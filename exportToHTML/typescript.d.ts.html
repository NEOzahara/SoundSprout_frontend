<html>
<head>
<title>typescript.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #6aab73;}
.s5 { color: #5f826b; font-style: italic;}
.s6 { color: #2aacb8;}
.s7 { color: #67a37c; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
typescript.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/*! ***************************************************************************** 
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use 
this file except in compliance with the License. You may obtain a copy of the 
License at http://www.apache.org/licenses/LICENSE-2.0 
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY 
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED 
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions 
and limitations under the License. 
***************************************************************************** */</span>

<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">const </span><span class="s1">versionMajorMinor </span><span class="s2">= </span><span class="s4">&quot;4.9&quot;</span><span class="s2">;</span>
    <span class="s5">/** The version of the TypeScript compiler release */</span>
    <span class="s3">const </span><span class="s1">version</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Type of objects whose values are all of the same type.</span>
     <span class="s5">* The `in` and `for-in` operators can *not* be safely used,</span>
     <span class="s5">* since `Object.prototype` may be modified by outside code.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">MapLike</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s2">[</span><span class="s1">index</span><span class="s2">: </span><span class="s1">string</span><span class="s2">]: </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SortedReadonlyArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s4">&quot; __sortedArrayBrand&quot;</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SortedArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">Array</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s4">&quot; __sortedArrayBrand&quot;</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** Common read methods for ES6 Map/Set. */</span>
    <span class="s3">interface </span><span class="s1">ReadonlyCollection</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt; {</span>
        <span class="s1">readonly size</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">has</span><span class="s2">(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">K</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">keys</span><span class="s2">(): </span><span class="s1">Iterator</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s5">/** Common write methods for ES6 Map/Set. */</span>
    <span class="s3">interface </span><span class="s1">Collection</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyCollection</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt; {</span>
        <span class="s3">delete</span><span class="s2">(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">K</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">clear</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** ES6 Map interface, only read methods included. */</span>
    <span class="s3">interface </span><span class="s1">ReadonlyESMap</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">, </span><span class="s1">V</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyCollection</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt; {</span>
        <span class="s1">get</span><span class="s2">(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">K</span><span class="s2">): </span><span class="s1">V </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">values</span><span class="s2">(): </span><span class="s1">Iterator</span><span class="s2">&lt;</span><span class="s1">V</span><span class="s2">&gt;;</span>
        <span class="s1">entries</span><span class="s2">(): </span><span class="s1">Iterator</span><span class="s2">&lt;[</span><span class="s1">K</span><span class="s2">, </span><span class="s1">V</span><span class="s2">]&gt;;</span>
        <span class="s1">forEach</span><span class="s2">(</span><span class="s1">action</span><span class="s2">: (</span><span class="s1">value</span><span class="s2">: </span><span class="s1">V</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">K</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* ES6 Map interface, only read methods included.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">ReadonlyMap</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyESMap</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">, </span><span class="s1">T</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s5">/** ES6 Map interface. */</span>
    <span class="s3">interface </span><span class="s1">ESMap</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">, </span><span class="s1">V</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyESMap</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">, </span><span class="s1">V</span><span class="s2">&gt;, </span><span class="s1">Collection</span><span class="s2">&lt;</span><span class="s1">K</span><span class="s2">&gt; {</span>
        <span class="s1">set</span><span class="s2">(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">K</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">V</span><span class="s2">): </span><span class="s3">this</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* ES6 Map interface.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">Map</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ESMap</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">, </span><span class="s1">T</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s5">/** ES6 Set interface, only read methods included. */</span>
    <span class="s3">interface </span><span class="s1">ReadonlySet</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyCollection</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s1">has</span><span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">values</span><span class="s2">(): </span><span class="s1">Iterator</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
        <span class="s1">entries</span><span class="s2">(): </span><span class="s1">Iterator</span><span class="s2">&lt;[</span><span class="s1">T</span><span class="s2">, </span><span class="s1">T</span><span class="s2">]&gt;;</span>
        <span class="s1">forEach</span><span class="s2">(</span><span class="s1">action</span><span class="s2">: (</span><span class="s1">value</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">T</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** ES6 Set interface. */</span>
    <span class="s3">interface </span><span class="s1">Set</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlySet</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">Collection</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s1">add</span><span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s3">this</span><span class="s2">;</span>
        <span class="s3">delete</span><span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** ES6 Iterator type. */</span>
    <span class="s3">interface </span><span class="s1">Iterator</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s1">next</span><span class="s2">(): {</span>
            <span class="s1">value</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
            <span class="s1">done</span><span class="s2">?: </span><span class="s3">false</span><span class="s2">;</span>
        <span class="s2">} | {</span>
            <span class="s1">value</span><span class="s2">: </span><span class="s3">void</span><span class="s2">;</span>
            <span class="s1">done</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s5">/** Array that is only intended to be pushed to, never read. */</span>
    <span class="s3">interface </span><span class="s1">Push</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s1">push</span><span class="s2">(</span><span class="s1">...values</span><span class="s2">: </span><span class="s1">T</span><span class="s2">[]): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">export </span><span class="s1">type Path </span><span class="s2">= </span><span class="s1">string </span><span class="s2">&amp; {</span>
        <span class="s1">__pathBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s3">export interface </span><span class="s1">TextRange </span><span class="s2">{</span>
        <span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ReadonlyTextRange </span><span class="s2">{</span>
        <span class="s1">readonly pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">readonly end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">SyntaxKind </span><span class="s2">{</span>
        <span class="s1">Unknown </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">EndOfFileToken </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">SingleLineCommentTrivia </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">MultiLineCommentTrivia </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">NewLineTrivia </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">WhitespaceTrivia </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">ShebangTrivia </span><span class="s2">= </span><span class="s6">6</span><span class="s2">,</span>
        <span class="s1">ConflictMarkerTrivia </span><span class="s2">= </span><span class="s6">7</span><span class="s2">,</span>
        <span class="s1">NumericLiteral </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">BigIntLiteral </span><span class="s2">= </span><span class="s6">9</span><span class="s2">,</span>
        <span class="s1">StringLiteral </span><span class="s2">= </span><span class="s6">10</span><span class="s2">,</span>
        <span class="s1">JsxText </span><span class="s2">= </span><span class="s6">11</span><span class="s2">,</span>
        <span class="s1">JsxTextAllWhiteSpaces </span><span class="s2">= </span><span class="s6">12</span><span class="s2">,</span>
        <span class="s1">RegularExpressionLiteral </span><span class="s2">= </span><span class="s6">13</span><span class="s2">,</span>
        <span class="s1">NoSubstitutionTemplateLiteral </span><span class="s2">= </span><span class="s6">14</span><span class="s2">,</span>
        <span class="s1">TemplateHead </span><span class="s2">= </span><span class="s6">15</span><span class="s2">,</span>
        <span class="s1">TemplateMiddle </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">TemplateTail </span><span class="s2">= </span><span class="s6">17</span><span class="s2">,</span>
        <span class="s1">OpenBraceToken </span><span class="s2">= </span><span class="s6">18</span><span class="s2">,</span>
        <span class="s1">CloseBraceToken </span><span class="s2">= </span><span class="s6">19</span><span class="s2">,</span>
        <span class="s1">OpenParenToken </span><span class="s2">= </span><span class="s6">20</span><span class="s2">,</span>
        <span class="s1">CloseParenToken </span><span class="s2">= </span><span class="s6">21</span><span class="s2">,</span>
        <span class="s1">OpenBracketToken </span><span class="s2">= </span><span class="s6">22</span><span class="s2">,</span>
        <span class="s1">CloseBracketToken </span><span class="s2">= </span><span class="s6">23</span><span class="s2">,</span>
        <span class="s1">DotToken </span><span class="s2">= </span><span class="s6">24</span><span class="s2">,</span>
        <span class="s1">DotDotDotToken </span><span class="s2">= </span><span class="s6">25</span><span class="s2">,</span>
        <span class="s1">SemicolonToken </span><span class="s2">= </span><span class="s6">26</span><span class="s2">,</span>
        <span class="s1">CommaToken </span><span class="s2">= </span><span class="s6">27</span><span class="s2">,</span>
        <span class="s1">QuestionDotToken </span><span class="s2">= </span><span class="s6">28</span><span class="s2">,</span>
        <span class="s1">LessThanToken </span><span class="s2">= </span><span class="s6">29</span><span class="s2">,</span>
        <span class="s1">LessThanSlashToken </span><span class="s2">= </span><span class="s6">30</span><span class="s2">,</span>
        <span class="s1">GreaterThanToken </span><span class="s2">= </span><span class="s6">31</span><span class="s2">,</span>
        <span class="s1">LessThanEqualsToken </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">GreaterThanEqualsToken </span><span class="s2">= </span><span class="s6">33</span><span class="s2">,</span>
        <span class="s1">EqualsEqualsToken </span><span class="s2">= </span><span class="s6">34</span><span class="s2">,</span>
        <span class="s1">ExclamationEqualsToken </span><span class="s2">= </span><span class="s6">35</span><span class="s2">,</span>
        <span class="s1">EqualsEqualsEqualsToken </span><span class="s2">= </span><span class="s6">36</span><span class="s2">,</span>
        <span class="s1">ExclamationEqualsEqualsToken </span><span class="s2">= </span><span class="s6">37</span><span class="s2">,</span>
        <span class="s1">EqualsGreaterThanToken </span><span class="s2">= </span><span class="s6">38</span><span class="s2">,</span>
        <span class="s1">PlusToken </span><span class="s2">= </span><span class="s6">39</span><span class="s2">,</span>
        <span class="s1">MinusToken </span><span class="s2">= </span><span class="s6">40</span><span class="s2">,</span>
        <span class="s1">AsteriskToken </span><span class="s2">= </span><span class="s6">41</span><span class="s2">,</span>
        <span class="s1">AsteriskAsteriskToken </span><span class="s2">= </span><span class="s6">42</span><span class="s2">,</span>
        <span class="s1">SlashToken </span><span class="s2">= </span><span class="s6">43</span><span class="s2">,</span>
        <span class="s1">PercentToken </span><span class="s2">= </span><span class="s6">44</span><span class="s2">,</span>
        <span class="s1">PlusPlusToken </span><span class="s2">= </span><span class="s6">45</span><span class="s2">,</span>
        <span class="s1">MinusMinusToken </span><span class="s2">= </span><span class="s6">46</span><span class="s2">,</span>
        <span class="s1">LessThanLessThanToken </span><span class="s2">= </span><span class="s6">47</span><span class="s2">,</span>
        <span class="s1">GreaterThanGreaterThanToken </span><span class="s2">= </span><span class="s6">48</span><span class="s2">,</span>
        <span class="s1">GreaterThanGreaterThanGreaterThanToken </span><span class="s2">= </span><span class="s6">49</span><span class="s2">,</span>
        <span class="s1">AmpersandToken </span><span class="s2">= </span><span class="s6">50</span><span class="s2">,</span>
        <span class="s1">BarToken </span><span class="s2">= </span><span class="s6">51</span><span class="s2">,</span>
        <span class="s1">CaretToken </span><span class="s2">= </span><span class="s6">52</span><span class="s2">,</span>
        <span class="s1">ExclamationToken </span><span class="s2">= </span><span class="s6">53</span><span class="s2">,</span>
        <span class="s1">TildeToken </span><span class="s2">= </span><span class="s6">54</span><span class="s2">,</span>
        <span class="s1">AmpersandAmpersandToken </span><span class="s2">= </span><span class="s6">55</span><span class="s2">,</span>
        <span class="s1">BarBarToken </span><span class="s2">= </span><span class="s6">56</span><span class="s2">,</span>
        <span class="s1">QuestionToken </span><span class="s2">= </span><span class="s6">57</span><span class="s2">,</span>
        <span class="s1">ColonToken </span><span class="s2">= </span><span class="s6">58</span><span class="s2">,</span>
        <span class="s1">AtToken </span><span class="s2">= </span><span class="s6">59</span><span class="s2">,</span>
        <span class="s1">QuestionQuestionToken </span><span class="s2">= </span><span class="s6">60</span><span class="s2">,</span>
        <span class="s5">/** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */</span>
        <span class="s1">BacktickToken </span><span class="s2">= </span><span class="s6">61</span><span class="s2">,</span>
        <span class="s5">/** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */</span>
        <span class="s1">HashToken </span><span class="s2">= </span><span class="s6">62</span><span class="s2">,</span>
        <span class="s1">EqualsToken </span><span class="s2">= </span><span class="s6">63</span><span class="s2">,</span>
        <span class="s1">PlusEqualsToken </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">MinusEqualsToken </span><span class="s2">= </span><span class="s6">65</span><span class="s2">,</span>
        <span class="s1">AsteriskEqualsToken </span><span class="s2">= </span><span class="s6">66</span><span class="s2">,</span>
        <span class="s1">AsteriskAsteriskEqualsToken </span><span class="s2">= </span><span class="s6">67</span><span class="s2">,</span>
        <span class="s1">SlashEqualsToken </span><span class="s2">= </span><span class="s6">68</span><span class="s2">,</span>
        <span class="s1">PercentEqualsToken </span><span class="s2">= </span><span class="s6">69</span><span class="s2">,</span>
        <span class="s1">LessThanLessThanEqualsToken </span><span class="s2">= </span><span class="s6">70</span><span class="s2">,</span>
        <span class="s1">GreaterThanGreaterThanEqualsToken </span><span class="s2">= </span><span class="s6">71</span><span class="s2">,</span>
        <span class="s1">GreaterThanGreaterThanGreaterThanEqualsToken </span><span class="s2">= </span><span class="s6">72</span><span class="s2">,</span>
        <span class="s1">AmpersandEqualsToken </span><span class="s2">= </span><span class="s6">73</span><span class="s2">,</span>
        <span class="s1">BarEqualsToken </span><span class="s2">= </span><span class="s6">74</span><span class="s2">,</span>
        <span class="s1">BarBarEqualsToken </span><span class="s2">= </span><span class="s6">75</span><span class="s2">,</span>
        <span class="s1">AmpersandAmpersandEqualsToken </span><span class="s2">= </span><span class="s6">76</span><span class="s2">,</span>
        <span class="s1">QuestionQuestionEqualsToken </span><span class="s2">= </span><span class="s6">77</span><span class="s2">,</span>
        <span class="s1">CaretEqualsToken </span><span class="s2">= </span><span class="s6">78</span><span class="s2">,</span>
        <span class="s1">Identifier </span><span class="s2">= </span><span class="s6">79</span><span class="s2">,</span>
        <span class="s1">PrivateIdentifier </span><span class="s2">= </span><span class="s6">80</span><span class="s2">,</span>
        <span class="s1">BreakKeyword </span><span class="s2">= </span><span class="s6">81</span><span class="s2">,</span>
        <span class="s1">CaseKeyword </span><span class="s2">= </span><span class="s6">82</span><span class="s2">,</span>
        <span class="s1">CatchKeyword </span><span class="s2">= </span><span class="s6">83</span><span class="s2">,</span>
        <span class="s1">ClassKeyword </span><span class="s2">= </span><span class="s6">84</span><span class="s2">,</span>
        <span class="s1">ConstKeyword </span><span class="s2">= </span><span class="s6">85</span><span class="s2">,</span>
        <span class="s1">ContinueKeyword </span><span class="s2">= </span><span class="s6">86</span><span class="s2">,</span>
        <span class="s1">DebuggerKeyword </span><span class="s2">= </span><span class="s6">87</span><span class="s2">,</span>
        <span class="s1">DefaultKeyword </span><span class="s2">= </span><span class="s6">88</span><span class="s2">,</span>
        <span class="s1">DeleteKeyword </span><span class="s2">= </span><span class="s6">89</span><span class="s2">,</span>
        <span class="s1">DoKeyword </span><span class="s2">= </span><span class="s6">90</span><span class="s2">,</span>
        <span class="s1">ElseKeyword </span><span class="s2">= </span><span class="s6">91</span><span class="s2">,</span>
        <span class="s1">EnumKeyword </span><span class="s2">= </span><span class="s6">92</span><span class="s2">,</span>
        <span class="s1">ExportKeyword </span><span class="s2">= </span><span class="s6">93</span><span class="s2">,</span>
        <span class="s1">ExtendsKeyword </span><span class="s2">= </span><span class="s6">94</span><span class="s2">,</span>
        <span class="s1">FalseKeyword </span><span class="s2">= </span><span class="s6">95</span><span class="s2">,</span>
        <span class="s1">FinallyKeyword </span><span class="s2">= </span><span class="s6">96</span><span class="s2">,</span>
        <span class="s1">ForKeyword </span><span class="s2">= </span><span class="s6">97</span><span class="s2">,</span>
        <span class="s1">FunctionKeyword </span><span class="s2">= </span><span class="s6">98</span><span class="s2">,</span>
        <span class="s1">IfKeyword </span><span class="s2">= </span><span class="s6">99</span><span class="s2">,</span>
        <span class="s1">ImportKeyword </span><span class="s2">= </span><span class="s6">100</span><span class="s2">,</span>
        <span class="s1">InKeyword </span><span class="s2">= </span><span class="s6">101</span><span class="s2">,</span>
        <span class="s1">InstanceOfKeyword </span><span class="s2">= </span><span class="s6">102</span><span class="s2">,</span>
        <span class="s1">NewKeyword </span><span class="s2">= </span><span class="s6">103</span><span class="s2">,</span>
        <span class="s1">NullKeyword </span><span class="s2">= </span><span class="s6">104</span><span class="s2">,</span>
        <span class="s1">ReturnKeyword </span><span class="s2">= </span><span class="s6">105</span><span class="s2">,</span>
        <span class="s1">SuperKeyword </span><span class="s2">= </span><span class="s6">106</span><span class="s2">,</span>
        <span class="s1">SwitchKeyword </span><span class="s2">= </span><span class="s6">107</span><span class="s2">,</span>
        <span class="s1">ThisKeyword </span><span class="s2">= </span><span class="s6">108</span><span class="s2">,</span>
        <span class="s1">ThrowKeyword </span><span class="s2">= </span><span class="s6">109</span><span class="s2">,</span>
        <span class="s1">TrueKeyword </span><span class="s2">= </span><span class="s6">110</span><span class="s2">,</span>
        <span class="s1">TryKeyword </span><span class="s2">= </span><span class="s6">111</span><span class="s2">,</span>
        <span class="s1">TypeOfKeyword </span><span class="s2">= </span><span class="s6">112</span><span class="s2">,</span>
        <span class="s1">VarKeyword </span><span class="s2">= </span><span class="s6">113</span><span class="s2">,</span>
        <span class="s1">VoidKeyword </span><span class="s2">= </span><span class="s6">114</span><span class="s2">,</span>
        <span class="s1">WhileKeyword </span><span class="s2">= </span><span class="s6">115</span><span class="s2">,</span>
        <span class="s1">WithKeyword </span><span class="s2">= </span><span class="s6">116</span><span class="s2">,</span>
        <span class="s1">ImplementsKeyword </span><span class="s2">= </span><span class="s6">117</span><span class="s2">,</span>
        <span class="s1">InterfaceKeyword </span><span class="s2">= </span><span class="s6">118</span><span class="s2">,</span>
        <span class="s1">LetKeyword </span><span class="s2">= </span><span class="s6">119</span><span class="s2">,</span>
        <span class="s1">PackageKeyword </span><span class="s2">= </span><span class="s6">120</span><span class="s2">,</span>
        <span class="s1">PrivateKeyword </span><span class="s2">= </span><span class="s6">121</span><span class="s2">,</span>
        <span class="s1">ProtectedKeyword </span><span class="s2">= </span><span class="s6">122</span><span class="s2">,</span>
        <span class="s1">PublicKeyword </span><span class="s2">= </span><span class="s6">123</span><span class="s2">,</span>
        <span class="s1">StaticKeyword </span><span class="s2">= </span><span class="s6">124</span><span class="s2">,</span>
        <span class="s1">YieldKeyword </span><span class="s2">= </span><span class="s6">125</span><span class="s2">,</span>
        <span class="s1">AbstractKeyword </span><span class="s2">= </span><span class="s6">126</span><span class="s2">,</span>
        <span class="s1">AccessorKeyword </span><span class="s2">= </span><span class="s6">127</span><span class="s2">,</span>
        <span class="s1">AsKeyword </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">AssertsKeyword </span><span class="s2">= </span><span class="s6">129</span><span class="s2">,</span>
        <span class="s1">AssertKeyword </span><span class="s2">= </span><span class="s6">130</span><span class="s2">,</span>
        <span class="s1">AnyKeyword </span><span class="s2">= </span><span class="s6">131</span><span class="s2">,</span>
        <span class="s1">AsyncKeyword </span><span class="s2">= </span><span class="s6">132</span><span class="s2">,</span>
        <span class="s1">AwaitKeyword </span><span class="s2">= </span><span class="s6">133</span><span class="s2">,</span>
        <span class="s1">BooleanKeyword </span><span class="s2">= </span><span class="s6">134</span><span class="s2">,</span>
        <span class="s1">ConstructorKeyword </span><span class="s2">= </span><span class="s6">135</span><span class="s2">,</span>
        <span class="s1">DeclareKeyword </span><span class="s2">= </span><span class="s6">136</span><span class="s2">,</span>
        <span class="s1">GetKeyword </span><span class="s2">= </span><span class="s6">137</span><span class="s2">,</span>
        <span class="s1">InferKeyword </span><span class="s2">= </span><span class="s6">138</span><span class="s2">,</span>
        <span class="s1">IntrinsicKeyword </span><span class="s2">= </span><span class="s6">139</span><span class="s2">,</span>
        <span class="s1">IsKeyword </span><span class="s2">= </span><span class="s6">140</span><span class="s2">,</span>
        <span class="s1">KeyOfKeyword </span><span class="s2">= </span><span class="s6">141</span><span class="s2">,</span>
        <span class="s1">ModuleKeyword </span><span class="s2">= </span><span class="s6">142</span><span class="s2">,</span>
        <span class="s1">NamespaceKeyword </span><span class="s2">= </span><span class="s6">143</span><span class="s2">,</span>
        <span class="s1">NeverKeyword </span><span class="s2">= </span><span class="s6">144</span><span class="s2">,</span>
        <span class="s1">OutKeyword </span><span class="s2">= </span><span class="s6">145</span><span class="s2">,</span>
        <span class="s1">ReadonlyKeyword </span><span class="s2">= </span><span class="s6">146</span><span class="s2">,</span>
        <span class="s1">RequireKeyword </span><span class="s2">= </span><span class="s6">147</span><span class="s2">,</span>
        <span class="s1">NumberKeyword </span><span class="s2">= </span><span class="s6">148</span><span class="s2">,</span>
        <span class="s1">ObjectKeyword </span><span class="s2">= </span><span class="s6">149</span><span class="s2">,</span>
        <span class="s1">SatisfiesKeyword </span><span class="s2">= </span><span class="s6">150</span><span class="s2">,</span>
        <span class="s1">SetKeyword </span><span class="s2">= </span><span class="s6">151</span><span class="s2">,</span>
        <span class="s1">StringKeyword </span><span class="s2">= </span><span class="s6">152</span><span class="s2">,</span>
        <span class="s1">SymbolKeyword </span><span class="s2">= </span><span class="s6">153</span><span class="s2">,</span>
        <span class="s1">TypeKeyword </span><span class="s2">= </span><span class="s6">154</span><span class="s2">,</span>
        <span class="s1">UndefinedKeyword </span><span class="s2">= </span><span class="s6">155</span><span class="s2">,</span>
        <span class="s1">UniqueKeyword </span><span class="s2">= </span><span class="s6">156</span><span class="s2">,</span>
        <span class="s1">UnknownKeyword </span><span class="s2">= </span><span class="s6">157</span><span class="s2">,</span>
        <span class="s1">FromKeyword </span><span class="s2">= </span><span class="s6">158</span><span class="s2">,</span>
        <span class="s1">GlobalKeyword </span><span class="s2">= </span><span class="s6">159</span><span class="s2">,</span>
        <span class="s1">BigIntKeyword </span><span class="s2">= </span><span class="s6">160</span><span class="s2">,</span>
        <span class="s1">OverrideKeyword </span><span class="s2">= </span><span class="s6">161</span><span class="s2">,</span>
        <span class="s1">OfKeyword </span><span class="s2">= </span><span class="s6">162</span><span class="s2">,</span>
        <span class="s1">QualifiedName </span><span class="s2">= </span><span class="s6">163</span><span class="s2">,</span>
        <span class="s1">ComputedPropertyName </span><span class="s2">= </span><span class="s6">164</span><span class="s2">,</span>
        <span class="s1">TypeParameter </span><span class="s2">= </span><span class="s6">165</span><span class="s2">,</span>
        <span class="s1">Parameter </span><span class="s2">= </span><span class="s6">166</span><span class="s2">,</span>
        <span class="s1">Decorator </span><span class="s2">= </span><span class="s6">167</span><span class="s2">,</span>
        <span class="s1">PropertySignature </span><span class="s2">= </span><span class="s6">168</span><span class="s2">,</span>
        <span class="s1">PropertyDeclaration </span><span class="s2">= </span><span class="s6">169</span><span class="s2">,</span>
        <span class="s1">MethodSignature </span><span class="s2">= </span><span class="s6">170</span><span class="s2">,</span>
        <span class="s1">MethodDeclaration </span><span class="s2">= </span><span class="s6">171</span><span class="s2">,</span>
        <span class="s1">ClassStaticBlockDeclaration </span><span class="s2">= </span><span class="s6">172</span><span class="s2">,</span>
        <span class="s1">Constructor </span><span class="s2">= </span><span class="s6">173</span><span class="s2">,</span>
        <span class="s1">GetAccessor </span><span class="s2">= </span><span class="s6">174</span><span class="s2">,</span>
        <span class="s1">SetAccessor </span><span class="s2">= </span><span class="s6">175</span><span class="s2">,</span>
        <span class="s1">CallSignature </span><span class="s2">= </span><span class="s6">176</span><span class="s2">,</span>
        <span class="s1">ConstructSignature </span><span class="s2">= </span><span class="s6">177</span><span class="s2">,</span>
        <span class="s1">IndexSignature </span><span class="s2">= </span><span class="s6">178</span><span class="s2">,</span>
        <span class="s1">TypePredicate </span><span class="s2">= </span><span class="s6">179</span><span class="s2">,</span>
        <span class="s1">TypeReference </span><span class="s2">= </span><span class="s6">180</span><span class="s2">,</span>
        <span class="s1">FunctionType </span><span class="s2">= </span><span class="s6">181</span><span class="s2">,</span>
        <span class="s1">ConstructorType </span><span class="s2">= </span><span class="s6">182</span><span class="s2">,</span>
        <span class="s1">TypeQuery </span><span class="s2">= </span><span class="s6">183</span><span class="s2">,</span>
        <span class="s1">TypeLiteral </span><span class="s2">= </span><span class="s6">184</span><span class="s2">,</span>
        <span class="s1">ArrayType </span><span class="s2">= </span><span class="s6">185</span><span class="s2">,</span>
        <span class="s1">TupleType </span><span class="s2">= </span><span class="s6">186</span><span class="s2">,</span>
        <span class="s1">OptionalType </span><span class="s2">= </span><span class="s6">187</span><span class="s2">,</span>
        <span class="s1">RestType </span><span class="s2">= </span><span class="s6">188</span><span class="s2">,</span>
        <span class="s1">UnionType </span><span class="s2">= </span><span class="s6">189</span><span class="s2">,</span>
        <span class="s1">IntersectionType </span><span class="s2">= </span><span class="s6">190</span><span class="s2">,</span>
        <span class="s1">ConditionalType </span><span class="s2">= </span><span class="s6">191</span><span class="s2">,</span>
        <span class="s1">InferType </span><span class="s2">= </span><span class="s6">192</span><span class="s2">,</span>
        <span class="s1">ParenthesizedType </span><span class="s2">= </span><span class="s6">193</span><span class="s2">,</span>
        <span class="s1">ThisType </span><span class="s2">= </span><span class="s6">194</span><span class="s2">,</span>
        <span class="s1">TypeOperator </span><span class="s2">= </span><span class="s6">195</span><span class="s2">,</span>
        <span class="s1">IndexedAccessType </span><span class="s2">= </span><span class="s6">196</span><span class="s2">,</span>
        <span class="s1">MappedType </span><span class="s2">= </span><span class="s6">197</span><span class="s2">,</span>
        <span class="s1">LiteralType </span><span class="s2">= </span><span class="s6">198</span><span class="s2">,</span>
        <span class="s1">NamedTupleMember </span><span class="s2">= </span><span class="s6">199</span><span class="s2">,</span>
        <span class="s1">TemplateLiteralType </span><span class="s2">= </span><span class="s6">200</span><span class="s2">,</span>
        <span class="s1">TemplateLiteralTypeSpan </span><span class="s2">= </span><span class="s6">201</span><span class="s2">,</span>
        <span class="s1">ImportType </span><span class="s2">= </span><span class="s6">202</span><span class="s2">,</span>
        <span class="s1">ObjectBindingPattern </span><span class="s2">= </span><span class="s6">203</span><span class="s2">,</span>
        <span class="s1">ArrayBindingPattern </span><span class="s2">= </span><span class="s6">204</span><span class="s2">,</span>
        <span class="s1">BindingElement </span><span class="s2">= </span><span class="s6">205</span><span class="s2">,</span>
        <span class="s1">ArrayLiteralExpression </span><span class="s2">= </span><span class="s6">206</span><span class="s2">,</span>
        <span class="s1">ObjectLiteralExpression </span><span class="s2">= </span><span class="s6">207</span><span class="s2">,</span>
        <span class="s1">PropertyAccessExpression </span><span class="s2">= </span><span class="s6">208</span><span class="s2">,</span>
        <span class="s1">ElementAccessExpression </span><span class="s2">= </span><span class="s6">209</span><span class="s2">,</span>
        <span class="s1">CallExpression </span><span class="s2">= </span><span class="s6">210</span><span class="s2">,</span>
        <span class="s1">NewExpression </span><span class="s2">= </span><span class="s6">211</span><span class="s2">,</span>
        <span class="s1">TaggedTemplateExpression </span><span class="s2">= </span><span class="s6">212</span><span class="s2">,</span>
        <span class="s1">TypeAssertionExpression </span><span class="s2">= </span><span class="s6">213</span><span class="s2">,</span>
        <span class="s1">ParenthesizedExpression </span><span class="s2">= </span><span class="s6">214</span><span class="s2">,</span>
        <span class="s1">FunctionExpression </span><span class="s2">= </span><span class="s6">215</span><span class="s2">,</span>
        <span class="s1">ArrowFunction </span><span class="s2">= </span><span class="s6">216</span><span class="s2">,</span>
        <span class="s1">DeleteExpression </span><span class="s2">= </span><span class="s6">217</span><span class="s2">,</span>
        <span class="s1">TypeOfExpression </span><span class="s2">= </span><span class="s6">218</span><span class="s2">,</span>
        <span class="s1">VoidExpression </span><span class="s2">= </span><span class="s6">219</span><span class="s2">,</span>
        <span class="s1">AwaitExpression </span><span class="s2">= </span><span class="s6">220</span><span class="s2">,</span>
        <span class="s1">PrefixUnaryExpression </span><span class="s2">= </span><span class="s6">221</span><span class="s2">,</span>
        <span class="s1">PostfixUnaryExpression </span><span class="s2">= </span><span class="s6">222</span><span class="s2">,</span>
        <span class="s1">BinaryExpression </span><span class="s2">= </span><span class="s6">223</span><span class="s2">,</span>
        <span class="s1">ConditionalExpression </span><span class="s2">= </span><span class="s6">224</span><span class="s2">,</span>
        <span class="s1">TemplateExpression </span><span class="s2">= </span><span class="s6">225</span><span class="s2">,</span>
        <span class="s1">YieldExpression </span><span class="s2">= </span><span class="s6">226</span><span class="s2">,</span>
        <span class="s1">SpreadElement </span><span class="s2">= </span><span class="s6">227</span><span class="s2">,</span>
        <span class="s1">ClassExpression </span><span class="s2">= </span><span class="s6">228</span><span class="s2">,</span>
        <span class="s1">OmittedExpression </span><span class="s2">= </span><span class="s6">229</span><span class="s2">,</span>
        <span class="s1">ExpressionWithTypeArguments </span><span class="s2">= </span><span class="s6">230</span><span class="s2">,</span>
        <span class="s1">AsExpression </span><span class="s2">= </span><span class="s6">231</span><span class="s2">,</span>
        <span class="s1">NonNullExpression </span><span class="s2">= </span><span class="s6">232</span><span class="s2">,</span>
        <span class="s1">MetaProperty </span><span class="s2">= </span><span class="s6">233</span><span class="s2">,</span>
        <span class="s1">SyntheticExpression </span><span class="s2">= </span><span class="s6">234</span><span class="s2">,</span>
        <span class="s1">SatisfiesExpression </span><span class="s2">= </span><span class="s6">235</span><span class="s2">,</span>
        <span class="s1">TemplateSpan </span><span class="s2">= </span><span class="s6">236</span><span class="s2">,</span>
        <span class="s1">SemicolonClassElement </span><span class="s2">= </span><span class="s6">237</span><span class="s2">,</span>
        <span class="s1">Block </span><span class="s2">= </span><span class="s6">238</span><span class="s2">,</span>
        <span class="s1">EmptyStatement </span><span class="s2">= </span><span class="s6">239</span><span class="s2">,</span>
        <span class="s1">VariableStatement </span><span class="s2">= </span><span class="s6">240</span><span class="s2">,</span>
        <span class="s1">ExpressionStatement </span><span class="s2">= </span><span class="s6">241</span><span class="s2">,</span>
        <span class="s1">IfStatement </span><span class="s2">= </span><span class="s6">242</span><span class="s2">,</span>
        <span class="s1">DoStatement </span><span class="s2">= </span><span class="s6">243</span><span class="s2">,</span>
        <span class="s1">WhileStatement </span><span class="s2">= </span><span class="s6">244</span><span class="s2">,</span>
        <span class="s1">ForStatement </span><span class="s2">= </span><span class="s6">245</span><span class="s2">,</span>
        <span class="s1">ForInStatement </span><span class="s2">= </span><span class="s6">246</span><span class="s2">,</span>
        <span class="s1">ForOfStatement </span><span class="s2">= </span><span class="s6">247</span><span class="s2">,</span>
        <span class="s1">ContinueStatement </span><span class="s2">= </span><span class="s6">248</span><span class="s2">,</span>
        <span class="s1">BreakStatement </span><span class="s2">= </span><span class="s6">249</span><span class="s2">,</span>
        <span class="s1">ReturnStatement </span><span class="s2">= </span><span class="s6">250</span><span class="s2">,</span>
        <span class="s1">WithStatement </span><span class="s2">= </span><span class="s6">251</span><span class="s2">,</span>
        <span class="s1">SwitchStatement </span><span class="s2">= </span><span class="s6">252</span><span class="s2">,</span>
        <span class="s1">LabeledStatement </span><span class="s2">= </span><span class="s6">253</span><span class="s2">,</span>
        <span class="s1">ThrowStatement </span><span class="s2">= </span><span class="s6">254</span><span class="s2">,</span>
        <span class="s1">TryStatement </span><span class="s2">= </span><span class="s6">255</span><span class="s2">,</span>
        <span class="s1">DebuggerStatement </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">VariableDeclaration </span><span class="s2">= </span><span class="s6">257</span><span class="s2">,</span>
        <span class="s1">VariableDeclarationList </span><span class="s2">= </span><span class="s6">258</span><span class="s2">,</span>
        <span class="s1">FunctionDeclaration </span><span class="s2">= </span><span class="s6">259</span><span class="s2">,</span>
        <span class="s1">ClassDeclaration </span><span class="s2">= </span><span class="s6">260</span><span class="s2">,</span>
        <span class="s1">InterfaceDeclaration </span><span class="s2">= </span><span class="s6">261</span><span class="s2">,</span>
        <span class="s1">TypeAliasDeclaration </span><span class="s2">= </span><span class="s6">262</span><span class="s2">,</span>
        <span class="s1">EnumDeclaration </span><span class="s2">= </span><span class="s6">263</span><span class="s2">,</span>
        <span class="s1">ModuleDeclaration </span><span class="s2">= </span><span class="s6">264</span><span class="s2">,</span>
        <span class="s1">ModuleBlock </span><span class="s2">= </span><span class="s6">265</span><span class="s2">,</span>
        <span class="s1">CaseBlock </span><span class="s2">= </span><span class="s6">266</span><span class="s2">,</span>
        <span class="s1">NamespaceExportDeclaration </span><span class="s2">= </span><span class="s6">267</span><span class="s2">,</span>
        <span class="s1">ImportEqualsDeclaration </span><span class="s2">= </span><span class="s6">268</span><span class="s2">,</span>
        <span class="s1">ImportDeclaration </span><span class="s2">= </span><span class="s6">269</span><span class="s2">,</span>
        <span class="s1">ImportClause </span><span class="s2">= </span><span class="s6">270</span><span class="s2">,</span>
        <span class="s1">NamespaceImport </span><span class="s2">= </span><span class="s6">271</span><span class="s2">,</span>
        <span class="s1">NamedImports </span><span class="s2">= </span><span class="s6">272</span><span class="s2">,</span>
        <span class="s1">ImportSpecifier </span><span class="s2">= </span><span class="s6">273</span><span class="s2">,</span>
        <span class="s1">ExportAssignment </span><span class="s2">= </span><span class="s6">274</span><span class="s2">,</span>
        <span class="s1">ExportDeclaration </span><span class="s2">= </span><span class="s6">275</span><span class="s2">,</span>
        <span class="s1">NamedExports </span><span class="s2">= </span><span class="s6">276</span><span class="s2">,</span>
        <span class="s1">NamespaceExport </span><span class="s2">= </span><span class="s6">277</span><span class="s2">,</span>
        <span class="s1">ExportSpecifier </span><span class="s2">= </span><span class="s6">278</span><span class="s2">,</span>
        <span class="s1">MissingDeclaration </span><span class="s2">= </span><span class="s6">279</span><span class="s2">,</span>
        <span class="s1">ExternalModuleReference </span><span class="s2">= </span><span class="s6">280</span><span class="s2">,</span>
        <span class="s1">JsxElement </span><span class="s2">= </span><span class="s6">281</span><span class="s2">,</span>
        <span class="s1">JsxSelfClosingElement </span><span class="s2">= </span><span class="s6">282</span><span class="s2">,</span>
        <span class="s1">JsxOpeningElement </span><span class="s2">= </span><span class="s6">283</span><span class="s2">,</span>
        <span class="s1">JsxClosingElement </span><span class="s2">= </span><span class="s6">284</span><span class="s2">,</span>
        <span class="s1">JsxFragment </span><span class="s2">= </span><span class="s6">285</span><span class="s2">,</span>
        <span class="s1">JsxOpeningFragment </span><span class="s2">= </span><span class="s6">286</span><span class="s2">,</span>
        <span class="s1">JsxClosingFragment </span><span class="s2">= </span><span class="s6">287</span><span class="s2">,</span>
        <span class="s1">JsxAttribute </span><span class="s2">= </span><span class="s6">288</span><span class="s2">,</span>
        <span class="s1">JsxAttributes </span><span class="s2">= </span><span class="s6">289</span><span class="s2">,</span>
        <span class="s1">JsxSpreadAttribute </span><span class="s2">= </span><span class="s6">290</span><span class="s2">,</span>
        <span class="s1">JsxExpression </span><span class="s2">= </span><span class="s6">291</span><span class="s2">,</span>
        <span class="s1">CaseClause </span><span class="s2">= </span><span class="s6">292</span><span class="s2">,</span>
        <span class="s1">DefaultClause </span><span class="s2">= </span><span class="s6">293</span><span class="s2">,</span>
        <span class="s1">HeritageClause </span><span class="s2">= </span><span class="s6">294</span><span class="s2">,</span>
        <span class="s1">CatchClause </span><span class="s2">= </span><span class="s6">295</span><span class="s2">,</span>
        <span class="s1">AssertClause </span><span class="s2">= </span><span class="s6">296</span><span class="s2">,</span>
        <span class="s1">AssertEntry </span><span class="s2">= </span><span class="s6">297</span><span class="s2">,</span>
        <span class="s1">ImportTypeAssertionContainer </span><span class="s2">= </span><span class="s6">298</span><span class="s2">,</span>
        <span class="s1">PropertyAssignment </span><span class="s2">= </span><span class="s6">299</span><span class="s2">,</span>
        <span class="s1">ShorthandPropertyAssignment </span><span class="s2">= </span><span class="s6">300</span><span class="s2">,</span>
        <span class="s1">SpreadAssignment </span><span class="s2">= </span><span class="s6">301</span><span class="s2">,</span>
        <span class="s1">EnumMember </span><span class="s2">= </span><span class="s6">302</span><span class="s2">,</span>
        <span class="s1">UnparsedPrologue </span><span class="s2">= </span><span class="s6">303</span><span class="s2">,</span>
        <span class="s1">UnparsedPrepend </span><span class="s2">= </span><span class="s6">304</span><span class="s2">,</span>
        <span class="s1">UnparsedText </span><span class="s2">= </span><span class="s6">305</span><span class="s2">,</span>
        <span class="s1">UnparsedInternalText </span><span class="s2">= </span><span class="s6">306</span><span class="s2">,</span>
        <span class="s1">UnparsedSyntheticReference </span><span class="s2">= </span><span class="s6">307</span><span class="s2">,</span>
        <span class="s1">SourceFile </span><span class="s2">= </span><span class="s6">308</span><span class="s2">,</span>
        <span class="s1">Bundle </span><span class="s2">= </span><span class="s6">309</span><span class="s2">,</span>
        <span class="s1">UnparsedSource </span><span class="s2">= </span><span class="s6">310</span><span class="s2">,</span>
        <span class="s1">InputFiles </span><span class="s2">= </span><span class="s6">311</span><span class="s2">,</span>
        <span class="s1">JSDocTypeExpression </span><span class="s2">= </span><span class="s6">312</span><span class="s2">,</span>
        <span class="s1">JSDocNameReference </span><span class="s2">= </span><span class="s6">313</span><span class="s2">,</span>
        <span class="s1">JSDocMemberName </span><span class="s2">= </span><span class="s6">314</span><span class="s2">,</span>
        <span class="s1">JSDocAllType </span><span class="s2">= </span><span class="s6">315</span><span class="s2">,</span>
        <span class="s1">JSDocUnknownType </span><span class="s2">= </span><span class="s6">316</span><span class="s2">,</span>
        <span class="s1">JSDocNullableType </span><span class="s2">= </span><span class="s6">317</span><span class="s2">,</span>
        <span class="s1">JSDocNonNullableType </span><span class="s2">= </span><span class="s6">318</span><span class="s2">,</span>
        <span class="s1">JSDocOptionalType </span><span class="s2">= </span><span class="s6">319</span><span class="s2">,</span>
        <span class="s1">JSDocFunctionType </span><span class="s2">= </span><span class="s6">320</span><span class="s2">,</span>
        <span class="s1">JSDocVariadicType </span><span class="s2">= </span><span class="s6">321</span><span class="s2">,</span>
        <span class="s1">JSDocNamepathType </span><span class="s2">= </span><span class="s6">322</span><span class="s2">,</span>
        <span class="s1">JSDoc </span><span class="s2">= </span><span class="s6">323</span><span class="s2">,</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use SyntaxKind.JSDoc */</span>
        <span class="s1">JSDocComment </span><span class="s2">= </span><span class="s6">323</span><span class="s2">,</span>
        <span class="s1">JSDocText </span><span class="s2">= </span><span class="s6">324</span><span class="s2">,</span>
        <span class="s1">JSDocTypeLiteral </span><span class="s2">= </span><span class="s6">325</span><span class="s2">,</span>
        <span class="s1">JSDocSignature </span><span class="s2">= </span><span class="s6">326</span><span class="s2">,</span>
        <span class="s1">JSDocLink </span><span class="s2">= </span><span class="s6">327</span><span class="s2">,</span>
        <span class="s1">JSDocLinkCode </span><span class="s2">= </span><span class="s6">328</span><span class="s2">,</span>
        <span class="s1">JSDocLinkPlain </span><span class="s2">= </span><span class="s6">329</span><span class="s2">,</span>
        <span class="s1">JSDocTag </span><span class="s2">= </span><span class="s6">330</span><span class="s2">,</span>
        <span class="s1">JSDocAugmentsTag </span><span class="s2">= </span><span class="s6">331</span><span class="s2">,</span>
        <span class="s1">JSDocImplementsTag </span><span class="s2">= </span><span class="s6">332</span><span class="s2">,</span>
        <span class="s1">JSDocAuthorTag </span><span class="s2">= </span><span class="s6">333</span><span class="s2">,</span>
        <span class="s1">JSDocDeprecatedTag </span><span class="s2">= </span><span class="s6">334</span><span class="s2">,</span>
        <span class="s1">JSDocClassTag </span><span class="s2">= </span><span class="s6">335</span><span class="s2">,</span>
        <span class="s1">JSDocPublicTag </span><span class="s2">= </span><span class="s6">336</span><span class="s2">,</span>
        <span class="s1">JSDocPrivateTag </span><span class="s2">= </span><span class="s6">337</span><span class="s2">,</span>
        <span class="s1">JSDocProtectedTag </span><span class="s2">= </span><span class="s6">338</span><span class="s2">,</span>
        <span class="s1">JSDocReadonlyTag </span><span class="s2">= </span><span class="s6">339</span><span class="s2">,</span>
        <span class="s1">JSDocOverrideTag </span><span class="s2">= </span><span class="s6">340</span><span class="s2">,</span>
        <span class="s1">JSDocCallbackTag </span><span class="s2">= </span><span class="s6">341</span><span class="s2">,</span>
        <span class="s1">JSDocEnumTag </span><span class="s2">= </span><span class="s6">342</span><span class="s2">,</span>
        <span class="s1">JSDocParameterTag </span><span class="s2">= </span><span class="s6">343</span><span class="s2">,</span>
        <span class="s1">JSDocReturnTag </span><span class="s2">= </span><span class="s6">344</span><span class="s2">,</span>
        <span class="s1">JSDocThisTag </span><span class="s2">= </span><span class="s6">345</span><span class="s2">,</span>
        <span class="s1">JSDocTypeTag </span><span class="s2">= </span><span class="s6">346</span><span class="s2">,</span>
        <span class="s1">JSDocTemplateTag </span><span class="s2">= </span><span class="s6">347</span><span class="s2">,</span>
        <span class="s1">JSDocTypedefTag </span><span class="s2">= </span><span class="s6">348</span><span class="s2">,</span>
        <span class="s1">JSDocSeeTag </span><span class="s2">= </span><span class="s6">349</span><span class="s2">,</span>
        <span class="s1">JSDocPropertyTag </span><span class="s2">= </span><span class="s6">350</span><span class="s2">,</span>
        <span class="s1">SyntaxList </span><span class="s2">= </span><span class="s6">351</span><span class="s2">,</span>
        <span class="s1">NotEmittedStatement </span><span class="s2">= </span><span class="s6">352</span><span class="s2">,</span>
        <span class="s1">PartiallyEmittedExpression </span><span class="s2">= </span><span class="s6">353</span><span class="s2">,</span>
        <span class="s1">CommaListExpression </span><span class="s2">= </span><span class="s6">354</span><span class="s2">,</span>
        <span class="s1">MergeDeclarationMarker </span><span class="s2">= </span><span class="s6">355</span><span class="s2">,</span>
        <span class="s1">EndOfDeclarationMarker </span><span class="s2">= </span><span class="s6">356</span><span class="s2">,</span>
        <span class="s1">SyntheticReferenceExpression </span><span class="s2">= </span><span class="s6">357</span><span class="s2">,</span>
        <span class="s1">Count </span><span class="s2">= </span><span class="s6">358</span><span class="s2">,</span>
        <span class="s1">FirstAssignment </span><span class="s2">= </span><span class="s6">63</span><span class="s2">,</span>
        <span class="s1">LastAssignment </span><span class="s2">= </span><span class="s6">78</span><span class="s2">,</span>
        <span class="s1">FirstCompoundAssignment </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">LastCompoundAssignment </span><span class="s2">= </span><span class="s6">78</span><span class="s2">,</span>
        <span class="s1">FirstReservedWord </span><span class="s2">= </span><span class="s6">81</span><span class="s2">,</span>
        <span class="s1">LastReservedWord </span><span class="s2">= </span><span class="s6">116</span><span class="s2">,</span>
        <span class="s1">FirstKeyword </span><span class="s2">= </span><span class="s6">81</span><span class="s2">,</span>
        <span class="s1">LastKeyword </span><span class="s2">= </span><span class="s6">162</span><span class="s2">,</span>
        <span class="s1">FirstFutureReservedWord </span><span class="s2">= </span><span class="s6">117</span><span class="s2">,</span>
        <span class="s1">LastFutureReservedWord </span><span class="s2">= </span><span class="s6">125</span><span class="s2">,</span>
        <span class="s1">FirstTypeNode </span><span class="s2">= </span><span class="s6">179</span><span class="s2">,</span>
        <span class="s1">LastTypeNode </span><span class="s2">= </span><span class="s6">202</span><span class="s2">,</span>
        <span class="s1">FirstPunctuation </span><span class="s2">= </span><span class="s6">18</span><span class="s2">,</span>
        <span class="s1">LastPunctuation </span><span class="s2">= </span><span class="s6">78</span><span class="s2">,</span>
        <span class="s1">FirstToken </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">LastToken </span><span class="s2">= </span><span class="s6">162</span><span class="s2">,</span>
        <span class="s1">FirstTriviaToken </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">LastTriviaToken </span><span class="s2">= </span><span class="s6">7</span><span class="s2">,</span>
        <span class="s1">FirstLiteralToken </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">LastLiteralToken </span><span class="s2">= </span><span class="s6">14</span><span class="s2">,</span>
        <span class="s1">FirstTemplateToken </span><span class="s2">= </span><span class="s6">14</span><span class="s2">,</span>
        <span class="s1">LastTemplateToken </span><span class="s2">= </span><span class="s6">17</span><span class="s2">,</span>
        <span class="s1">FirstBinaryOperator </span><span class="s2">= </span><span class="s6">29</span><span class="s2">,</span>
        <span class="s1">LastBinaryOperator </span><span class="s2">= </span><span class="s6">78</span><span class="s2">,</span>
        <span class="s1">FirstStatement </span><span class="s2">= </span><span class="s6">240</span><span class="s2">,</span>
        <span class="s1">LastStatement </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">FirstNode </span><span class="s2">= </span><span class="s6">163</span><span class="s2">,</span>
        <span class="s1">FirstJSDocNode </span><span class="s2">= </span><span class="s6">312</span><span class="s2">,</span>
        <span class="s1">LastJSDocNode </span><span class="s2">= </span><span class="s6">350</span><span class="s2">,</span>
        <span class="s1">FirstJSDocTagNode </span><span class="s2">= </span><span class="s6">330</span><span class="s2">,</span>
        <span class="s1">LastJSDocTagNode </span><span class="s2">= </span><span class="s6">350</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type TriviaSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SingleLineCommentTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MultiLineCommentTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NewLineTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">WhitespaceTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ShebangTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConflictMarkerTrivia</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type LiteralSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NumericLiteral </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BigIntLiteral </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxText </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxTextAllWhiteSpaces </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">RegularExpressionLiteral </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type PseudoLiteralSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateHead </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateTail</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type PunctuationSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OpenBraceToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CloseBraceToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OpenParenToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CloseParenToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OpenBracketToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CloseBracketToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DotToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SemicolonToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CommaToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanSlashToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExclamationEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsEqualsEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExclamationEqualsEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsGreaterThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskAsteriskToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SlashToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PercentToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusPlusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusMinusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanLessThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanGreaterThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanGreaterThanGreaterThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AmpersandToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BarToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CaretToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TildeToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AmpersandAmpersandToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BarBarToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionQuestionToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ColonToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AtToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BacktickToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">HashToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskAsteriskEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SlashEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PercentEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanLessThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanGreaterThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanGreaterThanGreaterThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AmpersandEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BarEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CaretEqualsToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type KeywordSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AbstractKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AccessorKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AnyKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AssertsKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AssertKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsyncKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AwaitKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BigIntKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BooleanKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BreakKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CaseKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CatchKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ClassKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConstKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConstructorKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ContinueKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DebuggerKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DeclareKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DefaultKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DeleteKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DoKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ElseKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EnumKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExportKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExtendsKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FalseKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FinallyKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ForKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FromKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FunctionKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GetKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GlobalKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">IfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImplementsKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InferKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InstanceOfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InterfaceKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">IntrinsicKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">IsKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">KeyOfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LetKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ModuleKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NamespaceKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NeverKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NewKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NullKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NumberKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ObjectKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PackageKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PrivateKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ProtectedKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PublicKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OutKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OverrideKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">RequireKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ReturnKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SatisfiesKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SetKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">StaticKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">StringKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SuperKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SwitchKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SymbolKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ThisKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ThrowKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TrueKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TryKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeOfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UndefinedKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UniqueKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnknownKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">VarKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">VoidKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">WhileKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">WithKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">YieldKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ModifierSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AbstractKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AccessorKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsyncKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConstKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DeclareKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DefaultKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExportKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PrivateKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ProtectedKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PublicKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OutKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OverrideKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">StaticKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type KeywordTypeSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AnyKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BigIntKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BooleanKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">IntrinsicKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NeverKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NumberKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ObjectKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">StringKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SymbolKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UndefinedKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnknownKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">VoidKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type TokenSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Unknown </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EndOfFileToken </span><span class="s2">| </span><span class="s1">TriviaSyntaxKind </span><span class="s2">| </span><span class="s1">LiteralSyntaxKind </span><span class="s2">| </span><span class="s1">PseudoLiteralSyntaxKind </span><span class="s2">| </span><span class="s1">PunctuationSyntaxKind </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">KeywordSyntaxKind</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type JsxTokenSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanSlashToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EndOfFileToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConflictMarkerTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxText </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxTextAllWhiteSpaces </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OpenBraceToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type JSDocSyntaxKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EndOfFileToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">WhitespaceTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AtToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NewLineTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OpenBraceToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CloseBraceToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OpenBracketToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CloseBracketToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CommaToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DotToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BacktickToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">HashToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Unknown </span><span class="s2">| </span><span class="s1">KeywordSyntaxKind</span><span class="s2">;</span>
    <span class="s3">export enum </span><span class="s1">NodeFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Let </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Const </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">NestedNamespace </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">Synthesized </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Namespace </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">OptionalChain </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">ExportContext </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">ContainsThis </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">HasImplicitReturn </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">HasExplicitReturn </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">GlobalAugmentation </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">HasAsyncFunctions </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">DisallowInContext </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">YieldContext </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">DecoratorContext </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">AwaitContext </span><span class="s2">= </span><span class="s6">32768</span><span class="s2">,</span>
        <span class="s1">DisallowConditionalTypesContext </span><span class="s2">= </span><span class="s6">65536</span><span class="s2">,</span>
        <span class="s1">ThisNodeHasError </span><span class="s2">= </span><span class="s6">131072</span><span class="s2">,</span>
        <span class="s1">JavaScriptFile </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">ThisNodeOrAnySubNodesHasError </span><span class="s2">= </span><span class="s6">524288</span><span class="s2">,</span>
        <span class="s1">HasAggregatedChildData </span><span class="s2">= </span><span class="s6">1048576</span><span class="s2">,</span>
        <span class="s1">JSDoc </span><span class="s2">= </span><span class="s6">8388608</span><span class="s2">,</span>
        <span class="s1">JsonFile </span><span class="s2">= </span><span class="s6">67108864</span><span class="s2">,</span>
        <span class="s1">BlockScoped </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">ReachabilityCheckFlags </span><span class="s2">= </span><span class="s6">768</span><span class="s2">,</span>
        <span class="s1">ReachabilityAndEmitFlags </span><span class="s2">= </span><span class="s6">2816</span><span class="s2">,</span>
        <span class="s1">ContextFlags </span><span class="s2">= </span><span class="s6">50720768</span><span class="s2">,</span>
        <span class="s1">TypeExcludesFlags </span><span class="s2">= </span><span class="s6">40960</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ModifierFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Export </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Ambient </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">Public </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">Private </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Protected </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">Static </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">Readonly </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">Accessor </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">Abstract </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">Async </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">Default </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">Const </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">HasComputedJSDocModifiers </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">Deprecated </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">Override </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">In </span><span class="s2">= </span><span class="s6">32768</span><span class="s2">,</span>
        <span class="s1">Out </span><span class="s2">= </span><span class="s6">65536</span><span class="s2">,</span>
        <span class="s1">Decorator </span><span class="s2">= </span><span class="s6">131072</span><span class="s2">,</span>
        <span class="s1">HasComputedFlags </span><span class="s2">= </span><span class="s6">536870912</span><span class="s2">,</span>
        <span class="s1">AccessibilityModifier </span><span class="s2">= </span><span class="s6">28</span><span class="s2">,</span>
        <span class="s1">ParameterPropertyModifier </span><span class="s2">= </span><span class="s6">16476</span><span class="s2">,</span>
        <span class="s1">NonPublicAccessibilityModifier </span><span class="s2">= </span><span class="s6">24</span><span class="s2">,</span>
        <span class="s1">TypeScriptModifier </span><span class="s2">= </span><span class="s6">117086</span><span class="s2">,</span>
        <span class="s1">ExportDefault </span><span class="s2">= </span><span class="s6">1025</span><span class="s2">,</span>
        <span class="s1">All </span><span class="s2">= </span><span class="s6">258047</span><span class="s2">,</span>
        <span class="s1">Modifier </span><span class="s2">= </span><span class="s6">126975</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">JsxFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s5">/** An element from a named property of the JSX.IntrinsicElements interface */</span>
        <span class="s1">IntrinsicNamedElement </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s5">/** An element inferred from the string index signature of the JSX.IntrinsicElements interface */</span>
        <span class="s1">IntrinsicIndexedElement </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">IntrinsicElement </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Node </span><span class="s3">extends </span><span class="s1">ReadonlyTextRange </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">readonly flags</span><span class="s2">: </span><span class="s1">NodeFlags</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type HasJSDoc </span><span class="s2">= </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">CallSignatureDeclaration </span><span class="s2">| </span><span class="s1">ClassStaticBlockDeclaration </span><span class="s2">| </span><span class="s1">ConstructSignatureDeclaration </span><span class="s2">| </span><span class="s1">MethodSignature </span><span class="s2">| </span><span class="s1">PropertySignature </span><span class="s2">| </span><span class="s1">ArrowFunction </span><span class="s2">| </span><span class="s1">ParenthesizedExpression </span><span class="s2">| </span><span class="s1">SpreadAssignment </span><span class="s2">| </span><span class="s1">ShorthandPropertyAssignment </span><span class="s2">| </span><span class="s1">PropertyAssignment </span><span class="s2">| </span><span class="s1">FunctionExpression </span><span class="s2">| </span><span class="s1">EmptyStatement </span><span class="s2">| </span><span class="s1">DebuggerStatement </span><span class="s2">| </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">VariableStatement </span><span class="s2">| </span><span class="s1">ExpressionStatement </span><span class="s2">| </span><span class="s1">IfStatement </span><span class="s2">| </span><span class="s1">DoStatement </span><span class="s2">| </span><span class="s1">WhileStatement </span><span class="s2">| </span><span class="s1">ForStatement </span><span class="s2">| </span><span class="s1">ForInStatement </span><span class="s2">| </span><span class="s1">ForOfStatement </span><span class="s2">| </span><span class="s1">BreakStatement </span><span class="s2">| </span><span class="s1">ContinueStatement </span><span class="s2">| </span><span class="s1">ReturnStatement </span><span class="s2">| </span><span class="s1">WithStatement </span><span class="s2">| </span><span class="s1">SwitchStatement </span><span class="s2">| </span><span class="s1">LabeledStatement </span><span class="s2">| </span><span class="s1">ThrowStatement </span><span class="s2">| </span><span class="s1">TryStatement </span><span class="s2">| </span><span class="s1">FunctionDeclaration </span><span class="s2">| </span><span class="s1">ConstructorDeclaration </span><span class="s2">| </span><span class="s1">MethodDeclaration </span><span class="s2">| </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">PropertyDeclaration </span><span class="s2">| </span><span class="s1">AccessorDeclaration </span><span class="s2">| </span><span class="s1">ClassLikeDeclaration </span><span class="s2">| </span><span class="s1">InterfaceDeclaration </span><span class="s2">| </span><span class="s1">TypeAliasDeclaration </span><span class="s2">| </span><span class="s1">EnumMember </span><span class="s2">| </span><span class="s1">EnumDeclaration </span><span class="s2">| </span><span class="s1">ModuleDeclaration </span><span class="s2">| </span><span class="s1">ImportEqualsDeclaration </span><span class="s2">| </span><span class="s1">ImportDeclaration </span><span class="s2">| </span><span class="s1">NamespaceExportDeclaration </span><span class="s2">| </span><span class="s1">ExportAssignment </span><span class="s2">| </span><span class="s1">IndexSignatureDeclaration </span><span class="s2">| </span><span class="s1">FunctionTypeNode </span><span class="s2">| </span><span class="s1">ConstructorTypeNode </span><span class="s2">| </span><span class="s1">JSDocFunctionType </span><span class="s2">| </span><span class="s1">ExportDeclaration </span><span class="s2">| </span><span class="s1">NamedTupleMember </span><span class="s2">| </span><span class="s1">ExportSpecifier </span><span class="s2">| </span><span class="s1">CaseClause </span><span class="s2">| </span><span class="s1">EndOfFileToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type HasType </span><span class="s2">= </span><span class="s1">SignatureDeclaration </span><span class="s2">| </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">PropertySignature </span><span class="s2">| </span><span class="s1">PropertyDeclaration </span><span class="s2">| </span><span class="s1">TypePredicateNode </span><span class="s2">| </span><span class="s1">ParenthesizedTypeNode </span><span class="s2">| </span><span class="s1">TypeOperatorNode </span><span class="s2">| </span><span class="s1">MappedTypeNode </span><span class="s2">| </span><span class="s1">AssertionExpression </span><span class="s2">| </span><span class="s1">TypeAliasDeclaration </span><span class="s2">| </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">JSDocNonNullableType </span><span class="s2">| </span><span class="s1">JSDocNullableType </span><span class="s2">| </span><span class="s1">JSDocOptionalType </span><span class="s2">| </span><span class="s1">JSDocVariadicType</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type HasTypeArguments </span><span class="s2">= </span><span class="s1">CallExpression </span><span class="s2">| </span><span class="s1">NewExpression </span><span class="s2">| </span><span class="s1">TaggedTemplateExpression </span><span class="s2">| </span><span class="s1">JsxOpeningElement </span><span class="s2">| </span><span class="s1">JsxSelfClosingElement</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type HasInitializer </span><span class="s2">= </span><span class="s1">HasExpressionInitializer </span><span class="s2">| </span><span class="s1">ForStatement </span><span class="s2">| </span><span class="s1">ForInStatement </span><span class="s2">| </span><span class="s1">ForOfStatement </span><span class="s2">| </span><span class="s1">JsxAttribute</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type HasExpressionInitializer </span><span class="s2">= </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">BindingElement </span><span class="s2">| </span><span class="s1">PropertyDeclaration </span><span class="s2">| </span><span class="s1">PropertyAssignment </span><span class="s2">| </span><span class="s1">EnumMember</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type HasDecorators </span><span class="s2">= </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">PropertyDeclaration </span><span class="s2">| </span><span class="s1">MethodDeclaration </span><span class="s2">| </span><span class="s1">GetAccessorDeclaration </span><span class="s2">| </span><span class="s1">SetAccessorDeclaration </span><span class="s2">| </span><span class="s1">ClassExpression </span><span class="s2">| </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type HasModifiers </span><span class="s2">= </span><span class="s1">TypeParameterDeclaration </span><span class="s2">| </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">ConstructorTypeNode </span><span class="s2">| </span><span class="s1">PropertySignature </span><span class="s2">| </span><span class="s1">PropertyDeclaration </span><span class="s2">| </span><span class="s1">MethodSignature </span><span class="s2">| </span><span class="s1">MethodDeclaration </span><span class="s2">| </span><span class="s1">ConstructorDeclaration </span><span class="s2">| </span><span class="s1">GetAccessorDeclaration </span><span class="s2">| </span><span class="s1">SetAccessorDeclaration </span><span class="s2">| </span><span class="s1">IndexSignatureDeclaration </span><span class="s2">| </span><span class="s1">FunctionExpression </span><span class="s2">| </span><span class="s1">ArrowFunction </span><span class="s2">| </span><span class="s1">ClassExpression </span><span class="s2">| </span><span class="s1">VariableStatement </span><span class="s2">| </span><span class="s1">FunctionDeclaration </span><span class="s2">| </span><span class="s1">ClassDeclaration </span><span class="s2">| </span><span class="s1">InterfaceDeclaration </span><span class="s2">| </span><span class="s1">TypeAliasDeclaration </span><span class="s2">| </span><span class="s1">EnumDeclaration </span><span class="s2">| </span><span class="s1">ModuleDeclaration </span><span class="s2">| </span><span class="s1">ImportEqualsDeclaration </span><span class="s2">| </span><span class="s1">ImportDeclaration </span><span class="s2">| </span><span class="s1">ExportAssignment </span><span class="s2">| </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">ReadonlyTextRange </span><span class="s2">{</span>
        <span class="s1">readonly hasTrailingComma</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">SyntaxKind</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type EndOfFileToken </span><span class="s2">= </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EndOfFileToken</span><span class="s2">&gt; &amp; </span><span class="s1">JSDocContainer</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">PunctuationSyntaxKind</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type DotToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DotToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type DotDotDotToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DotDotDotToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type QuestionToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type ExclamationToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExclamationToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type ColonToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ColonToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type EqualsToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type AsteriskToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type EqualsGreaterThanToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsGreaterThanToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type PlusToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type MinusToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusToken</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type QuestionDotToken </span><span class="s2">= </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionDotToken</span><span class="s2">&gt;;</span>
    <span class="s3">export interface </span><span class="s1">KeywordToken</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">KeywordSyntaxKind</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type AssertsKeyword </span><span class="s2">= </span><span class="s1">KeywordToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AssertsKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type AssertKeyword </span><span class="s2">= </span><span class="s1">KeywordToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AssertKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type AwaitKeyword </span><span class="s2">= </span><span class="s1">KeywordToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AwaitKeyword</span><span class="s2">&gt;;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `AwaitKeyword` instead. */</span>
    <span class="s3">export </span><span class="s1">type AwaitKeywordToken </span><span class="s2">= </span><span class="s1">AwaitKeyword</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `AssertsKeyword` instead. */</span>
    <span class="s3">export </span><span class="s1">type AssertsToken </span><span class="s2">= </span><span class="s1">AssertsKeyword</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">ModifierSyntaxKind</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">KeywordToken</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type AbstractKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AbstractKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type AccessorKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AccessorKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type AsyncKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsyncKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type ConstKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConstKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type DeclareKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DeclareKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type DefaultKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DefaultKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type ExportKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExportKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type InKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type PrivateKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PrivateKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type ProtectedKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ProtectedKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type PublicKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PublicKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type ReadonlyKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ReadonlyKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type OutKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OutKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type OverrideKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OverrideKeyword</span><span class="s2">&gt;;</span>
    <span class="s3">export </span><span class="s1">type StaticKeyword </span><span class="s2">= </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">StaticKeyword</span><span class="s2">&gt;;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `ReadonlyKeyword` instead. */</span>
    <span class="s3">export </span><span class="s1">type ReadonlyToken </span><span class="s2">= </span><span class="s1">ReadonlyKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type Modifier </span><span class="s2">= </span><span class="s1">AbstractKeyword </span><span class="s2">| </span><span class="s1">AccessorKeyword </span><span class="s2">| </span><span class="s1">AsyncKeyword </span><span class="s2">| </span><span class="s1">ConstKeyword </span><span class="s2">| </span><span class="s1">DeclareKeyword </span><span class="s2">| </span><span class="s1">DefaultKeyword </span><span class="s2">| </span><span class="s1">ExportKeyword </span><span class="s2">| </span><span class="s1">InKeyword </span><span class="s2">| </span><span class="s1">PrivateKeyword </span><span class="s2">| </span><span class="s1">ProtectedKeyword </span><span class="s2">| </span><span class="s1">PublicKeyword </span><span class="s2">| </span><span class="s1">OutKeyword </span><span class="s2">| </span><span class="s1">OverrideKeyword </span><span class="s2">| </span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">StaticKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ModifierLike </span><span class="s2">= </span><span class="s1">Modifier </span><span class="s2">| </span><span class="s1">Decorator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type AccessibilityModifier </span><span class="s2">= </span><span class="s1">PublicKeyword </span><span class="s2">| </span><span class="s1">PrivateKeyword </span><span class="s2">| </span><span class="s1">ProtectedKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ParameterPropertyModifier </span><span class="s2">= </span><span class="s1">AccessibilityModifier </span><span class="s2">| </span><span class="s1">ReadonlyKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ClassMemberModifier </span><span class="s2">= </span><span class="s1">AccessibilityModifier </span><span class="s2">| </span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">StaticKeyword </span><span class="s2">| </span><span class="s1">AccessorKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ModifiersArray </span><span class="s2">= </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
    <span class="s3">export enum </span><span class="s1">GeneratedIdentifierFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">ReservedInNestedScopes </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Optimistic </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">FileLevel </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">AllowNameSubstitution </span><span class="s2">= </span><span class="s6">64</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Identifier </span><span class="s3">extends </span><span class="s1">PrimaryExpression</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Prefer to use `id.unescapedText`. (Note: This is available only in services, not internally to the TypeScript compiler.)</span>
         <span class="s5">* Text of identifier, but if the identifier begins with two underscores, this will begin with three.</span>
         <span class="s5">*/</span>
        <span class="s1">readonly escapedText</span><span class="s2">: </span><span class="s1">__String</span><span class="s2">;</span>
        <span class="s1">readonly originalKeywordKind</span><span class="s2">?: </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">isInJSDocNamespace</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TransientIdentifier </span><span class="s3">extends </span><span class="s1">Identifier </span><span class="s2">{</span>
        <span class="s1">resolvedSymbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">QualifiedName </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QualifiedName</span><span class="s2">;</span>
        <span class="s1">readonly left</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">;</span>
        <span class="s1">readonly right</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type EntityName </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">QualifiedName</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type PropertyName </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">NumericLiteral </span><span class="s2">| </span><span class="s1">ComputedPropertyName </span><span class="s2">| </span><span class="s1">PrivateIdentifier</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type MemberName </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PrivateIdentifier</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type DeclarationName </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PrivateIdentifier </span><span class="s2">| </span><span class="s1">StringLiteralLike </span><span class="s2">| </span><span class="s1">NumericLiteral </span><span class="s2">| </span><span class="s1">ComputedPropertyName </span><span class="s2">| </span><span class="s1">ElementAccessExpression </span><span class="s2">| </span><span class="s1">BindingPattern </span><span class="s2">| </span><span class="s1">EntityNameExpression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">Declaration </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">_declarationBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NamedDeclaration </span><span class="s3">extends </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">DeclarationName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DeclarationStatement </span><span class="s3">extends </span><span class="s1">NamedDeclaration</span><span class="s2">, </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">NumericLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ComputedPropertyName </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ComputedPropertyName</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">Declaration</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PrivateIdentifier </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PrivateIdentifier</span><span class="s2">;</span>
        <span class="s1">readonly escapedText</span><span class="s2">: </span><span class="s1">__String</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Decorator </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Decorator</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">NamedDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeParameterDeclaration </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeParameter</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">DeclarationWithTypeParameterChildren </span><span class="s2">| </span><span class="s1">InferTypeNode</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s5">/** Note: Consider calling `getEffectiveConstraintOfTypeParameter` */</span>
        <span class="s1">readonly constraint</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly </span><span class="s3">default</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">expression</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SignatureDeclarationBase </span><span class="s3">extends </span><span class="s1">NamedDeclaration</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SignatureDeclaration</span><span class="s2">[</span><span class="s4">&quot;kind&quot;</span><span class="s2">];</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly typeParameters</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">readonly parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;;</span>
        <span class="s1">readonly type</span><span class="s2">?: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type SignatureDeclaration </span><span class="s2">= </span><span class="s1">CallSignatureDeclaration </span><span class="s2">| </span><span class="s1">ConstructSignatureDeclaration </span><span class="s2">| </span><span class="s1">MethodSignature </span><span class="s2">| </span><span class="s1">IndexSignatureDeclaration </span><span class="s2">| </span><span class="s1">FunctionTypeNode </span><span class="s2">| </span><span class="s1">ConstructorTypeNode </span><span class="s2">| </span><span class="s1">JSDocFunctionType </span><span class="s2">| </span><span class="s1">FunctionDeclaration </span><span class="s2">| </span><span class="s1">MethodDeclaration </span><span class="s2">| </span><span class="s1">ConstructorDeclaration </span><span class="s2">| </span><span class="s1">AccessorDeclaration </span><span class="s2">| </span><span class="s1">FunctionExpression </span><span class="s2">| </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">CallSignatureDeclaration </span><span class="s3">extends </span><span class="s1">SignatureDeclarationBase</span><span class="s2">, </span><span class="s1">TypeElement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CallSignature</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ConstructSignatureDeclaration </span><span class="s3">extends </span><span class="s1">SignatureDeclarationBase</span><span class="s2">, </span><span class="s1">TypeElement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConstructSignature</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type BindingName </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">BindingPattern</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">VariableDeclaration </span><span class="s3">extends </span><span class="s1">NamedDeclaration</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">VariableDeclarationList </span><span class="s2">| </span><span class="s1">CatchClause</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">;</span>
        <span class="s1">readonly exclamationToken</span><span class="s2">?: </span><span class="s1">ExclamationToken</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">VariableDeclarationList </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">VariableDeclarationList</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">VariableStatement </span><span class="s2">| </span><span class="s1">ForStatement </span><span class="s2">| </span><span class="s1">ForOfStatement </span><span class="s2">| </span><span class="s1">ForInStatement</span><span class="s2">;</span>
        <span class="s1">readonly declarations</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">VariableDeclaration</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ParameterDeclaration </span><span class="s3">extends </span><span class="s1">NamedDeclaration</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Parameter</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">SignatureDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ModifierLike</span><span class="s2">&gt;;</span>
        <span class="s1">readonly dotDotDotToken</span><span class="s2">?: </span><span class="s1">DotDotDotToken</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">;</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">BindingElement </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BindingElement</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">BindingPattern</span><span class="s2">;</span>
        <span class="s1">readonly propertyName</span><span class="s2">?: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly dotDotDotToken</span><span class="s2">?: </span><span class="s1">DotDotDotToken</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PropertySignature </span><span class="s3">extends </span><span class="s1">TypeElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PropertySignature</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PropertyDeclaration </span><span class="s3">extends </span><span class="s1">ClassElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ClassLikeDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ModifierLike</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken</span><span class="s2">;</span>
        <span class="s1">readonly exclamationToken</span><span class="s2">?: </span><span class="s1">ExclamationToken</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">AutoAccessorPropertyDeclaration </span><span class="s3">extends </span><span class="s1">PropertyDeclaration </span><span class="s2">{</span>
        <span class="s1">_autoAccessorBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ObjectLiteralElement </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">_objectLiteralBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">PropertyName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** Unlike ObjectLiteralElement, excludes JSXAttribute and JSXSpreadAttribute. */</span>
    <span class="s3">export </span><span class="s1">type ObjectLiteralElementLike </span><span class="s2">= </span><span class="s1">PropertyAssignment </span><span class="s2">| </span><span class="s1">ShorthandPropertyAssignment </span><span class="s2">| </span><span class="s1">SpreadAssignment </span><span class="s2">| </span><span class="s1">MethodDeclaration </span><span class="s2">| </span><span class="s1">AccessorDeclaration</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">PropertyAssignment </span><span class="s3">extends </span><span class="s1">ObjectLiteralElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PropertyAssignment</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ShorthandPropertyAssignment </span><span class="s3">extends </span><span class="s1">ObjectLiteralElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ShorthandPropertyAssignment</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly equalsToken</span><span class="s2">?: </span><span class="s1">EqualsToken</span><span class="s2">;</span>
        <span class="s1">readonly objectAssignmentInitializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SpreadAssignment </span><span class="s3">extends </span><span class="s1">ObjectLiteralElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SpreadAssignment</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type VariableLikeDeclaration </span><span class="s2">= </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">BindingElement </span><span class="s2">| </span><span class="s1">PropertyDeclaration </span><span class="s2">| </span><span class="s1">PropertyAssignment </span><span class="s2">| </span><span class="s1">PropertySignature </span><span class="s2">| </span><span class="s1">JsxAttribute </span><span class="s2">| </span><span class="s1">ShorthandPropertyAssignment </span><span class="s2">| </span><span class="s1">EnumMember </span><span class="s2">| </span><span class="s1">JSDocPropertyTag </span><span class="s2">| </span><span class="s1">JSDocParameterTag</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">PropertyLikeDeclaration </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ObjectBindingPattern </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ObjectBindingPattern</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">BindingElement</span><span class="s2">;</span>
        <span class="s1">readonly elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">BindingElement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ArrayBindingPattern </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ArrayBindingPattern</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">BindingElement</span><span class="s2">;</span>
        <span class="s1">readonly elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ArrayBindingElement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type BindingPattern </span><span class="s2">= </span><span class="s1">ObjectBindingPattern </span><span class="s2">| </span><span class="s1">ArrayBindingPattern</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ArrayBindingElement </span><span class="s2">= </span><span class="s1">BindingElement </span><span class="s2">| </span><span class="s1">OmittedExpression</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Several node kinds share function-like features such as a signature,</span>
     <span class="s5">* a name, and a body. These nodes should extend FunctionLikeDeclarationBase.</span>
     <span class="s5">* Examples:</span>
     <span class="s5">* - FunctionDeclaration</span>
     <span class="s5">* - MethodDeclaration</span>
     <span class="s5">* - AccessorDeclaration</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">FunctionLikeDeclarationBase </span><span class="s3">extends </span><span class="s1">SignatureDeclarationBase </span><span class="s2">{</span>
        <span class="s1">_functionLikeDeclarationBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">readonly asteriskToken</span><span class="s2">?: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">readonly exclamationToken</span><span class="s2">?: </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">?: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type FunctionLikeDeclaration </span><span class="s2">= </span><span class="s1">FunctionDeclaration </span><span class="s2">| </span><span class="s1">MethodDeclaration </span><span class="s2">| </span><span class="s1">GetAccessorDeclaration </span><span class="s2">| </span><span class="s1">SetAccessorDeclaration </span><span class="s2">| </span><span class="s1">ConstructorDeclaration </span><span class="s2">| </span><span class="s1">FunctionExpression </span><span class="s2">| </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use SignatureDeclaration */</span>
    <span class="s3">export </span><span class="s1">type FunctionLike </span><span class="s2">= </span><span class="s1">SignatureDeclaration</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">FunctionDeclaration </span><span class="s3">extends </span><span class="s1">FunctionLikeDeclarationBase</span><span class="s2">, </span><span class="s1">DeclarationStatement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">?: </span><span class="s1">FunctionBody</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">MethodSignature </span><span class="s3">extends </span><span class="s1">SignatureDeclarationBase</span><span class="s2">, </span><span class="s1">TypeElement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MethodSignature</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ObjectTypeDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">MethodDeclaration </span><span class="s3">extends </span><span class="s1">FunctionLikeDeclarationBase</span><span class="s2">, </span><span class="s1">ClassElement</span><span class="s2">, </span><span class="s1">ObjectLiteralElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ClassLikeDeclaration </span><span class="s2">| </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ModifierLike</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">?: </span><span class="s1">FunctionBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ConstructorDeclaration </span><span class="s3">extends </span><span class="s1">FunctionLikeDeclarationBase</span><span class="s2">, </span><span class="s1">ClassElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Constructor</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ClassLikeDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">?: </span><span class="s1">FunctionBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** For when we encounter a semicolon in a class declaration. ES6 allows these as class elements. */</span>
    <span class="s3">export interface </span><span class="s1">SemicolonClassElement </span><span class="s3">extends </span><span class="s1">ClassElement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SemicolonClassElement</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ClassLikeDeclaration</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">GetAccessorDeclaration </span><span class="s3">extends </span><span class="s1">FunctionLikeDeclarationBase</span><span class="s2">, </span><span class="s1">ClassElement</span><span class="s2">, </span><span class="s1">TypeElement</span><span class="s2">, </span><span class="s1">ObjectLiteralElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GetAccessor</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ClassLikeDeclaration </span><span class="s2">| </span><span class="s1">ObjectLiteralExpression </span><span class="s2">| </span><span class="s1">TypeLiteralNode </span><span class="s2">| </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ModifierLike</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">?: </span><span class="s1">FunctionBody</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SetAccessorDeclaration </span><span class="s3">extends </span><span class="s1">FunctionLikeDeclarationBase</span><span class="s2">, </span><span class="s1">ClassElement</span><span class="s2">, </span><span class="s1">TypeElement</span><span class="s2">, </span><span class="s1">ObjectLiteralElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SetAccessor</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ClassLikeDeclaration </span><span class="s2">| </span><span class="s1">ObjectLiteralExpression </span><span class="s2">| </span><span class="s1">TypeLiteralNode </span><span class="s2">| </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ModifierLike</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">?: </span><span class="s1">FunctionBody</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type AccessorDeclaration </span><span class="s2">= </span><span class="s1">GetAccessorDeclaration </span><span class="s2">| </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">IndexSignatureDeclaration </span><span class="s3">extends </span><span class="s1">SignatureDeclarationBase</span><span class="s2">, </span><span class="s1">ClassElement</span><span class="s2">, </span><span class="s1">TypeElement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">IndexSignature</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ObjectTypeDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ClassStaticBlockDeclaration </span><span class="s3">extends </span><span class="s1">ClassElement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ClassStaticBlockDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ClassDeclaration </span><span class="s2">| </span><span class="s1">ClassExpression</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeNode </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">_typeNodeBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">KeywordTypeNode</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">KeywordTypeSyntaxKind </span><span class="s2">= </span><span class="s1">KeywordTypeSyntaxKind</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">KeywordToken</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;, </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ImportTypeAssertionContainer </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportTypeAssertionContainer</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
        <span class="s1">readonly assertClause</span><span class="s2">: </span><span class="s1">AssertClause</span><span class="s2">;</span>
        <span class="s1">readonly multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ImportTypeNode </span><span class="s3">extends </span><span class="s1">NodeWithTypeArguments </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportType</span><span class="s2">;</span>
        <span class="s1">readonly isTypeOf</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly assertions</span><span class="s2">?: </span><span class="s1">ImportTypeAssertionContainer</span><span class="s2">;</span>
        <span class="s1">readonly qualifier</span><span class="s2">?: </span><span class="s1">EntityName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ThisTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ThisType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type FunctionOrConstructorTypeNode </span><span class="s2">= </span><span class="s1">FunctionTypeNode </span><span class="s2">| </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">FunctionOrConstructorTypeNodeBase </span><span class="s3">extends </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">SignatureDeclarationBase </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FunctionType </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConstructorType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FunctionTypeNode </span><span class="s3">extends </span><span class="s1">FunctionOrConstructorTypeNodeBase </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FunctionType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ConstructorTypeNode </span><span class="s3">extends </span><span class="s1">FunctionOrConstructorTypeNodeBase </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConstructorType</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NodeWithTypeArguments </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly typeArguments</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type TypeReferenceType </span><span class="s2">= </span><span class="s1">TypeReferenceNode </span><span class="s2">| </span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">TypeReferenceNode </span><span class="s3">extends </span><span class="s1">NodeWithTypeArguments </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeReference</span><span class="s2">;</span>
        <span class="s1">readonly typeName</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypePredicateNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypePredicate</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">SignatureDeclaration </span><span class="s2">| </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
        <span class="s1">readonly assertsModifier</span><span class="s2">?: </span><span class="s1">AssertsKeyword</span><span class="s2">;</span>
        <span class="s1">readonly parameterName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">ThisTypeNode</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeQueryNode </span><span class="s3">extends </span><span class="s1">NodeWithTypeArguments </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeQuery</span><span class="s2">;</span>
        <span class="s1">readonly exprName</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeLiteralNode </span><span class="s3">extends </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeLiteral</span><span class="s2">;</span>
        <span class="s1">readonly members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ArrayTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ArrayType</span><span class="s2">;</span>
        <span class="s1">readonly elementType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TupleTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TupleType</span><span class="s2">;</span>
        <span class="s1">readonly elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">NamedTupleMember</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NamedTupleMember </span><span class="s3">extends </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">JSDocContainer</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NamedTupleMember</span><span class="s2">;</span>
        <span class="s1">readonly dotDotDotToken</span><span class="s2">?: </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DotDotDotToken</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionToken</span><span class="s2">&gt;;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">OptionalTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OptionalType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">RestTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">RestType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type UnionOrIntersectionTypeNode </span><span class="s2">= </span><span class="s1">UnionTypeNode </span><span class="s2">| </span><span class="s1">IntersectionTypeNode</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">UnionTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnionType</span><span class="s2">;</span>
        <span class="s1">readonly types</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">IntersectionTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">IntersectionType</span><span class="s2">;</span>
        <span class="s1">readonly types</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ConditionalTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConditionalType</span><span class="s2">;</span>
        <span class="s1">readonly checkType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly extendsType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly trueType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly falseType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">InferTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InferType</span><span class="s2">;</span>
        <span class="s1">readonly typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ParenthesizedTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ParenthesizedType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeOperatorNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeOperator</span><span class="s2">;</span>
        <span class="s1">readonly operator</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">KeyOfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UniqueKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ReadonlyKeyword</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">IndexedAccessTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">IndexedAccessType</span><span class="s2">;</span>
        <span class="s1">readonly objectType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly indexType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">MappedTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MappedType</span><span class="s2">;</span>
        <span class="s1">readonly readonlyToken</span><span class="s2">?: </span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken</span><span class="s2">;</span>
        <span class="s1">readonly typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly nameType</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s5">/** Used only to produce grammar errors */</span>
        <span class="s1">readonly members</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">LiteralTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LiteralType</span><span class="s2">;</span>
        <span class="s1">readonly literal</span><span class="s2">: </span><span class="s1">NullLiteral </span><span class="s2">| </span><span class="s1">BooleanLiteral </span><span class="s2">| </span><span class="s1">LiteralExpression </span><span class="s2">| </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">StringLiteral </span><span class="s3">extends </span><span class="s1">LiteralExpression</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">StringLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type StringLiteralLike </span><span class="s2">= </span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type PropertyNameLiteral </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">StringLiteralLike </span><span class="s2">| </span><span class="s1">NumericLiteral</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">TemplateLiteralTypeNode </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateLiteralType</span><span class="s2">;</span>
        <span class="s1">readonly head</span><span class="s2">: </span><span class="s1">TemplateHead</span><span class="s2">;</span>
        <span class="s1">readonly templateSpans</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TemplateLiteralTypeSpan</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TemplateLiteralTypeSpan </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateLiteralTypeSpan</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">TemplateLiteralTypeNode</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly literal</span><span class="s2">: </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Expression </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">_expressionBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">OmittedExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">OmittedExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PartiallyEmittedExpression </span><span class="s3">extends </span><span class="s1">LeftHandSideExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PartiallyEmittedExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnaryExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">_unaryExpressionBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** Deprecated, please use UpdateExpression */</span>
    <span class="s3">export </span><span class="s1">type IncrementExpression </span><span class="s2">= </span><span class="s1">UpdateExpression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">UpdateExpression </span><span class="s3">extends </span><span class="s1">UnaryExpression </span><span class="s2">{</span>
        <span class="s1">_updateExpressionBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type PrefixUnaryOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusPlusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusMinusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TildeToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExclamationToken</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">PrefixUnaryExpression </span><span class="s3">extends </span><span class="s1">UpdateExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">readonly operator</span><span class="s2">: </span><span class="s1">PrefixUnaryOperator</span><span class="s2">;</span>
        <span class="s1">readonly operand</span><span class="s2">: </span><span class="s1">UnaryExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type PostfixUnaryOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusPlusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusMinusToken</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">PostfixUnaryExpression </span><span class="s3">extends </span><span class="s1">UpdateExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">readonly operand</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
        <span class="s1">readonly operator</span><span class="s2">: </span><span class="s1">PostfixUnaryOperator</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">LeftHandSideExpression </span><span class="s3">extends </span><span class="s1">UpdateExpression </span><span class="s2">{</span>
        <span class="s1">_leftHandSideExpressionBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">MemberExpression </span><span class="s3">extends </span><span class="s1">LeftHandSideExpression </span><span class="s2">{</span>
        <span class="s1">_memberExpressionBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PrimaryExpression </span><span class="s3">extends </span><span class="s1">MemberExpression </span><span class="s2">{</span>
        <span class="s1">_primaryExpressionBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NullLiteral </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NullKeyword</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TrueLiteral </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TrueKeyword</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FalseLiteral </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FalseKeyword</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type BooleanLiteral </span><span class="s2">= </span><span class="s1">TrueLiteral </span><span class="s2">| </span><span class="s1">FalseLiteral</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ThisExpression </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ThisKeyword</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SuperExpression </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SuperKeyword</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ImportExpression </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportKeyword</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DeleteExpression </span><span class="s3">extends </span><span class="s1">UnaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DeleteExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">UnaryExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeOfExpression </span><span class="s3">extends </span><span class="s1">UnaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeOfExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">UnaryExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">VoidExpression </span><span class="s3">extends </span><span class="s1">UnaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">VoidExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">UnaryExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">AwaitExpression </span><span class="s3">extends </span><span class="s1">UnaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AwaitExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">UnaryExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">YieldExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">YieldExpression</span><span class="s2">;</span>
        <span class="s1">readonly asteriskToken</span><span class="s2">?: </span><span class="s1">AsteriskToken</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SyntheticExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SyntheticExpression</span><span class="s2">;</span>
        <span class="s1">readonly isSpread</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">readonly tupleNameSource</span><span class="s2">?: </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">NamedTupleMember</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type ExponentiationOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskAsteriskToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type MultiplicativeOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SlashToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PercentToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type MultiplicativeOperatorOrHigher </span><span class="s2">= </span><span class="s1">ExponentiationOperator </span><span class="s2">| </span><span class="s1">MultiplicativeOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type AdditiveOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type AdditiveOperatorOrHigher </span><span class="s2">= </span><span class="s1">MultiplicativeOperatorOrHigher </span><span class="s2">| </span><span class="s1">AdditiveOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ShiftOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanLessThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanGreaterThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanGreaterThanGreaterThanToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ShiftOperatorOrHigher </span><span class="s2">= </span><span class="s1">AdditiveOperatorOrHigher </span><span class="s2">| </span><span class="s1">ShiftOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type RelationalOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InstanceOfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InKeyword</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type RelationalOperatorOrHigher </span><span class="s2">= </span><span class="s1">ShiftOperatorOrHigher </span><span class="s2">| </span><span class="s1">RelationalOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type EqualityOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsEqualsEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExclamationEqualsEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExclamationEqualsToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type EqualityOperatorOrHigher </span><span class="s2">= </span><span class="s1">RelationalOperatorOrHigher </span><span class="s2">| </span><span class="s1">EqualityOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type BitwiseOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AmpersandToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BarToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CaretToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type BitwiseOperatorOrHigher </span><span class="s2">= </span><span class="s1">EqualityOperatorOrHigher </span><span class="s2">| </span><span class="s1">BitwiseOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type LogicalOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AmpersandAmpersandToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BarBarToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type LogicalOperatorOrHigher </span><span class="s2">= </span><span class="s1">BitwiseOperatorOrHigher </span><span class="s2">| </span><span class="s1">LogicalOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type CompoundAssignmentOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PlusEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskAsteriskEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsteriskEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SlashEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PercentEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AmpersandEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BarEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CaretEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LessThanLessThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanGreaterThanGreaterThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">GreaterThanGreaterThanEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BarBarEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AmpersandAmpersandEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionQuestionEqualsToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type AssignmentOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EqualsToken </span><span class="s2">| </span><span class="s1">CompoundAssignmentOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type AssignmentOperatorOrHigher </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionQuestionToken </span><span class="s2">| </span><span class="s1">LogicalOperatorOrHigher </span><span class="s2">| </span><span class="s1">AssignmentOperator</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type BinaryOperator </span><span class="s2">= </span><span class="s1">AssignmentOperatorOrHigher </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CommaToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type LogicalOrCoalescingAssignmentOperator </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AmpersandAmpersandEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BarBarEqualsToken </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">QuestionQuestionEqualsToken</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type BinaryOperatorToken </span><span class="s2">= </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">BinaryOperator</span><span class="s2">&gt;;</span>
    <span class="s3">export interface </span><span class="s1">BinaryExpression </span><span class="s3">extends </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">readonly left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly operatorToken</span><span class="s2">: </span><span class="s1">BinaryOperatorToken</span><span class="s2">;</span>
        <span class="s1">readonly right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type AssignmentOperatorToken </span><span class="s2">= </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">AssignmentOperator</span><span class="s2">&gt;;</span>
    <span class="s3">export interface </span><span class="s1">AssignmentExpression</span><span class="s2">&lt;</span><span class="s1">TOperator </span><span class="s3">extends </span><span class="s1">AssignmentOperatorToken</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">BinaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly left</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
        <span class="s1">readonly operatorToken</span><span class="s2">: </span><span class="s1">TOperator</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ObjectDestructuringAssignment </span><span class="s3">extends </span><span class="s1">AssignmentExpression</span><span class="s2">&lt;</span><span class="s1">EqualsToken</span><span class="s2">&gt; {</span>
        <span class="s1">readonly left</span><span class="s2">: </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ArrayDestructuringAssignment </span><span class="s3">extends </span><span class="s1">AssignmentExpression</span><span class="s2">&lt;</span><span class="s1">EqualsToken</span><span class="s2">&gt; {</span>
        <span class="s1">readonly left</span><span class="s2">: </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type DestructuringAssignment </span><span class="s2">= </span><span class="s1">ObjectDestructuringAssignment </span><span class="s2">| </span><span class="s1">ArrayDestructuringAssignment</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type BindingOrAssignmentElement </span><span class="s2">= </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">ObjectBindingOrAssignmentElement </span><span class="s2">| </span><span class="s1">ArrayBindingOrAssignmentElement</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ObjectBindingOrAssignmentElement </span><span class="s2">= </span><span class="s1">BindingElement </span><span class="s2">| </span><span class="s1">PropertyAssignment </span><span class="s2">| </span><span class="s1">ShorthandPropertyAssignment </span><span class="s2">| </span><span class="s1">SpreadAssignment</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ArrayBindingOrAssignmentElement </span><span class="s2">= </span><span class="s1">BindingElement </span><span class="s2">| </span><span class="s1">OmittedExpression </span><span class="s2">| </span><span class="s1">SpreadElement </span><span class="s2">| </span><span class="s1">ArrayLiteralExpression </span><span class="s2">| </span><span class="s1">ObjectLiteralExpression </span><span class="s2">| </span><span class="s1">AssignmentExpression</span><span class="s2">&lt;</span><span class="s1">EqualsToken</span><span class="s2">&gt; | </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PropertyAccessExpression </span><span class="s2">| </span><span class="s1">ElementAccessExpression</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type BindingOrAssignmentElementRestIndicator </span><span class="s2">= </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">SpreadElement </span><span class="s2">| </span><span class="s1">SpreadAssignment</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type BindingOrAssignmentElementTarget </span><span class="s2">= </span><span class="s1">BindingOrAssignmentPattern </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PropertyAccessExpression </span><span class="s2">| </span><span class="s1">ElementAccessExpression </span><span class="s2">| </span><span class="s1">OmittedExpression</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ObjectBindingOrAssignmentPattern </span><span class="s2">= </span><span class="s1">ObjectBindingPattern </span><span class="s2">| </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ArrayBindingOrAssignmentPattern </span><span class="s2">= </span><span class="s1">ArrayBindingPattern </span><span class="s2">| </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type AssignmentPattern </span><span class="s2">= </span><span class="s1">ObjectLiteralExpression </span><span class="s2">| </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type BindingOrAssignmentPattern </span><span class="s2">= </span><span class="s1">ObjectBindingOrAssignmentPattern </span><span class="s2">| </span><span class="s1">ArrayBindingOrAssignmentPattern</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ConditionalExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ConditionalExpression</span><span class="s2">;</span>
        <span class="s1">readonly condition</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly questionToken</span><span class="s2">: </span><span class="s1">QuestionToken</span><span class="s2">;</span>
        <span class="s1">readonly whenTrue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly colonToken</span><span class="s2">: </span><span class="s1">ColonToken</span><span class="s2">;</span>
        <span class="s1">readonly whenFalse</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type FunctionBody </span><span class="s2">= </span><span class="s1">Block</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ConciseBody </span><span class="s2">= </span><span class="s1">FunctionBody </span><span class="s2">| </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">FunctionExpression </span><span class="s3">extends </span><span class="s1">PrimaryExpression</span><span class="s2">, </span><span class="s1">FunctionLikeDeclarationBase</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FunctionExpression</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">: </span><span class="s1">FunctionBody</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ArrowFunction </span><span class="s3">extends </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">FunctionLikeDeclarationBase</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ArrowFunction</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly equalsGreaterThanToken</span><span class="s2">: </span><span class="s1">EqualsGreaterThanToken</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">: </span><span class="s1">ConciseBody</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">LiteralLikeNode </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">isUnterminated</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">hasExtendedUnicodeEscape</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TemplateLiteralLikeNode </span><span class="s3">extends </span><span class="s1">LiteralLikeNode </span><span class="s2">{</span>
        <span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">LiteralExpression </span><span class="s3">extends </span><span class="s1">LiteralLikeNode</span><span class="s2">, </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">_literalExpressionBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">RegularExpressionLiteral </span><span class="s3">extends </span><span class="s1">LiteralExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">RegularExpressionLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NoSubstitutionTemplateLiteral </span><span class="s3">extends </span><span class="s1">LiteralExpression</span><span class="s2">, </span><span class="s1">TemplateLiteralLikeNode</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">TokenFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Scientific </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">Octal </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">HexSpecifier </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">BinarySpecifier </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">OctalSpecifier </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NumericLiteral </span><span class="s3">extends </span><span class="s1">LiteralExpression</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NumericLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">BigIntLiteral </span><span class="s3">extends </span><span class="s1">LiteralExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BigIntLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type LiteralToken </span><span class="s2">= </span><span class="s1">NumericLiteral </span><span class="s2">| </span><span class="s1">BigIntLiteral </span><span class="s2">| </span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">JsxText </span><span class="s2">| </span><span class="s1">RegularExpressionLiteral </span><span class="s2">| </span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">TemplateHead </span><span class="s3">extends </span><span class="s1">TemplateLiteralLikeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateHead</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">TemplateExpression </span><span class="s2">| </span><span class="s1">TemplateLiteralTypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TemplateMiddle </span><span class="s3">extends </span><span class="s1">TemplateLiteralLikeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateMiddle</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">TemplateSpan </span><span class="s2">| </span><span class="s1">TemplateLiteralTypeSpan</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TemplateTail </span><span class="s3">extends </span><span class="s1">TemplateLiteralLikeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateTail</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">TemplateSpan </span><span class="s2">| </span><span class="s1">TemplateLiteralTypeSpan</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type PseudoLiteralToken </span><span class="s2">= </span><span class="s1">TemplateHead </span><span class="s2">| </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type TemplateLiteralToken </span><span class="s2">= </span><span class="s1">NoSubstitutionTemplateLiteral </span><span class="s2">| </span><span class="s1">PseudoLiteralToken</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">TemplateExpression </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateExpression</span><span class="s2">;</span>
        <span class="s1">readonly head</span><span class="s2">: </span><span class="s1">TemplateHead</span><span class="s2">;</span>
        <span class="s1">readonly templateSpans</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TemplateSpan</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type TemplateLiteral </span><span class="s2">= </span><span class="s1">TemplateExpression </span><span class="s2">| </span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">TemplateSpan </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TemplateSpan</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">TemplateExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly literal</span><span class="s2">: </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ParenthesizedExpression </span><span class="s3">extends </span><span class="s1">PrimaryExpression</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ParenthesizedExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ArrayLiteralExpression </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
        <span class="s1">readonly elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Expression</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SpreadElement </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SpreadElement</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ArrayLiteralExpression </span><span class="s2">| </span><span class="s1">CallExpression </span><span class="s2">| </span><span class="s1">NewExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* This interface is a base interface for ObjectLiteralExpression and JSXAttributes to extend from. JSXAttributes is similar to</span>
     <span class="s5">* ObjectLiteralExpression in that it contains array of properties; however, JSXAttributes' properties can only be</span>
     <span class="s5">* JSXAttribute or JSXSpreadAttribute. ObjectLiteralExpression, on the other hand, can only have properties of type</span>
     <span class="s5">* ObjectLiteralElement (e.g. PropertyAssignment, ShorthandPropertyAssignment etc.)</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">ObjectLiteralExpressionBase</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">ObjectLiteralElement</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">PrimaryExpression</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly properties</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ObjectLiteralExpression </span><span class="s3">extends </span><span class="s1">ObjectLiteralExpressionBase</span><span class="s2">&lt;</span><span class="s1">ObjectLiteralElementLike</span><span class="s2">&gt; {</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type EntityNameExpression </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PropertyAccessEntityNameExpression</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type EntityNameOrEntityNameExpression </span><span class="s2">= </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">EntityNameExpression</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type AccessExpression </span><span class="s2">= </span><span class="s1">PropertyAccessExpression </span><span class="s2">| </span><span class="s1">ElementAccessExpression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">PropertyAccessExpression </span><span class="s3">extends </span><span class="s1">MemberExpression</span><span class="s2">, </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PropertyAccessExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
        <span class="s1">readonly questionDotToken</span><span class="s2">?: </span><span class="s1">QuestionDotToken</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">MemberName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PropertyAccessChain </span><span class="s3">extends </span><span class="s1">PropertyAccessExpression </span><span class="s2">{</span>
        <span class="s1">_optionalChainBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">MemberName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SuperPropertyAccessExpression </span><span class="s3">extends </span><span class="s1">PropertyAccessExpression </span><span class="s2">{</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">SuperExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** Brand for a PropertyAccessExpression which, like a QualifiedName, consists of a sequence of identifiers separated by dots. */</span>
    <span class="s3">export interface </span><span class="s1">PropertyAccessEntityNameExpression </span><span class="s3">extends </span><span class="s1">PropertyAccessExpression </span><span class="s2">{</span>
        <span class="s1">_propertyAccessExpressionLikeQualifiedNameBrand</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">EntityNameExpression</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ElementAccessExpression </span><span class="s3">extends </span><span class="s1">MemberExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ElementAccessExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
        <span class="s1">readonly questionDotToken</span><span class="s2">?: </span><span class="s1">QuestionDotToken</span><span class="s2">;</span>
        <span class="s1">readonly argumentExpression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ElementAccessChain </span><span class="s3">extends </span><span class="s1">ElementAccessExpression </span><span class="s2">{</span>
        <span class="s1">_optionalChainBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SuperElementAccessExpression </span><span class="s3">extends </span><span class="s1">ElementAccessExpression </span><span class="s2">{</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">SuperExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type SuperProperty </span><span class="s2">= </span><span class="s1">SuperPropertyAccessExpression </span><span class="s2">| </span><span class="s1">SuperElementAccessExpression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">CallExpression </span><span class="s3">extends </span><span class="s1">LeftHandSideExpression</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
        <span class="s1">readonly questionDotToken</span><span class="s2">?: </span><span class="s1">QuestionDotToken</span><span class="s2">;</span>
        <span class="s1">readonly typeArguments</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
        <span class="s1">readonly arguments</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Expression</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CallChain </span><span class="s3">extends </span><span class="s1">CallExpression </span><span class="s2">{</span>
        <span class="s1">_optionalChainBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type OptionalChain </span><span class="s2">= </span><span class="s1">PropertyAccessChain </span><span class="s2">| </span><span class="s1">ElementAccessChain </span><span class="s2">| </span><span class="s1">CallChain </span><span class="s2">| </span><span class="s1">NonNullChain</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">SuperCall </span><span class="s3">extends </span><span class="s1">CallExpression </span><span class="s2">{</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">SuperExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ImportCall </span><span class="s3">extends </span><span class="s1">CallExpression </span><span class="s2">{</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">ImportExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ExpressionWithTypeArguments </span><span class="s3">extends </span><span class="s1">MemberExpression</span><span class="s2">, </span><span class="s1">NodeWithTypeArguments </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NewExpression </span><span class="s3">extends </span><span class="s1">PrimaryExpression</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NewExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
        <span class="s1">readonly typeArguments</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
        <span class="s1">readonly arguments</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Expression</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TaggedTemplateExpression </span><span class="s3">extends </span><span class="s1">MemberExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TaggedTemplateExpression</span><span class="s2">;</span>
        <span class="s1">readonly tag</span><span class="s2">: </span><span class="s1">LeftHandSideExpression</span><span class="s2">;</span>
        <span class="s1">readonly typeArguments</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
        <span class="s1">readonly template</span><span class="s2">: </span><span class="s1">TemplateLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type CallLikeExpression </span><span class="s2">= </span><span class="s1">CallExpression </span><span class="s2">| </span><span class="s1">NewExpression </span><span class="s2">| </span><span class="s1">TaggedTemplateExpression </span><span class="s2">| </span><span class="s1">Decorator </span><span class="s2">| </span><span class="s1">JsxOpeningLikeElement</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">AsExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AsExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeAssertion </span><span class="s3">extends </span><span class="s1">UnaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeAssertionExpression</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">UnaryExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SatisfiesExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SatisfiesExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type AssertionExpression </span><span class="s2">= </span><span class="s1">TypeAssertion </span><span class="s2">| </span><span class="s1">AsExpression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">NonNullExpression </span><span class="s3">extends </span><span class="s1">LeftHandSideExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NonNullExpression</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NonNullChain </span><span class="s3">extends </span><span class="s1">NonNullExpression </span><span class="s2">{</span>
        <span class="s1">_optionalChainBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">MetaProperty </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MetaProperty</span><span class="s2">;</span>
        <span class="s1">readonly keywordToken</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NewKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportKeyword</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxElement </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxElement</span><span class="s2">;</span>
        <span class="s1">readonly openingElement</span><span class="s2">: </span><span class="s1">JsxOpeningElement</span><span class="s2">;</span>
        <span class="s1">readonly children</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JsxChild</span><span class="s2">&gt;;</span>
        <span class="s1">readonly closingElement</span><span class="s2">: </span><span class="s1">JsxClosingElement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type JsxOpeningLikeElement </span><span class="s2">= </span><span class="s1">JsxSelfClosingElement </span><span class="s2">| </span><span class="s1">JsxOpeningElement</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type JsxAttributeLike </span><span class="s2">= </span><span class="s1">JsxAttribute </span><span class="s2">| </span><span class="s1">JsxSpreadAttribute</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type JsxTagNameExpression </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">ThisExpression </span><span class="s2">| </span><span class="s1">JsxTagNamePropertyAccess</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">JsxTagNamePropertyAccess </span><span class="s3">extends </span><span class="s1">PropertyAccessExpression </span><span class="s2">{</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxAttributes </span><span class="s3">extends </span><span class="s1">ObjectLiteralExpressionBase</span><span class="s2">&lt;</span><span class="s1">JsxAttributeLike</span><span class="s2">&gt; {</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxAttributes</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxOpeningLikeElement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxOpeningElement </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxOpeningElement</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxElement</span><span class="s2">;</span>
        <span class="s1">readonly tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">;</span>
        <span class="s1">readonly typeArguments</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
        <span class="s1">readonly attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxSelfClosingElement </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxSelfClosingElement</span><span class="s2">;</span>
        <span class="s1">readonly tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">;</span>
        <span class="s1">readonly typeArguments</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
        <span class="s1">readonly attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxFragment </span><span class="s3">extends </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxFragment</span><span class="s2">;</span>
        <span class="s1">readonly openingFragment</span><span class="s2">: </span><span class="s1">JsxOpeningFragment</span><span class="s2">;</span>
        <span class="s1">readonly children</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JsxChild</span><span class="s2">&gt;;</span>
        <span class="s1">readonly closingFragment</span><span class="s2">: </span><span class="s1">JsxClosingFragment</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxOpeningFragment </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxOpeningFragment</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxFragment</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxClosingFragment </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxClosingFragment</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxFragment</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxAttribute </span><span class="s3">extends </span><span class="s1">ObjectLiteralElement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxAttribute</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">?: </span><span class="s1">JsxAttributeValue</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type JsxAttributeValue </span><span class="s2">= </span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">JsxExpression </span><span class="s2">| </span><span class="s1">JsxElement </span><span class="s2">| </span><span class="s1">JsxSelfClosingElement </span><span class="s2">| </span><span class="s1">JsxFragment</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">JsxSpreadAttribute </span><span class="s3">extends </span><span class="s1">ObjectLiteralElement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxSpreadAttribute</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxClosingElement </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxClosingElement</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxElement</span><span class="s2">;</span>
        <span class="s1">readonly tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxExpression</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxElement </span><span class="s2">| </span><span class="s1">JsxFragment </span><span class="s2">| </span><span class="s1">JsxAttributeLike</span><span class="s2">;</span>
        <span class="s1">readonly dotDotDotToken</span><span class="s2">?: </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DotDotDotToken</span><span class="s2">&gt;;</span>
        <span class="s1">readonly expression</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsxText </span><span class="s3">extends </span><span class="s1">LiteralLikeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JsxText</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JsxElement </span><span class="s2">| </span><span class="s1">JsxFragment</span><span class="s2">;</span>
        <span class="s1">readonly containsOnlyTriviaWhiteSpaces</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type JsxChild </span><span class="s2">= </span><span class="s1">JsxText </span><span class="s2">| </span><span class="s1">JsxExpression </span><span class="s2">| </span><span class="s1">JsxElement </span><span class="s2">| </span><span class="s1">JsxSelfClosingElement </span><span class="s2">| </span><span class="s1">JsxFragment</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">Statement </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">_statementBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NotEmittedStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NotEmittedStatement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* A list of comma-separated expressions. This node is only created by transformations.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">CommaListExpression </span><span class="s3">extends </span><span class="s1">Expression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CommaListExpression</span><span class="s2">;</span>
        <span class="s1">readonly elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Expression</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">EmptyStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EmptyStatement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DebuggerStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DebuggerStatement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">MissingDeclaration </span><span class="s3">extends </span><span class="s1">DeclarationStatement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MissingDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type BlockLike </span><span class="s2">= </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">ModuleBlock </span><span class="s2">| </span><span class="s1">CaseOrDefaultClause</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">Block </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Block</span><span class="s2">;</span>
        <span class="s1">readonly statements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Statement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">VariableStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">VariableStatement</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly declarationList</span><span class="s2">: </span><span class="s1">VariableDeclarationList</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ExpressionStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExpressionStatement</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">IfStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">IfStatement</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly thenStatement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">;</span>
        <span class="s1">readonly elseStatement</span><span class="s2">?: </span><span class="s1">Statement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">IterationStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DoStatement </span><span class="s3">extends </span><span class="s1">IterationStatement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DoStatement</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">WhileStatement </span><span class="s3">extends </span><span class="s1">IterationStatement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">WhileStatement</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type ForInitializer </span><span class="s2">= </span><span class="s1">VariableDeclarationList </span><span class="s2">| </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ForStatement </span><span class="s3">extends </span><span class="s1">IterationStatement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ForStatement</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">?: </span><span class="s1">ForInitializer</span><span class="s2">;</span>
        <span class="s1">readonly condition</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly incrementor</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type ForInOrOfStatement </span><span class="s2">= </span><span class="s1">ForInStatement </span><span class="s2">| </span><span class="s1">ForOfStatement</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ForInStatement </span><span class="s3">extends </span><span class="s1">IterationStatement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ForInStatement</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ForOfStatement </span><span class="s3">extends </span><span class="s1">IterationStatement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ForOfStatement</span><span class="s2">;</span>
        <span class="s1">readonly awaitModifier</span><span class="s2">?: </span><span class="s1">AwaitKeyword</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">BreakStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">BreakStatement</span><span class="s2">;</span>
        <span class="s1">readonly label</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ContinueStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ContinueStatement</span><span class="s2">;</span>
        <span class="s1">readonly label</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type BreakOrContinueStatement </span><span class="s2">= </span><span class="s1">BreakStatement </span><span class="s2">| </span><span class="s1">ContinueStatement</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ReturnStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ReturnStatement</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">WithStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">WithStatement</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SwitchStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SwitchStatement</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly caseBlock</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">;</span>
        <span class="s1">possiblyExhaustive</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CaseBlock </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CaseBlock</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">SwitchStatement</span><span class="s2">;</span>
        <span class="s1">readonly clauses</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">CaseOrDefaultClause</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CaseClause </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CaseClause</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly statements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Statement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DefaultClause </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">DefaultClause</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">;</span>
        <span class="s1">readonly statements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Statement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type CaseOrDefaultClause </span><span class="s2">= </span><span class="s1">CaseClause </span><span class="s2">| </span><span class="s1">DefaultClause</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">LabeledStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">LabeledStatement</span><span class="s2">;</span>
        <span class="s1">readonly label</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ThrowStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ThrowStatement</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TryStatement </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TryStatement</span><span class="s2">;</span>
        <span class="s1">readonly tryBlock</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">;</span>
        <span class="s1">readonly catchClause</span><span class="s2">?: </span><span class="s1">CatchClause</span><span class="s2">;</span>
        <span class="s1">readonly finallyBlock</span><span class="s2">?: </span><span class="s1">Block</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CatchClause </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">CatchClause</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">TryStatement</span><span class="s2">;</span>
        <span class="s1">readonly variableDeclaration</span><span class="s2">?: </span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly block</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type ObjectTypeDeclaration </span><span class="s2">= </span><span class="s1">ClassLikeDeclaration </span><span class="s2">| </span><span class="s1">InterfaceDeclaration </span><span class="s2">| </span><span class="s1">TypeLiteralNode</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type DeclarationWithTypeParameters </span><span class="s2">= </span><span class="s1">DeclarationWithTypeParameterChildren </span><span class="s2">| </span><span class="s1">JSDocTypedefTag </span><span class="s2">| </span><span class="s1">JSDocCallbackTag </span><span class="s2">| </span><span class="s1">JSDocSignature</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type DeclarationWithTypeParameterChildren </span><span class="s2">= </span><span class="s1">SignatureDeclaration </span><span class="s2">| </span><span class="s1">ClassLikeDeclaration </span><span class="s2">| </span><span class="s1">InterfaceDeclaration </span><span class="s2">| </span><span class="s1">TypeAliasDeclaration </span><span class="s2">| </span><span class="s1">JSDocTemplateTag</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ClassLikeDeclarationBase </span><span class="s3">extends </span><span class="s1">NamedDeclaration</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ClassDeclaration </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ClassExpression</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly typeParameters</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt;;</span>
        <span class="s1">readonly heritageClauses</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">HeritageClause</span><span class="s2">&gt;;</span>
        <span class="s1">readonly members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ClassElement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ClassDeclaration </span><span class="s3">extends </span><span class="s1">ClassLikeDeclarationBase</span><span class="s2">, </span><span class="s1">DeclarationStatement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ModifierLike</span><span class="s2">&gt;;</span>
        <span class="s5">/** May be undefined in `export default class { ... }`. */</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ClassExpression </span><span class="s3">extends </span><span class="s1">ClassLikeDeclarationBase</span><span class="s2">, </span><span class="s1">PrimaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ClassExpression</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ModifierLike</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type ClassLikeDeclaration </span><span class="s2">= </span><span class="s1">ClassDeclaration </span><span class="s2">| </span><span class="s1">ClassExpression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ClassElement </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">_classElementBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">PropertyName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeElement </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">_typeElementBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">InterfaceDeclaration </span><span class="s3">extends </span><span class="s1">DeclarationStatement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly typeParameters</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt;;</span>
        <span class="s1">readonly heritageClauses</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">HeritageClause</span><span class="s2">&gt;;</span>
        <span class="s1">readonly members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">HeritageClause </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">HeritageClause</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">InterfaceDeclaration </span><span class="s2">| </span><span class="s1">ClassLikeDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExtendsKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImplementsKeyword</span><span class="s2">;</span>
        <span class="s1">readonly types</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeAliasDeclaration </span><span class="s3">extends </span><span class="s1">DeclarationStatement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly typeParameters</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt;;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">EnumMember </span><span class="s3">extends </span><span class="s1">NamedDeclaration</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EnumMember</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">;</span>
        <span class="s1">readonly initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">EnumDeclaration </span><span class="s3">extends </span><span class="s1">DeclarationStatement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">EnumMember</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type ModuleName </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">StringLiteral</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type ModuleBody </span><span class="s2">= </span><span class="s1">NamespaceBody </span><span class="s2">| </span><span class="s1">JSDocNamespaceBody</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ModuleDeclaration </span><span class="s3">extends </span><span class="s1">DeclarationStatement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">?: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">JSDocNamespaceDeclaration</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type NamespaceBody </span><span class="s2">= </span><span class="s1">ModuleBlock </span><span class="s2">| </span><span class="s1">NamespaceDeclaration</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">NamespaceDeclaration </span><span class="s3">extends </span><span class="s1">ModuleDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">: </span><span class="s1">NamespaceBody</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type JSDocNamespaceBody </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">JSDocNamespaceDeclaration</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">JSDocNamespaceDeclaration </span><span class="s3">extends </span><span class="s1">ModuleDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly body</span><span class="s2">?: </span><span class="s1">JSDocNamespaceBody</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ModuleBlock </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ModuleBlock</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly statements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Statement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type ModuleReference </span><span class="s2">= </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">ExternalModuleReference</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* One of:</span>
     <span class="s5">* - import x = require(&quot;mod&quot;);</span>
     <span class="s5">* - import x = M.x;</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">ImportEqualsDeclaration </span><span class="s3">extends </span><span class="s1">DeclarationStatement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">ModuleBlock</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ExternalModuleReference </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExternalModuleReference</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ImportDeclaration </span><span class="s3">extends </span><span class="s1">Statement </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">ModuleBlock</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly importClause</span><span class="s2">?: </span><span class="s1">ImportClause</span><span class="s2">;</span>
        <span class="s5">/** If this is not a StringLiteral it will be a grammar error. */</span>
        <span class="s1">readonly moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly assertClause</span><span class="s2">?: </span><span class="s1">AssertClause</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type NamedImportBindings </span><span class="s2">= </span><span class="s1">NamespaceImport </span><span class="s2">| </span><span class="s1">NamedImports</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type NamedExportBindings </span><span class="s2">= </span><span class="s1">NamespaceExport </span><span class="s2">| </span><span class="s1">NamedExports</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ImportClause </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportClause</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly namedBindings</span><span class="s2">?: </span><span class="s1">NamedImportBindings</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type AssertionKey </span><span class="s2">= </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">StringLiteral</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">AssertEntry </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AssertEntry</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">AssertClause</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">AssertionKey</span><span class="s2">;</span>
        <span class="s1">readonly value</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">AssertClause </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">AssertClause</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ImportDeclaration </span><span class="s2">| </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">AssertEntry</span><span class="s2">&gt;;</span>
        <span class="s1">readonly multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NamespaceImport </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NamespaceImport</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ImportClause</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NamespaceExport </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NamespaceExport</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NamespaceExportDeclaration </span><span class="s3">extends </span><span class="s1">DeclarationStatement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NamespaceExportDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ExportDeclaration </span><span class="s3">extends </span><span class="s1">DeclarationStatement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">ModuleBlock</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/** Will not be assigned in the case of `export * from &quot;foo&quot;;` */</span>
        <span class="s1">readonly exportClause</span><span class="s2">?: </span><span class="s1">NamedExportBindings</span><span class="s2">;</span>
        <span class="s5">/** If this is not a StringLiteral it will be a grammar error. */</span>
        <span class="s1">readonly moduleSpecifier</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">readonly assertClause</span><span class="s2">?: </span><span class="s1">AssertClause</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NamedImports </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NamedImports</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ImportClause</span><span class="s2">;</span>
        <span class="s1">readonly elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ImportSpecifier</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NamedExports </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NamedExports</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
        <span class="s1">readonly elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ExportSpecifier</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type NamedImportsOrExports </span><span class="s2">= </span><span class="s1">NamedImports </span><span class="s2">| </span><span class="s1">NamedExports</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ImportSpecifier </span><span class="s3">extends </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportSpecifier</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">NamedImports</span><span class="s2">;</span>
        <span class="s1">readonly propertyName</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ExportSpecifier </span><span class="s3">extends </span><span class="s1">NamedDeclaration</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExportSpecifier</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">NamedExports</span><span class="s2">;</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly propertyName</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type ImportOrExportSpecifier </span><span class="s2">= </span><span class="s1">ImportSpecifier </span><span class="s2">| </span><span class="s1">ExportSpecifier</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type TypeOnlyCompatibleAliasDeclaration </span><span class="s2">= </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">ImportEqualsDeclaration </span><span class="s2">| </span><span class="s1">NamespaceImport </span><span class="s2">| </span><span class="s1">ImportOrExportSpecifier</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type TypeOnlyAliasDeclaration </span><span class="s2">= </span><span class="s1">ImportClause </span><span class="s2">&amp; {</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">} | </span><span class="s1">ImportEqualsDeclaration </span><span class="s2">&amp; {</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s2">} | </span><span class="s1">NamespaceImport </span><span class="s2">&amp; {</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">&amp; {</span>
            <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s2">};</span>
    <span class="s2">} | </span><span class="s1">ImportSpecifier </span><span class="s2">&amp; ({</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s2">} | {</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">NamedImports </span><span class="s2">&amp; {</span>
            <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">&amp; {</span>
                <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
            <span class="s2">};</span>
        <span class="s2">};</span>
    <span class="s2">}) | </span><span class="s1">ExportSpecifier </span><span class="s2">&amp; ({</span>
        <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s2">} | {</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">NamedExports </span><span class="s2">&amp; {</span>
            <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">ExportDeclaration </span><span class="s2">&amp; {</span>
                <span class="s1">readonly isTypeOnly</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
            <span class="s2">};</span>
        <span class="s2">};</span>
    <span class="s2">});</span>
    <span class="s5">/**</span>
     <span class="s5">* This is either an `export =` or an `export default` declaration.</span>
     <span class="s5">* Unless `isExportEquals` is set, this node was parsed as an `export default`.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">ExportAssignment </span><span class="s3">extends </span><span class="s1">DeclarationStatement</span><span class="s2">, </span><span class="s1">JSDocContainer </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExportAssignment</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt;;</span>
        <span class="s1">readonly isExportEquals</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FileReference </span><span class="s3">extends </span><span class="s1">TextRange </span><span class="s2">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">resolutionMode</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CheckJsDirective </span><span class="s3">extends </span><span class="s1">TextRange </span><span class="s2">{</span>
        <span class="s1">enabled</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type CommentKind </span><span class="s2">= </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SingleLineCommentTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MultiLineCommentTrivia</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">CommentRange </span><span class="s3">extends </span><span class="s1">TextRange </span><span class="s2">{</span>
        <span class="s1">hasTrailingNewLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">CommentKind</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SynthesizedComment </span><span class="s3">extends </span><span class="s1">CommentRange </span><span class="s2">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">pos</span><span class="s2">: -</span><span class="s6">1</span><span class="s2">;</span>
        <span class="s1">end</span><span class="s2">: -</span><span class="s6">1</span><span class="s2">;</span>
        <span class="s1">hasLeadingNewline</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocTypeExpression </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocNameReference </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocNameReference</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** Class#method reference in JSDoc */</span>
    <span class="s3">export interface </span><span class="s1">JSDocMemberName </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
        <span class="s1">readonly left</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
        <span class="s1">readonly right</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocType </span><span class="s3">extends </span><span class="s1">TypeNode </span><span class="s2">{</span>
        <span class="s1">_jsDocTypeBrand</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocAllType </span><span class="s3">extends </span><span class="s1">JSDocType </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocAllType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocUnknownType </span><span class="s3">extends </span><span class="s1">JSDocType </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocUnknownType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocNonNullableType </span><span class="s3">extends </span><span class="s1">JSDocType </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocNonNullableType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly postfix</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocNullableType </span><span class="s3">extends </span><span class="s1">JSDocType </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocNullableType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
        <span class="s1">readonly postfix</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocOptionalType </span><span class="s3">extends </span><span class="s1">JSDocType </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocOptionalType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocFunctionType </span><span class="s3">extends </span><span class="s1">JSDocType</span><span class="s2">, </span><span class="s1">SignatureDeclarationBase </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocFunctionType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocVariadicType </span><span class="s3">extends </span><span class="s1">JSDocType </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocVariadicType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocNamepathType </span><span class="s3">extends </span><span class="s1">JSDocType </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocNamepathType</span><span class="s2">;</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type JSDocTypeReferencingNode </span><span class="s2">= </span><span class="s1">JSDocVariadicType </span><span class="s2">| </span><span class="s1">JSDocOptionalType </span><span class="s2">| </span><span class="s1">JSDocNullableType </span><span class="s2">| </span><span class="s1">JSDocNonNullableType</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">JSDoc </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDoc</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">HasJSDoc</span><span class="s2">;</span>
        <span class="s1">readonly tags</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocTag</span><span class="s2">&gt;;</span>
        <span class="s1">readonly comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocTag </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JSDoc </span><span class="s2">| </span><span class="s1">JSDocTypeLiteral</span><span class="s2">;</span>
        <span class="s1">readonly tagName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocLink </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocLink</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocLinkCode </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocLinkCode</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocLinkPlain </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocLinkPlain</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type JSDocComment </span><span class="s2">= </span><span class="s1">JSDocText </span><span class="s2">| </span><span class="s1">JSDocLink </span><span class="s2">| </span><span class="s1">JSDocLinkCode </span><span class="s2">| </span><span class="s1">JSDocLinkPlain</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">JSDocText </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocText</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocUnknownTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Note that `@extends` is a synonym of `@augments`.</span>
     <span class="s5">* Both tags are represented by this interface.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">JSDocAugmentsTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocAugmentsTag</span><span class="s2">;</span>
        <span class="s1">readonly </span><span class="s3">class</span><span class="s2">: </span><span class="s1">ExpressionWithTypeArguments </span><span class="s2">&amp; {</span>
            <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PropertyAccessEntityNameExpression</span><span class="s2">;</span>
        <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocImplementsTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocImplementsTag</span><span class="s2">;</span>
        <span class="s1">readonly </span><span class="s3">class</span><span class="s2">: </span><span class="s1">ExpressionWithTypeArguments </span><span class="s2">&amp; {</span>
            <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PropertyAccessEntityNameExpression</span><span class="s2">;</span>
        <span class="s2">};</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocAuthorTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocAuthorTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocDeprecatedTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocDeprecatedTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocClassTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocClassTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocPublicTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocPublicTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocPrivateTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocPrivateTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocProtectedTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocProtectedTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocReadonlyTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocReadonlyTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocOverrideTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocOverrideTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocEnumTag </span><span class="s3">extends </span><span class="s1">JSDocTag</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocEnumTag</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JSDoc</span><span class="s2">;</span>
        <span class="s1">readonly typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocThisTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocThisTag</span><span class="s2">;</span>
        <span class="s1">readonly typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocTemplateTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocTemplateTag</span><span class="s2">;</span>
        <span class="s1">readonly constraint</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">readonly typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocSeeTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocSeeTag</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">JSDocNameReference</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocReturnTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocReturnTag</span><span class="s2">;</span>
        <span class="s1">readonly typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocTypeTag </span><span class="s3">extends </span><span class="s1">JSDocTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocTypeTag</span><span class="s2">;</span>
        <span class="s1">readonly typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocTypedefTag </span><span class="s3">extends </span><span class="s1">JSDocTag</span><span class="s2">, </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocTypedefTag</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JSDoc</span><span class="s2">;</span>
        <span class="s1">readonly fullName</span><span class="s2">?: </span><span class="s1">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">JSDocTypeLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocCallbackTag </span><span class="s3">extends </span><span class="s1">JSDocTag</span><span class="s2">, </span><span class="s1">NamedDeclaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocCallbackTag</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JSDoc</span><span class="s2">;</span>
        <span class="s1">readonly fullName</span><span class="s2">?: </span><span class="s1">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">?: </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">readonly typeExpression</span><span class="s2">: </span><span class="s1">JSDocSignature</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocSignature </span><span class="s3">extends </span><span class="s1">JSDocType</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocSignature</span><span class="s2">;</span>
        <span class="s1">readonly typeParameters</span><span class="s2">?: </span><span class="s1">readonly JSDocTemplateTag</span><span class="s2">[];</span>
        <span class="s1">readonly parameters</span><span class="s2">: </span><span class="s1">readonly JSDocParameterTag</span><span class="s2">[];</span>
        <span class="s1">readonly type</span><span class="s2">: </span><span class="s1">JSDocReturnTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocPropertyLikeTag </span><span class="s3">extends </span><span class="s1">JSDocTag</span><span class="s2">, </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">JSDoc</span><span class="s2">;</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">;</span>
        <span class="s1">readonly typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
        <span class="s5">/** Whether the property name came before the type -- non-standard for JSDoc, but Typescript-like */</span>
        <span class="s1">readonly isNameFirst</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly isBracketed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocPropertyTag </span><span class="s3">extends </span><span class="s1">JSDocPropertyLikeTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocPropertyTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocParameterTag </span><span class="s3">extends </span><span class="s1">JSDocPropertyLikeTag </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocParameterTag</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JSDocTypeLiteral </span><span class="s3">extends </span><span class="s1">JSDocType </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">JSDocTypeLiteral</span><span class="s2">;</span>
        <span class="s1">readonly jsDocPropertyTags</span><span class="s2">?: </span><span class="s1">readonly JSDocPropertyLikeTag</span><span class="s2">[];</span>
        <span class="s5">/** If true, then this type literal represents an *array* of its type. */</span>
        <span class="s1">readonly isArrayType</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">FlowFlags </span><span class="s2">{</span>
        <span class="s1">Unreachable </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Start </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">BranchLabel </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">LoopLabel </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Assignment </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">TrueCondition </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">FalseCondition </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">SwitchClause </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">ArrayMutation </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">Call </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">ReduceLabel </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">Referenced </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">Shared </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">Label </span><span class="s2">= </span><span class="s6">12</span><span class="s2">,</span>
        <span class="s1">Condition </span><span class="s2">= </span><span class="s6">96</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type FlowNode </span><span class="s2">= </span><span class="s1">FlowStart </span><span class="s2">| </span><span class="s1">FlowLabel </span><span class="s2">| </span><span class="s1">FlowAssignment </span><span class="s2">| </span><span class="s1">FlowCondition </span><span class="s2">| </span><span class="s1">FlowSwitchClause </span><span class="s2">| </span><span class="s1">FlowArrayMutation </span><span class="s2">| </span><span class="s1">FlowCall </span><span class="s2">| </span><span class="s1">FlowReduceLabel</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s1">FlowFlags</span><span class="s2">;</span>
        <span class="s1">id</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FlowStart </span><span class="s3">extends </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">node</span><span class="s2">?: </span><span class="s1">FunctionExpression </span><span class="s2">| </span><span class="s1">ArrowFunction </span><span class="s2">| </span><span class="s1">MethodDeclaration </span><span class="s2">| </span><span class="s1">GetAccessorDeclaration </span><span class="s2">| </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FlowLabel </span><span class="s3">extends </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">antecedents</span><span class="s2">: </span><span class="s1">FlowNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FlowAssignment </span><span class="s3">extends </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">BindingElement</span><span class="s2">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s1">FlowNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FlowCall </span><span class="s3">extends </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s1">FlowNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FlowCondition </span><span class="s3">extends </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s1">FlowNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FlowSwitchClause </span><span class="s3">extends </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">switchStatement</span><span class="s2">: </span><span class="s1">SwitchStatement</span><span class="s2">;</span>
        <span class="s1">clauseStart</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">clauseEnd</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s1">FlowNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FlowArrayMutation </span><span class="s3">extends </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s1">CallExpression </span><span class="s2">| </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s1">FlowNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FlowReduceLabel </span><span class="s3">extends </span><span class="s1">FlowNodeBase </span><span class="s2">{</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s1">FlowLabel</span><span class="s2">;</span>
        <span class="s1">antecedents</span><span class="s2">: </span><span class="s1">FlowNode</span><span class="s2">[];</span>
        <span class="s1">antecedent</span><span class="s2">: </span><span class="s1">FlowNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type FlowType </span><span class="s2">= </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">IncompleteType</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">IncompleteType </span><span class="s2">{</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s1">TypeFlags</span><span class="s2">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">AmdDependency </span><span class="s2">{</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">name</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Subset of properties from SourceFile that are used in multiple utility functions</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">SourceFileLike </span><span class="s2">{</span>
        <span class="s1">readonly text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SourceFile </span><span class="s3">extends </span><span class="s1">Declaration </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">readonly statements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Statement</span><span class="s2">&gt;;</span>
        <span class="s1">readonly endOfFileToken</span><span class="s2">: </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EndOfFileToken</span><span class="s2">&gt;;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">amdDependencies</span><span class="s2">: </span><span class="s1">readonly AmdDependency</span><span class="s2">[];</span>
        <span class="s1">moduleName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">referencedFiles</span><span class="s2">: </span><span class="s1">readonly FileReference</span><span class="s2">[];</span>
        <span class="s1">typeReferenceDirectives</span><span class="s2">: </span><span class="s1">readonly FileReference</span><span class="s2">[];</span>
        <span class="s1">libReferenceDirectives</span><span class="s2">: </span><span class="s1">readonly FileReference</span><span class="s2">[];</span>
        <span class="s1">languageVariant</span><span class="s2">: </span><span class="s1">LanguageVariant</span><span class="s2">;</span>
        <span class="s1">isDeclarationFile</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* lib.d.ts should have a reference comment like</span>
         <span class="s5">*</span>
         <span class="s5">*  /// &lt;reference no-default-lib=&quot;true&quot;/&gt;</span>
         <span class="s5">*</span>
         <span class="s5">* If any other file has this comment, it signals not to include lib.d.ts</span>
         <span class="s5">* because this containing file is intended to act as a default library.</span>
         <span class="s5">*/</span>
        <span class="s1">hasNoDefaultLib</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">languageVersion</span><span class="s2">: </span><span class="s1">ScriptTarget</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* When `module` is `Node16` or `NodeNext`, this field controls whether the</span>
         <span class="s5">* source file in question is an ESNext-output-format file, or a CommonJS-output-format</span>
         <span class="s5">* module. This is derived by the module resolver as it looks up the file, since</span>
         <span class="s5">* it is derived from either the file extension of the module, or the containing</span>
         <span class="s5">* `package.json` context, and affects both checking and emit.</span>
         <span class="s5">*</span>
         <span class="s5">* It is _public_ so that (pre)transformers can set this field,</span>
         <span class="s5">* since it switches the builtin `node` module transform. Generally speaking, if unset,</span>
         <span class="s5">* the field is treated as though it is `ModuleKind.CommonJS`.</span>
         <span class="s5">*</span>
         <span class="s5">* Note that this field is only set by the module resolution process when</span>
         <span class="s5">* `moduleResolution` is `Node16` or `NodeNext`, which is implied by the `module` setting</span>
         <span class="s5">* of `Node16` or `NodeNext`, respectively, but may be overriden (eg, by a `moduleResolution`</span>
         <span class="s5">* of `node`). If so, this field will be unset and source files will be considered to be</span>
         <span class="s5">* CommonJS-output-format by the node module transformer and type checker, regardless of extension or context.</span>
         <span class="s5">*/</span>
        <span class="s1">impliedNodeFormat</span><span class="s2">?: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Bundle </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Bundle</span><span class="s2">;</span>
        <span class="s1">readonly prepends</span><span class="s2">: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">InputFiles </span><span class="s2">| </span><span class="s1">UnparsedSource</span><span class="s2">)[];</span>
        <span class="s1">readonly sourceFiles</span><span class="s2">: </span><span class="s1">readonly SourceFile</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">InputFiles </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">InputFiles</span><span class="s2">;</span>
        <span class="s1">javascriptPath</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">javascriptText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">javascriptMapPath</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">javascriptMapText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">declarationPath</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">declarationText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">declarationMapPath</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">declarationMapText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnparsedSource </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnparsedSource</span><span class="s2">;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly prologues</span><span class="s2">: </span><span class="s1">readonly UnparsedPrologue</span><span class="s2">[];</span>
        <span class="s1">helpers</span><span class="s2">: </span><span class="s1">readonly UnscopedEmitHelper</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">referencedFiles</span><span class="s2">: </span><span class="s1">readonly FileReference</span><span class="s2">[];</span>
        <span class="s1">typeReferenceDirectives</span><span class="s2">: </span><span class="s1">readonly FileReference</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">libReferenceDirectives</span><span class="s2">: </span><span class="s1">readonly FileReference</span><span class="s2">[];</span>
        <span class="s1">hasNoDefaultLib</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">sourceMapPath</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">sourceMapText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly syntheticReferences</span><span class="s2">?: </span><span class="s1">readonly UnparsedSyntheticReference</span><span class="s2">[];</span>
        <span class="s1">readonly texts</span><span class="s2">: </span><span class="s1">readonly UnparsedSourceText</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type UnparsedSourceText </span><span class="s2">= </span><span class="s1">UnparsedPrepend </span><span class="s2">| </span><span class="s1">UnparsedTextLike</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type UnparsedNode </span><span class="s2">= </span><span class="s1">UnparsedPrologue </span><span class="s2">| </span><span class="s1">UnparsedSourceText </span><span class="s2">| </span><span class="s1">UnparsedSyntheticReference</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">UnparsedSection </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
        <span class="s1">readonly data</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnparsedPrologue </span><span class="s3">extends </span><span class="s1">UnparsedSection </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnparsedPrologue</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
        <span class="s1">readonly data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnparsedPrepend </span><span class="s3">extends </span><span class="s1">UnparsedSection </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnparsedPrepend</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
        <span class="s1">readonly data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly texts</span><span class="s2">: </span><span class="s1">readonly UnparsedTextLike</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnparsedTextLike </span><span class="s3">extends </span><span class="s1">UnparsedSection </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnparsedText </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnparsedInternalText</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnparsedSyntheticReference </span><span class="s3">extends </span><span class="s1">UnparsedSection </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UnparsedSyntheticReference</span><span class="s2">;</span>
        <span class="s1">readonly parent</span><span class="s2">: </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsonSourceFile </span><span class="s3">extends </span><span class="s1">SourceFile </span><span class="s2">{</span>
        <span class="s1">readonly statements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JsonObjectExpressionStatement</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TsConfigSourceFile </span><span class="s3">extends </span><span class="s1">JsonSourceFile </span><span class="s2">{</span>
        <span class="s1">extendedSourceFiles</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">JsonMinusNumericLiteral </span><span class="s3">extends </span><span class="s1">PrefixUnaryExpression </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">readonly operator</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MinusToken</span><span class="s2">;</span>
        <span class="s1">readonly operand</span><span class="s2">: </span><span class="s1">NumericLiteral</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type JsonObjectExpression </span><span class="s2">= </span><span class="s1">ObjectLiteralExpression </span><span class="s2">| </span><span class="s1">ArrayLiteralExpression </span><span class="s2">| </span><span class="s1">JsonMinusNumericLiteral </span><span class="s2">| </span><span class="s1">NumericLiteral </span><span class="s2">| </span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">BooleanLiteral </span><span class="s2">| </span><span class="s1">NullLiteral</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">JsonObjectExpressionStatement </span><span class="s3">extends </span><span class="s1">ExpressionStatement </span><span class="s2">{</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">JsonObjectExpression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ScriptReferenceHost </span><span class="s2">{</span>
        <span class="s1">getCompilerOptions</span><span class="s2">(): </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">getSourceFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSourceFileByPath</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">): </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ParseConfigHost </span><span class="s2">{</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readDirectory</span><span class="s2">(</span><span class="s1">rootDir</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">extensions</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">excludes</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">includes</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">depth</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">readonly string</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets a value indicating whether the specified path exists and is a file.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">path The path to test.</span>
         <span class="s5">*/</span>
        <span class="s1">fileExists</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readFile</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">trace</span><span class="s2">?(</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Branded string for keeping track of when we've turned an ambiguous path</span>
     <span class="s5">* specified like &quot;./blah&quot; to an absolute path to an actual</span>
     <span class="s5">* tsconfig file, e.g. &quot;/root/blah/tsconfig.json&quot;</span>
     <span class="s5">*/</span>
    <span class="s3">export </span><span class="s1">type ResolvedConfigFileName </span><span class="s2">= </span><span class="s1">string </span><span class="s2">&amp; {</span>
        <span class="s1">_isResolvedConfigFileName</span><span class="s2">: </span><span class="s1">never</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s3">export interface </span><span class="s1">WriteFileCallbackData </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type WriteFileCallback </span><span class="s2">= (</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">writeByteOrderMark</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">onError</span><span class="s2">?: (</span><span class="s1">message</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">, </span><span class="s1">sourceFiles</span><span class="s2">?: </span><span class="s1">readonly SourceFile</span><span class="s2">[], </span><span class="s1">data</span><span class="s2">?: </span><span class="s1">WriteFileCallbackData</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s3">export class </span><span class="s1">OperationCanceledException </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CancellationToken </span><span class="s2">{</span>
        <span class="s1">isCancellationRequested</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@throws </span><span class="s5">OperationCanceledException if isCancellationRequested is true */</span>
        <span class="s1">throwIfCancellationRequested</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Program </span><span class="s3">extends </span><span class="s1">ScriptReferenceHost </span><span class="s2">{</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Get a list of root file names that were passed to a 'createProgram'</span>
         <span class="s5">*/</span>
        <span class="s1">getRootFileNames</span><span class="s2">(): </span><span class="s1">readonly string</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Get a list of files in the program</span>
         <span class="s5">*/</span>
        <span class="s1">getSourceFiles</span><span class="s2">(): </span><span class="s1">readonly SourceFile</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Emits the JavaScript and declaration files.  If targetSourceFile is not specified, then</span>
         <span class="s5">* the JavaScript and declaration files will be produced for all the files in this program.</span>
         <span class="s5">* If targetSourceFile is specified, then only the JavaScript and declaration for that</span>
         <span class="s5">* specific file will be generated.</span>
         <span class="s5">*</span>
         <span class="s5">* If writeFile is not specified then the writeFile callback from the compiler host will be</span>
         <span class="s5">* used for writing the JavaScript and declaration files.  Otherwise, the writeFile parameter</span>
         <span class="s5">* will be invoked when writing the JavaScript and declaration files.</span>
         <span class="s5">*/</span>
        <span class="s1">emit</span><span class="s2">(</span><span class="s1">targetSourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">customTransformers</span><span class="s2">?: </span><span class="s1">CustomTransformers</span><span class="s2">): </span><span class="s1">EmitResult</span><span class="s2">;</span>
        <span class="s1">getOptionsDiagnostics</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">getGlobalDiagnostics</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">getSyntacticDiagnostics</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly DiagnosticWithLocation</span><span class="s2">[];</span>
        <span class="s5">/** The first time this is called, it will return global diagnostics (no location). */</span>
        <span class="s1">getSemanticDiagnostics</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">getDeclarationDiagnostics</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly DiagnosticWithLocation</span><span class="s2">[];</span>
        <span class="s1">getConfigFileParsingDiagnostics</span><span class="s2">(): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets a type checker that can be used to semantically analyze source files in the program.</span>
         <span class="s5">*/</span>
        <span class="s1">getTypeChecker</span><span class="s2">(): </span><span class="s1">TypeChecker</span><span class="s2">;</span>
        <span class="s1">getNodeCount</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getIdentifierCount</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getSymbolCount</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getTypeCount</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getInstantiationCount</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getRelationCacheSizes</span><span class="s2">(): {</span>
            <span class="s1">assignable</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
            <span class="s1">identity</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
            <span class="s1">subtype</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
            <span class="s1">strictSubtype</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s2">};</span>
        <span class="s1">isSourceFileFromExternalLibrary</span><span class="s2">(</span><span class="s1">file</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isSourceFileDefaultLibrary</span><span class="s2">(</span><span class="s1">file</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getProjectReferences</span><span class="s2">(): </span><span class="s1">readonly ProjectReference</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getResolvedProjectReferences</span><span class="s2">(): </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">ResolvedProjectReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ResolvedProjectReference </span><span class="s2">{</span>
        <span class="s1">commandLine</span><span class="s2">: </span><span class="s1">ParsedCommandLine</span><span class="s2">;</span>
        <span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">references</span><span class="s2">?: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">ResolvedProjectReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[];</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type CustomTransformerFactory </span><span class="s2">= (</span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">) =&gt; </span><span class="s1">CustomTransformer</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">CustomTransformer </span><span class="s2">{</span>
        <span class="s1">transformSourceFile</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">transformBundle</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Bundle</span><span class="s2">): </span><span class="s1">Bundle</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CustomTransformers </span><span class="s2">{</span>
        <span class="s5">/** Custom transformers to evaluate before built-in .js transformations. */</span>
        <span class="s1">before</span><span class="s2">?: (</span><span class="s1">TransformerFactory</span><span class="s2">&lt;</span><span class="s1">SourceFile</span><span class="s2">&gt; | </span><span class="s1">CustomTransformerFactory</span><span class="s2">)[];</span>
        <span class="s5">/** Custom transformers to evaluate after built-in .js transformations. */</span>
        <span class="s1">after</span><span class="s2">?: (</span><span class="s1">TransformerFactory</span><span class="s2">&lt;</span><span class="s1">SourceFile</span><span class="s2">&gt; | </span><span class="s1">CustomTransformerFactory</span><span class="s2">)[];</span>
        <span class="s5">/** Custom transformers to evaluate after built-in .d.ts transformations. */</span>
        <span class="s1">afterDeclarations</span><span class="s2">?: (</span><span class="s1">TransformerFactory</span><span class="s2">&lt;</span><span class="s1">Bundle </span><span class="s2">| </span><span class="s1">SourceFile</span><span class="s2">&gt; | </span><span class="s1">CustomTransformerFactory</span><span class="s2">)[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SourceMapSpan </span><span class="s2">{</span>
        <span class="s5">/** Line number in the .js file. */</span>
        <span class="s1">emittedLine</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s5">/** Column number in the .js file. */</span>
        <span class="s1">emittedColumn</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s5">/** Line number in the .ts file. */</span>
        <span class="s1">sourceLine</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s5">/** Column number in the .ts file. */</span>
        <span class="s1">sourceColumn</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s5">/** Optional name (index into names array) associated with this span. */</span>
        <span class="s1">nameIndex</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s5">/** .ts file (index into sources array) associated with this span */</span>
        <span class="s1">sourceIndex</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** Return code used by getEmitOutput function to indicate status of the function */</span>
    <span class="s3">export enum </span><span class="s1">ExitStatus </span><span class="s2">{</span>
        <span class="s1">Success </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">DiagnosticsPresent_OutputsSkipped </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">DiagnosticsPresent_OutputsGenerated </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">InvalidProject_OutputsSkipped </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">ProjectReferenceCycle_OutputsSkipped </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use ProjectReferenceCycle_OutputsSkipped instead. */</span>
        <span class="s1">ProjectReferenceCycle_OutputsSkupped </span><span class="s2">= </span><span class="s6">4</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">EmitResult </span><span class="s2">{</span>
        <span class="s1">emitSkipped</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/** Contains declaration emit diagnostics */</span>
        <span class="s1">diagnostics</span><span class="s2">: </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">emittedFiles</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeChecker </span><span class="s2">{</span>
        <span class="s1">getTypeOfSymbolAtLocation</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getDeclaredTypeOfSymbol</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getPropertiesOfType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">getPropertyOfType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getPrivateIdentifierPropertyOfType</span><span class="s2">(</span><span class="s1">leftType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">location</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getIndexInfoOfType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">IndexKind</span><span class="s2">): </span><span class="s1">IndexInfo </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getIndexInfosOfType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">readonly IndexInfo</span><span class="s2">[];</span>
        <span class="s1">getIndexInfosOfIndexSymbol</span><span class="s2">: (</span><span class="s1">indexSymbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">) =&gt; </span><span class="s1">IndexInfo</span><span class="s2">[];</span>
        <span class="s1">getSignaturesOfType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SignatureKind</span><span class="s2">): </span><span class="s1">readonly Signature</span><span class="s2">[];</span>
        <span class="s1">getIndexTypeOfType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">IndexKind</span><span class="s2">): </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getBaseTypes</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">InterfaceType</span><span class="s2">): </span><span class="s1">BaseType</span><span class="s2">[];</span>
        <span class="s1">getBaseTypeOfLiteralType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getWidenedType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getReturnTypeOfSignature</span><span class="s2">(</span><span class="s1">signature</span><span class="s2">: </span><span class="s1">Signature</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getNullableType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">TypeFlags</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getNonNullableType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getTypeArguments</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeReference</span><span class="s2">): </span><span class="s1">readonly Type</span><span class="s2">[];</span>
        <span class="s5">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">typeToTypeNode</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeBuilderFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">signatureToSignatureDeclaration</span><span class="s2">(</span><span class="s1">signature</span><span class="s2">: </span><span class="s1">Signature</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeBuilderFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SignatureDeclaration </span><span class="s2">&amp; {</span>
            <span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;;</span>
        <span class="s2">} | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">indexInfoToIndexSignatureDeclaration</span><span class="s2">(</span><span class="s1">indexInfo</span><span class="s2">: </span><span class="s1">IndexInfo</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeBuilderFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">IndexSignatureDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToEntityName</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">, </span><span class="s1">meaning</span><span class="s2">: </span><span class="s1">SymbolFlags</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeBuilderFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToExpression</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">, </span><span class="s1">meaning</span><span class="s2">: </span><span class="s1">SymbolFlags</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeBuilderFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToTypeParameterDeclarations</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeBuilderFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">symbolToParameterDeclaration</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeBuilderFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Note that the resulting nodes cannot be checked. */</span>
        <span class="s1">typeParameterToDeclaration</span><span class="s2">(</span><span class="s1">parameter</span><span class="s2">: </span><span class="s1">TypeParameter</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeBuilderFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSymbolsInScope</span><span class="s2">(</span><span class="s1">location</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">meaning</span><span class="s2">: </span><span class="s1">SymbolFlags</span><span class="s2">): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">getSymbolAtLocation</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSymbolsOfParameterPropertyDeclaration</span><span class="s2">(</span><span class="s1">parameter</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">parameterName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* The function returns the value (local variable) symbol of an identifier in the short-hand property assignment.</span>
         <span class="s5">* This is necessary as an identifier in short-hand property assignment can contains two meaning: property name and property value.</span>
         <span class="s5">*/</span>
        <span class="s1">getShorthandAssignmentValueSymbol</span><span class="s2">(</span><span class="s1">location</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getExportSpecifierLocalTargetSymbol</span><span class="s2">(</span><span class="s1">location</span><span class="s2">: </span><span class="s1">ExportSpecifier </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* If a symbol is a local symbol with an associated exported symbol, returns the exported symbol.</span>
         <span class="s5">* Otherwise returns its input.</span>
         <span class="s5">* For example, at `export type T = number;`:</span>
         <span class="s5">*     - `getSymbolAtLocation` at the location `T` will return the exported symbol for `T`.</span>
         <span class="s5">*     - But the result of `getSymbolsInScope` will contain the *local* symbol for `T`, not the exported symbol.</span>
         <span class="s5">*     - Calling `getExportSymbolOfSymbol` on that local symbol will return the exported symbol.</span>
         <span class="s5">*/</span>
        <span class="s1">getExportSymbolOfSymbol</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">Symbol</span><span class="s2">;</span>
        <span class="s1">getPropertySymbolOfDestructuringAssignment</span><span class="s2">(</span><span class="s1">location</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getTypeOfAssignmentPattern</span><span class="s2">(</span><span class="s1">pattern</span><span class="s2">: </span><span class="s1">AssignmentPattern</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getTypeAtLocation</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getTypeFromTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">signatureToString</span><span class="s2">(</span><span class="s1">signature</span><span class="s2">: </span><span class="s1">Signature</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">?: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">TypeFormatFlags</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">?: </span><span class="s1">SignatureKind</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">typeToString</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">?: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">TypeFormatFlags</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">symbolToString</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">?: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">meaning</span><span class="s2">?: </span><span class="s1">SymbolFlags</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">SymbolFormatFlags</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">typePredicateToString</span><span class="s2">(</span><span class="s1">predicate</span><span class="s2">: </span><span class="s1">TypePredicate</span><span class="s2">, </span><span class="s1">enclosingDeclaration</span><span class="s2">?: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">TypeFormatFlags</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getFullyQualifiedName</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getAugmentedPropertiesOfType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">getRootSymbols</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">readonly Symbol</span><span class="s2">[];</span>
        <span class="s1">getSymbolOfExpando</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">allowDeclaration</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getContextualType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* returns unknownSignature in the case of an error.</span>
         <span class="s5">* returns undefined if the node is not valid.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">argumentCount Apparent number of arguments, passed in case of a possibly incomplete call. This should come from an ArgumentListInfo. See `signatureHelp.ts`.</span>
         <span class="s5">*/</span>
        <span class="s1">getResolvedSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CallLikeExpression</span><span class="s2">, </span><span class="s1">candidatesOutArray</span><span class="s2">?: </span><span class="s1">Signature</span><span class="s2">[], </span><span class="s1">argumentCount</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">Signature </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSignatureFromDeclaration</span><span class="s2">(</span><span class="s1">declaration</span><span class="s2">: </span><span class="s1">SignatureDeclaration</span><span class="s2">): </span><span class="s1">Signature </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">isImplementationOfOverload</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SignatureDeclaration</span><span class="s2">): </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">isUndefinedSymbol</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isArgumentsSymbol</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isUnknownSymbol</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getConstantValue</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">EnumMember </span><span class="s2">| </span><span class="s1">PropertyAccessExpression </span><span class="s2">| </span><span class="s1">ElementAccessExpression</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">isValidPropertyAccess</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyAccessExpression </span><span class="s2">| </span><span class="s1">QualifiedName </span><span class="s2">| </span><span class="s1">ImportTypeNode</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/** Follow all aliases to get the original symbol. */</span>
        <span class="s1">getAliasedSymbol</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">Symbol</span><span class="s2">;</span>
        <span class="s5">/** Follow a *single* alias to get the immediately aliased symbol. */</span>
        <span class="s1">getImmediateAliasedSymbol</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getExportsOfModule</span><span class="s2">(</span><span class="s1">moduleSymbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">getJsxIntrinsicTagNamesAt</span><span class="s2">(</span><span class="s1">location</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">isOptionalParameter</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getAmbientModules</span><span class="s2">(): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">tryGetMemberInModuleExports</span><span class="s2">(</span><span class="s1">memberName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">moduleSymbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getApparentType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getBaseConstraintOfType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getDefaultFromTypeParameter</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">): </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getTypePredicateOfSignature</span><span class="s2">(</span><span class="s1">signature</span><span class="s2">: </span><span class="s1">Signature</span><span class="s2">): </span><span class="s1">TypePredicate </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Depending on the operation performed, it may be appropriate to throw away the checker</span>
         <span class="s5">* if the cancellation token is triggered. Typically, if it is used for error checking</span>
         <span class="s5">* and the operation is cancelled, then it should be discarded, otherwise it is safe to keep.</span>
         <span class="s5">*/</span>
        <span class="s1">runWithCancellationToken</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">: (</span><span class="s1">checker</span><span class="s2">: </span><span class="s1">TypeChecker</span><span class="s2">) =&gt; </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">NodeBuilderFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">NoTruncation </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">WriteArrayAsGenericType </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">GenerateNamesForShadowedTypeParams </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">UseStructuralFallback </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">ForbidIndexedAccessSymbolReferences </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">WriteTypeArgumentsOfSignature </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">UseFullyQualifiedType </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">UseOnlyExternalAliasing </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">SuppressAnyReturnType </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">WriteTypeParametersInQualifiedName </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">MultilineObjectLiterals </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">WriteClassExpressionAsTypeLiteral </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">UseTypeOfFunction </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">OmitParameterModifiers </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">UseAliasDefinedOutsideCurrentScope </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">UseSingleQuotesForStringLiteralType </span><span class="s2">= </span><span class="s6">268435456</span><span class="s2">,</span>
        <span class="s1">NoTypeReduction </span><span class="s2">= </span><span class="s6">536870912</span><span class="s2">,</span>
        <span class="s1">OmitThisParameter </span><span class="s2">= </span><span class="s6">33554432</span><span class="s2">,</span>
        <span class="s1">AllowThisInObjectLiteral </span><span class="s2">= </span><span class="s6">32768</span><span class="s2">,</span>
        <span class="s1">AllowQualifiedNameInPlaceOfIdentifier </span><span class="s2">= </span><span class="s6">65536</span><span class="s2">,</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">AllowQualifedNameInPlaceOfIdentifier. Use AllowQualifiedNameInPlaceOfIdentifier instead. */</span>
        <span class="s1">AllowQualifedNameInPlaceOfIdentifier </span><span class="s2">= </span><span class="s6">65536</span><span class="s2">,</span>
        <span class="s1">AllowAnonymousIdentifier </span><span class="s2">= </span><span class="s6">131072</span><span class="s2">,</span>
        <span class="s1">AllowEmptyUnionOrIntersection </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">AllowEmptyTuple </span><span class="s2">= </span><span class="s6">524288</span><span class="s2">,</span>
        <span class="s1">AllowUniqueESSymbolType </span><span class="s2">= </span><span class="s6">1048576</span><span class="s2">,</span>
        <span class="s1">AllowEmptyIndexInfoType </span><span class="s2">= </span><span class="s6">2097152</span><span class="s2">,</span>
        <span class="s1">AllowNodeModulesRelativePaths </span><span class="s2">= </span><span class="s6">67108864</span><span class="s2">,</span>
        <span class="s1">IgnoreErrors </span><span class="s2">= </span><span class="s6">70221824</span><span class="s2">,</span>
        <span class="s1">InObjectTypeLiteral </span><span class="s2">= </span><span class="s6">4194304</span><span class="s2">,</span>
        <span class="s1">InTypeAlias </span><span class="s2">= </span><span class="s6">8388608</span><span class="s2">,</span>
        <span class="s1">InInitialEntityName </span><span class="s2">= </span><span class="s6">16777216</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">TypeFormatFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">NoTruncation </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">WriteArrayAsGenericType </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">UseStructuralFallback </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">WriteTypeArgumentsOfSignature </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">UseFullyQualifiedType </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">SuppressAnyReturnType </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">MultilineObjectLiterals </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">WriteClassExpressionAsTypeLiteral </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">UseTypeOfFunction </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">OmitParameterModifiers </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">UseAliasDefinedOutsideCurrentScope </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">UseSingleQuotesForStringLiteralType </span><span class="s2">= </span><span class="s6">268435456</span><span class="s2">,</span>
        <span class="s1">NoTypeReduction </span><span class="s2">= </span><span class="s6">536870912</span><span class="s2">,</span>
        <span class="s1">OmitThisParameter </span><span class="s2">= </span><span class="s6">33554432</span><span class="s2">,</span>
        <span class="s1">AllowUniqueESSymbolType </span><span class="s2">= </span><span class="s6">1048576</span><span class="s2">,</span>
        <span class="s1">AddUndefined </span><span class="s2">= </span><span class="s6">131072</span><span class="s2">,</span>
        <span class="s1">WriteArrowStyleSignature </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">InArrayType </span><span class="s2">= </span><span class="s6">524288</span><span class="s2">,</span>
        <span class="s1">InElementType </span><span class="s2">= </span><span class="s6">2097152</span><span class="s2">,</span>
        <span class="s1">InFirstTypeArgument </span><span class="s2">= </span><span class="s6">4194304</span><span class="s2">,</span>
        <span class="s1">InTypeAlias </span><span class="s2">= </span><span class="s6">8388608</span><span class="s2">,</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">*/ </span><span class="s1">WriteOwnNameForAnyLike </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">NodeBuilderFlagsMask </span><span class="s2">= </span><span class="s6">848330091</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">SymbolFormatFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">WriteTypeParametersOrArguments </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">UseOnlyExternalAliasing </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">AllowAnyNodeKind </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">UseAliasDefinedOutsideCurrentScope </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">TypePredicateKind </span><span class="s2">{</span>
        <span class="s1">This </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Identifier </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">AssertsThis </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">AssertsIdentifier </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypePredicateBase </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">TypePredicateKind</span><span class="s2">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ThisTypePredicate </span><span class="s3">extends </span><span class="s1">TypePredicateBase </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">TypePredicateKind</span><span class="s2">.</span><span class="s1">This</span><span class="s2">;</span>
        <span class="s1">parameterName</span><span class="s2">: </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">parameterIndex</span><span class="s2">: </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">IdentifierTypePredicate </span><span class="s3">extends </span><span class="s1">TypePredicateBase </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">TypePredicateKind</span><span class="s2">.</span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">parameterName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">parameterIndex</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">AssertsThisTypePredicate </span><span class="s3">extends </span><span class="s1">TypePredicateBase </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">TypePredicateKind</span><span class="s2">.</span><span class="s1">AssertsThis</span><span class="s2">;</span>
        <span class="s1">parameterName</span><span class="s2">: </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">parameterIndex</span><span class="s2">: </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">AssertsIdentifierTypePredicate </span><span class="s3">extends </span><span class="s1">TypePredicateBase </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">TypePredicateKind</span><span class="s2">.</span><span class="s1">AssertsIdentifier</span><span class="s2">;</span>
        <span class="s1">parameterName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">parameterIndex</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type TypePredicate </span><span class="s2">= </span><span class="s1">ThisTypePredicate </span><span class="s2">| </span><span class="s1">IdentifierTypePredicate </span><span class="s2">| </span><span class="s1">AssertsThisTypePredicate </span><span class="s2">| </span><span class="s1">AssertsIdentifierTypePredicate</span><span class="s2">;</span>
    <span class="s3">export enum </span><span class="s1">SymbolFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">FunctionScopedVariable </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">BlockScopedVariable </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">Property </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">EnumMember </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Function </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">Class </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">Interface </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">ConstEnum </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">RegularEnum </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">ValueModule </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">NamespaceModule </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">TypeLiteral </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">ObjectLiteral </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">Method </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">Constructor </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">GetAccessor </span><span class="s2">= </span><span class="s6">32768</span><span class="s2">,</span>
        <span class="s1">SetAccessor </span><span class="s2">= </span><span class="s6">65536</span><span class="s2">,</span>
        <span class="s1">Signature </span><span class="s2">= </span><span class="s6">131072</span><span class="s2">,</span>
        <span class="s1">TypeParameter </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">TypeAlias </span><span class="s2">= </span><span class="s6">524288</span><span class="s2">,</span>
        <span class="s1">ExportValue </span><span class="s2">= </span><span class="s6">1048576</span><span class="s2">,</span>
        <span class="s1">Alias </span><span class="s2">= </span><span class="s6">2097152</span><span class="s2">,</span>
        <span class="s1">Prototype </span><span class="s2">= </span><span class="s6">4194304</span><span class="s2">,</span>
        <span class="s1">ExportStar </span><span class="s2">= </span><span class="s6">8388608</span><span class="s2">,</span>
        <span class="s1">Optional </span><span class="s2">= </span><span class="s6">16777216</span><span class="s2">,</span>
        <span class="s1">Transient </span><span class="s2">= </span><span class="s6">33554432</span><span class="s2">,</span>
        <span class="s1">Assignment </span><span class="s2">= </span><span class="s6">67108864</span><span class="s2">,</span>
        <span class="s1">ModuleExports </span><span class="s2">= </span><span class="s6">134217728</span><span class="s2">,</span>
        <span class="s1">Enum </span><span class="s2">= </span><span class="s6">384</span><span class="s2">,</span>
        <span class="s1">Variable </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">Value </span><span class="s2">= </span><span class="s6">111551</span><span class="s2">,</span>
        <span class="s1">Type </span><span class="s2">= </span><span class="s6">788968</span><span class="s2">,</span>
        <span class="s1">Namespace </span><span class="s2">= </span><span class="s6">1920</span><span class="s2">,</span>
        <span class="s1">Module </span><span class="s2">= </span><span class="s6">1536</span><span class="s2">,</span>
        <span class="s1">Accessor </span><span class="s2">= </span><span class="s6">98304</span><span class="s2">,</span>
        <span class="s1">FunctionScopedVariableExcludes </span><span class="s2">= </span><span class="s6">111550</span><span class="s2">,</span>
        <span class="s1">BlockScopedVariableExcludes </span><span class="s2">= </span><span class="s6">111551</span><span class="s2">,</span>
        <span class="s1">ParameterExcludes </span><span class="s2">= </span><span class="s6">111551</span><span class="s2">,</span>
        <span class="s1">PropertyExcludes </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">EnumMemberExcludes </span><span class="s2">= </span><span class="s6">900095</span><span class="s2">,</span>
        <span class="s1">FunctionExcludes </span><span class="s2">= </span><span class="s6">110991</span><span class="s2">,</span>
        <span class="s1">ClassExcludes </span><span class="s2">= </span><span class="s6">899503</span><span class="s2">,</span>
        <span class="s1">InterfaceExcludes </span><span class="s2">= </span><span class="s6">788872</span><span class="s2">,</span>
        <span class="s1">RegularEnumExcludes </span><span class="s2">= </span><span class="s6">899327</span><span class="s2">,</span>
        <span class="s1">ConstEnumExcludes </span><span class="s2">= </span><span class="s6">899967</span><span class="s2">,</span>
        <span class="s1">ValueModuleExcludes </span><span class="s2">= </span><span class="s6">110735</span><span class="s2">,</span>
        <span class="s1">NamespaceModuleExcludes </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">MethodExcludes </span><span class="s2">= </span><span class="s6">103359</span><span class="s2">,</span>
        <span class="s1">GetAccessorExcludes </span><span class="s2">= </span><span class="s6">46015</span><span class="s2">,</span>
        <span class="s1">SetAccessorExcludes </span><span class="s2">= </span><span class="s6">78783</span><span class="s2">,</span>
        <span class="s1">AccessorExcludes </span><span class="s2">= </span><span class="s6">13247</span><span class="s2">,</span>
        <span class="s1">TypeParameterExcludes </span><span class="s2">= </span><span class="s6">526824</span><span class="s2">,</span>
        <span class="s1">TypeAliasExcludes </span><span class="s2">= </span><span class="s6">788968</span><span class="s2">,</span>
        <span class="s1">AliasExcludes </span><span class="s2">= </span><span class="s6">2097152</span><span class="s2">,</span>
        <span class="s1">ModuleMember </span><span class="s2">= </span><span class="s6">2623475</span><span class="s2">,</span>
        <span class="s1">ExportHasLocal </span><span class="s2">= </span><span class="s6">944</span><span class="s2">,</span>
        <span class="s1">BlockScoped </span><span class="s2">= </span><span class="s6">418</span><span class="s2">,</span>
        <span class="s1">PropertyOrAccessor </span><span class="s2">= </span><span class="s6">98308</span><span class="s2">,</span>
        <span class="s1">ClassMember </span><span class="s2">= </span><span class="s6">106500</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Symbol </span><span class="s2">{</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s1">SymbolFlags</span><span class="s2">;</span>
        <span class="s1">escapedName</span><span class="s2">: </span><span class="s1">__String</span><span class="s2">;</span>
        <span class="s1">declarations</span><span class="s2">?: </span><span class="s1">Declaration</span><span class="s2">[];</span>
        <span class="s1">valueDeclaration</span><span class="s2">?: </span><span class="s1">Declaration</span><span class="s2">;</span>
        <span class="s1">members</span><span class="s2">?: </span><span class="s1">SymbolTable</span><span class="s2">;</span>
        <span class="s1">exports</span><span class="s2">?: </span><span class="s1">SymbolTable</span><span class="s2">;</span>
        <span class="s1">globalExports</span><span class="s2">?: </span><span class="s1">SymbolTable</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">InternalSymbolName </span><span class="s2">{</span>
        <span class="s1">Call </span><span class="s2">= </span><span class="s4">&quot;__call&quot;</span><span class="s2">,</span>
        <span class="s1">Constructor </span><span class="s2">= </span><span class="s4">&quot;__constructor&quot;</span><span class="s2">,</span>
        <span class="s1">New </span><span class="s2">= </span><span class="s4">&quot;__new&quot;</span><span class="s2">,</span>
        <span class="s1">Index </span><span class="s2">= </span><span class="s4">&quot;__index&quot;</span><span class="s2">,</span>
        <span class="s1">ExportStar </span><span class="s2">= </span><span class="s4">&quot;__export&quot;</span><span class="s2">,</span>
        <span class="s1">Global </span><span class="s2">= </span><span class="s4">&quot;__global&quot;</span><span class="s2">,</span>
        <span class="s1">Missing </span><span class="s2">= </span><span class="s4">&quot;__missing&quot;</span><span class="s2">,</span>
        <span class="s1">Type </span><span class="s2">= </span><span class="s4">&quot;__type&quot;</span><span class="s2">,</span>
        <span class="s1">Object </span><span class="s2">= </span><span class="s4">&quot;__object&quot;</span><span class="s2">,</span>
        <span class="s1">JSXAttributes </span><span class="s2">= </span><span class="s4">&quot;__jsxAttributes&quot;</span><span class="s2">,</span>
        <span class="s1">Class </span><span class="s2">= </span><span class="s4">&quot;__class&quot;</span><span class="s2">,</span>
        <span class="s1">Function </span><span class="s2">= </span><span class="s4">&quot;__function&quot;</span><span class="s2">,</span>
        <span class="s1">Computed </span><span class="s2">= </span><span class="s4">&quot;__computed&quot;</span><span class="s2">,</span>
        <span class="s1">Resolving </span><span class="s2">= </span><span class="s4">&quot;__resolving__&quot;</span><span class="s2">,</span>
        <span class="s1">ExportEquals </span><span class="s2">= </span><span class="s4">&quot;export=&quot;</span><span class="s2">,</span>
        <span class="s1">Default </span><span class="s2">= </span><span class="s4">&quot;default&quot;</span><span class="s2">,</span>
        <span class="s1">This </span><span class="s2">= </span><span class="s4">&quot;this&quot;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* This represents a string whose leading underscore have been escaped by adding extra leading underscores.</span>
     <span class="s5">* The shape of this brand is rather unique compared to others we've used.</span>
     <span class="s5">* Instead of just an intersection of a string and an object, it is that union-ed</span>
     <span class="s5">* with an intersection of void and an object. This makes it wholly incompatible</span>
     <span class="s5">* with a normal string (which is good, it cannot be misused on assignment or on usage),</span>
     <span class="s5">* while still being comparable with a normal string via === (also good) and castable from a string.</span>
     <span class="s5">*/</span>
    <span class="s3">export </span><span class="s1">type __String </span><span class="s2">= (</span><span class="s1">string </span><span class="s2">&amp; {</span>
        <span class="s1">__escapedIdentifier</span><span class="s2">: </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}) | (</span><span class="s3">void </span><span class="s2">&amp; {</span>
        <span class="s1">__escapedIdentifier</span><span class="s2">: </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}) | </span><span class="s1">InternalSymbolName</span><span class="s2">;</span>
    <span class="s5">/** ReadonlyMap where keys are `__String`s. */</span>
    <span class="s3">export interface </span><span class="s1">ReadonlyUnderscoreEscapedMap</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyESMap</span><span class="s2">&lt;</span><span class="s1">__String</span><span class="s2">, </span><span class="s1">T</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s5">/** Map where keys are `__String`s. */</span>
    <span class="s3">export interface </span><span class="s1">UnderscoreEscapedMap</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ESMap</span><span class="s2">&lt;</span><span class="s1">__String</span><span class="s2">, </span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">ReadonlyUnderscoreEscapedMap</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s5">/** SymbolTable based on ES6 Map interface. */</span>
    <span class="s3">export </span><span class="s1">type SymbolTable </span><span class="s2">= </span><span class="s1">UnderscoreEscapedMap</span><span class="s2">&lt;</span><span class="s1">Symbol</span><span class="s2">&gt;;</span>
    <span class="s3">export enum </span><span class="s1">TypeFlags </span><span class="s2">{</span>
        <span class="s1">Any </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Unknown </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">String </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">Number </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Boolean </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">Enum </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">BigInt </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">StringLiteral </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">NumberLiteral </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">BooleanLiteral </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">EnumLiteral </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">BigIntLiteral </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">ESSymbol </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">UniqueESSymbol </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">Void </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">Undefined </span><span class="s2">= </span><span class="s6">32768</span><span class="s2">,</span>
        <span class="s1">Null </span><span class="s2">= </span><span class="s6">65536</span><span class="s2">,</span>
        <span class="s1">Never </span><span class="s2">= </span><span class="s6">131072</span><span class="s2">,</span>
        <span class="s1">TypeParameter </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">Object </span><span class="s2">= </span><span class="s6">524288</span><span class="s2">,</span>
        <span class="s1">Union </span><span class="s2">= </span><span class="s6">1048576</span><span class="s2">,</span>
        <span class="s1">Intersection </span><span class="s2">= </span><span class="s6">2097152</span><span class="s2">,</span>
        <span class="s1">Index </span><span class="s2">= </span><span class="s6">4194304</span><span class="s2">,</span>
        <span class="s1">IndexedAccess </span><span class="s2">= </span><span class="s6">8388608</span><span class="s2">,</span>
        <span class="s1">Conditional </span><span class="s2">= </span><span class="s6">16777216</span><span class="s2">,</span>
        <span class="s1">Substitution </span><span class="s2">= </span><span class="s6">33554432</span><span class="s2">,</span>
        <span class="s1">NonPrimitive </span><span class="s2">= </span><span class="s6">67108864</span><span class="s2">,</span>
        <span class="s1">TemplateLiteral </span><span class="s2">= </span><span class="s6">134217728</span><span class="s2">,</span>
        <span class="s1">StringMapping </span><span class="s2">= </span><span class="s6">268435456</span><span class="s2">,</span>
        <span class="s1">Literal </span><span class="s2">= </span><span class="s6">2944</span><span class="s2">,</span>
        <span class="s1">Unit </span><span class="s2">= </span><span class="s6">109440</span><span class="s2">,</span>
        <span class="s1">StringOrNumberLiteral </span><span class="s2">= </span><span class="s6">384</span><span class="s2">,</span>
        <span class="s1">PossiblyFalsy </span><span class="s2">= </span><span class="s6">117724</span><span class="s2">,</span>
        <span class="s1">StringLike </span><span class="s2">= </span><span class="s6">402653316</span><span class="s2">,</span>
        <span class="s1">NumberLike </span><span class="s2">= </span><span class="s6">296</span><span class="s2">,</span>
        <span class="s1">BigIntLike </span><span class="s2">= </span><span class="s6">2112</span><span class="s2">,</span>
        <span class="s1">BooleanLike </span><span class="s2">= </span><span class="s6">528</span><span class="s2">,</span>
        <span class="s1">EnumLike </span><span class="s2">= </span><span class="s6">1056</span><span class="s2">,</span>
        <span class="s1">ESSymbolLike </span><span class="s2">= </span><span class="s6">12288</span><span class="s2">,</span>
        <span class="s1">VoidLike </span><span class="s2">= </span><span class="s6">49152</span><span class="s2">,</span>
        <span class="s1">UnionOrIntersection </span><span class="s2">= </span><span class="s6">3145728</span><span class="s2">,</span>
        <span class="s1">StructuredType </span><span class="s2">= </span><span class="s6">3670016</span><span class="s2">,</span>
        <span class="s1">TypeVariable </span><span class="s2">= </span><span class="s6">8650752</span><span class="s2">,</span>
        <span class="s1">InstantiableNonPrimitive </span><span class="s2">= </span><span class="s6">58982400</span><span class="s2">,</span>
        <span class="s1">InstantiablePrimitive </span><span class="s2">= </span><span class="s6">406847488</span><span class="s2">,</span>
        <span class="s1">Instantiable </span><span class="s2">= </span><span class="s6">465829888</span><span class="s2">,</span>
        <span class="s1">StructuredOrInstantiable </span><span class="s2">= </span><span class="s6">469499904</span><span class="s2">,</span>
        <span class="s1">Narrowable </span><span class="s2">= </span><span class="s6">536624127</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type DestructuringPattern </span><span class="s2">= </span><span class="s1">BindingPattern </span><span class="s2">| </span><span class="s1">ObjectLiteralExpression </span><span class="s2">| </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">Type </span><span class="s2">{</span>
        <span class="s1">flags</span><span class="s2">: </span><span class="s1">TypeFlags</span><span class="s2">;</span>
        <span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">;</span>
        <span class="s1">pattern</span><span class="s2">?: </span><span class="s1">DestructuringPattern</span><span class="s2">;</span>
        <span class="s1">aliasSymbol</span><span class="s2">?: </span><span class="s1">Symbol</span><span class="s2">;</span>
        <span class="s1">aliasTypeArguments</span><span class="s2">?: </span><span class="s1">readonly Type</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">LiteralType </span><span class="s3">extends </span><span class="s1">Type </span><span class="s2">{</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number </span><span class="s2">| </span><span class="s1">PseudoBigInt</span><span class="s2">;</span>
        <span class="s1">freshType</span><span class="s2">: </span><span class="s1">LiteralType</span><span class="s2">;</span>
        <span class="s1">regularType</span><span class="s2">: </span><span class="s1">LiteralType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UniqueESSymbolType </span><span class="s3">extends </span><span class="s1">Type </span><span class="s2">{</span>
        <span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">;</span>
        <span class="s1">escapedName</span><span class="s2">: </span><span class="s1">__String</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">StringLiteralType </span><span class="s3">extends </span><span class="s1">LiteralType </span><span class="s2">{</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NumberLiteralType </span><span class="s3">extends </span><span class="s1">LiteralType </span><span class="s2">{</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">BigIntLiteralType </span><span class="s3">extends </span><span class="s1">LiteralType </span><span class="s2">{</span>
        <span class="s1">value</span><span class="s2">: </span><span class="s1">PseudoBigInt</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">EnumType </span><span class="s3">extends </span><span class="s1">Type </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ObjectFlags </span><span class="s2">{</span>
        <span class="s1">Class </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Interface </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">Reference </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">Tuple </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Anonymous </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">Mapped </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">Instantiated </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">ObjectLiteral </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">EvolvingArray </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">ObjectLiteralPatternWithComputedProperties </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">ReverseMapped </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">JsxAttributes </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">JSLiteral </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">FreshLiteral </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">ArrayLiteral </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">ClassOrInterface </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">ContainsSpread </span><span class="s2">= </span><span class="s6">2097152</span><span class="s2">,</span>
        <span class="s1">ObjectRestType </span><span class="s2">= </span><span class="s6">4194304</span><span class="s2">,</span>
        <span class="s1">InstantiationExpressionType </span><span class="s2">= </span><span class="s6">8388608</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ObjectType </span><span class="s3">extends </span><span class="s1">Type </span><span class="s2">{</span>
        <span class="s1">objectFlags</span><span class="s2">: </span><span class="s1">ObjectFlags</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** Class and interface types (ObjectFlags.Class and ObjectFlags.Interface). */</span>
    <span class="s3">export interface </span><span class="s1">InterfaceType </span><span class="s3">extends </span><span class="s1">ObjectType </span><span class="s2">{</span>
        <span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">TypeParameter</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">outerTypeParameters</span><span class="s2">: </span><span class="s1">TypeParameter</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">localTypeParameters</span><span class="s2">: </span><span class="s1">TypeParameter</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">thisType</span><span class="s2">: </span><span class="s1">TypeParameter </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type BaseType </span><span class="s2">= </span><span class="s1">ObjectType </span><span class="s2">| </span><span class="s1">IntersectionType </span><span class="s2">| </span><span class="s1">TypeVariable</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">InterfaceTypeWithDeclaredMembers </span><span class="s3">extends </span><span class="s1">InterfaceType </span><span class="s2">{</span>
        <span class="s1">declaredProperties</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">declaredCallSignatures</span><span class="s2">: </span><span class="s1">Signature</span><span class="s2">[];</span>
        <span class="s1">declaredConstructSignatures</span><span class="s2">: </span><span class="s1">Signature</span><span class="s2">[];</span>
        <span class="s1">declaredIndexInfos</span><span class="s2">: </span><span class="s1">IndexInfo</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Type references (ObjectFlags.Reference). When a class or interface has type parameters or</span>
     <span class="s5">* a &quot;this&quot; type, references to the class or interface are made using type references. The</span>
     <span class="s5">* typeArguments property specifies the types to substitute for the type parameters of the</span>
     <span class="s5">* class or interface and optionally includes an extra element that specifies the type to</span>
     <span class="s5">* substitute for &quot;this&quot; in the resulting instantiation. When no extra argument is present,</span>
     <span class="s5">* the type reference itself is substituted for &quot;this&quot;. The typeArguments property is undefined</span>
     <span class="s5">* if the class or interface has no type parameters and the reference isn't specifying an</span>
     <span class="s5">* explicit &quot;this&quot; argument.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">TypeReference </span><span class="s3">extends </span><span class="s1">ObjectType </span><span class="s2">{</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s1">GenericType</span><span class="s2">;</span>
        <span class="s1">node</span><span class="s2">?: </span><span class="s1">TypeReferenceNode </span><span class="s2">| </span><span class="s1">ArrayTypeNode </span><span class="s2">| </span><span class="s1">TupleTypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DeferredTypeReference </span><span class="s3">extends </span><span class="s1">TypeReference </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">GenericType </span><span class="s3">extends </span><span class="s1">InterfaceType</span><span class="s2">, </span><span class="s1">TypeReference </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ElementFlags </span><span class="s2">{</span>
        <span class="s1">Required </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Optional </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">Rest </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">Variadic </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Fixed </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">Variable </span><span class="s2">= </span><span class="s6">12</span><span class="s2">,</span>
        <span class="s1">NonRequired </span><span class="s2">= </span><span class="s6">14</span><span class="s2">,</span>
        <span class="s1">NonRest </span><span class="s2">= </span><span class="s6">11</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TupleType </span><span class="s3">extends </span><span class="s1">GenericType </span><span class="s2">{</span>
        <span class="s1">elementFlags</span><span class="s2">: </span><span class="s1">readonly ElementFlags</span><span class="s2">[];</span>
        <span class="s1">minLength</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">fixedLength</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">hasRestElement</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">combinedFlags</span><span class="s2">: </span><span class="s1">ElementFlags</span><span class="s2">;</span>
        <span class="s1">readonly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">labeledElementDeclarations</span><span class="s2">?: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">NamedTupleMember </span><span class="s2">| </span><span class="s1">ParameterDeclaration</span><span class="s2">)[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TupleTypeReference </span><span class="s3">extends </span><span class="s1">TypeReference </span><span class="s2">{</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s1">TupleType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnionOrIntersectionType </span><span class="s3">extends </span><span class="s1">Type </span><span class="s2">{</span>
        <span class="s1">types</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnionType </span><span class="s3">extends </span><span class="s1">UnionOrIntersectionType </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">IntersectionType </span><span class="s3">extends </span><span class="s1">UnionOrIntersectionType </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type StructuredType </span><span class="s2">= </span><span class="s1">ObjectType </span><span class="s2">| </span><span class="s1">UnionType </span><span class="s2">| </span><span class="s1">IntersectionType</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">EvolvingArrayType </span><span class="s3">extends </span><span class="s1">ObjectType </span><span class="s2">{</span>
        <span class="s1">elementType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">finalArrayType</span><span class="s2">?: </span><span class="s1">Type</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">InstantiableType </span><span class="s3">extends </span><span class="s1">Type </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeParameter </span><span class="s3">extends </span><span class="s1">InstantiableType </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">IndexedAccessType </span><span class="s3">extends </span><span class="s1">InstantiableType </span><span class="s2">{</span>
        <span class="s1">objectType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">indexType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">constraint</span><span class="s2">?: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">simplifiedForReading</span><span class="s2">?: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">simplifiedForWriting</span><span class="s2">?: </span><span class="s1">Type</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type TypeVariable </span><span class="s2">= </span><span class="s1">TypeParameter </span><span class="s2">| </span><span class="s1">IndexedAccessType</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">IndexType </span><span class="s3">extends </span><span class="s1">InstantiableType </span><span class="s2">{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">InstantiableType </span><span class="s2">| </span><span class="s1">UnionOrIntersectionType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ConditionalRoot </span><span class="s2">{</span>
        <span class="s1">node</span><span class="s2">: </span><span class="s1">ConditionalTypeNode</span><span class="s2">;</span>
        <span class="s1">checkType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">extendsType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">isDistributive</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">inferTypeParameters</span><span class="s2">?: </span><span class="s1">TypeParameter</span><span class="s2">[];</span>
        <span class="s1">outerTypeParameters</span><span class="s2">?: </span><span class="s1">TypeParameter</span><span class="s2">[];</span>
        <span class="s1">instantiations</span><span class="s2">?: </span><span class="s1">Map</span><span class="s2">&lt;</span><span class="s1">Type</span><span class="s2">&gt;;</span>
        <span class="s1">aliasSymbol</span><span class="s2">?: </span><span class="s1">Symbol</span><span class="s2">;</span>
        <span class="s1">aliasTypeArguments</span><span class="s2">?: </span><span class="s1">Type</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ConditionalType </span><span class="s3">extends </span><span class="s1">InstantiableType </span><span class="s2">{</span>
        <span class="s1">root</span><span class="s2">: </span><span class="s1">ConditionalRoot</span><span class="s2">;</span>
        <span class="s1">checkType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">extendsType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">resolvedTrueType</span><span class="s2">?: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">resolvedFalseType</span><span class="s2">?: </span><span class="s1">Type</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TemplateLiteralType </span><span class="s3">extends </span><span class="s1">InstantiableType </span><span class="s2">{</span>
        <span class="s1">texts</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[];</span>
        <span class="s1">types</span><span class="s2">: </span><span class="s1">readonly Type</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">StringMappingType </span><span class="s3">extends </span><span class="s1">InstantiableType </span><span class="s2">{</span>
        <span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SubstitutionType </span><span class="s3">extends </span><span class="s1">InstantiableType </span><span class="s2">{</span>
        <span class="s1">objectFlags</span><span class="s2">: </span><span class="s1">ObjectFlags</span><span class="s2">;</span>
        <span class="s1">baseType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">constraint</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">SignatureKind </span><span class="s2">{</span>
        <span class="s1">Call </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Construct </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Signature </span><span class="s2">{</span>
        <span class="s1">declaration</span><span class="s2">?: </span><span class="s1">SignatureDeclaration </span><span class="s2">| </span><span class="s1">JSDocSignature</span><span class="s2">;</span>
        <span class="s1">typeParameters</span><span class="s2">?: </span><span class="s1">readonly TypeParameter</span><span class="s2">[];</span>
        <span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly Symbol</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">IndexKind </span><span class="s2">{</span>
        <span class="s1">String </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Number </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">IndexInfo </span><span class="s2">{</span>
        <span class="s1">keyType</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">isReadonly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">declaration</span><span class="s2">?: </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">InferencePriority </span><span class="s2">{</span>
        <span class="s1">NakedTypeVariable </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">SpeculativeTuple </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">SubstituteSource </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">HomomorphicMappedType </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">PartialHomomorphicMappedType </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">MappedTypeConstraint </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">ContravariantConditional </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">ReturnType </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">LiteralKeyof </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">NoConstraints </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">AlwaysStrict </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">MaxValue </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">PriorityImpliesCombination </span><span class="s2">= </span><span class="s6">416</span><span class="s2">,</span>
        <span class="s1">Circularity </span><span class="s2">= -</span><span class="s6">1</span>
    <span class="s2">}</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use FileExtensionInfo instead. */</span>
    <span class="s3">export </span><span class="s1">type JsFileExtensionInfo </span><span class="s2">= </span><span class="s1">FileExtensionInfo</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">FileExtensionInfo </span><span class="s2">{</span>
        <span class="s1">extension</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">isMixedContent</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DiagnosticMessage </span><span class="s2">{</span>
        <span class="s1">key</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s1">DiagnosticCategory</span><span class="s2">;</span>
        <span class="s1">code</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">reportsUnnecessary</span><span class="s2">?: {};</span>
        <span class="s1">reportsDeprecated</span><span class="s2">?: {};</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* A linked list of formatted diagnostic messages to be used as part of a multiline message.</span>
     <span class="s5">* It is built from the bottom up, leaving the head to be the &quot;main&quot; diagnostic.</span>
     <span class="s5">* While it seems that DiagnosticMessageChain is structurally similar to DiagnosticMessage,</span>
     <span class="s5">* the difference is that messages are all preformatted in DMC.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">DiagnosticMessageChain </span><span class="s2">{</span>
        <span class="s1">messageText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s1">DiagnosticCategory</span><span class="s2">;</span>
        <span class="s1">code</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">next</span><span class="s2">?: </span><span class="s1">DiagnosticMessageChain</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">Diagnostic </span><span class="s3">extends </span><span class="s1">DiagnosticRelatedInformation </span><span class="s2">{</span>
        <span class="s5">/** May store more in future. For now, this will simply be `true` to indicate when a diagnostic is an unused-identifier diagnostic. */</span>
        <span class="s1">reportsUnnecessary</span><span class="s2">?: {};</span>
        <span class="s1">reportsDeprecated</span><span class="s2">?: {};</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">relatedInformation</span><span class="s2">?: </span><span class="s1">DiagnosticRelatedInformation</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DiagnosticRelatedInformation </span><span class="s2">{</span>
        <span class="s1">category</span><span class="s2">: </span><span class="s1">DiagnosticCategory</span><span class="s2">;</span>
        <span class="s1">code</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">messageText</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">DiagnosticMessageChain</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">DiagnosticWithLocation </span><span class="s3">extends </span><span class="s1">Diagnostic </span><span class="s2">{</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">DiagnosticCategory </span><span class="s2">{</span>
        <span class="s1">Warning </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Error </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Suggestion </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">Message </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ModuleResolutionKind </span><span class="s2">{</span>
        <span class="s1">Classic </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">NodeJs </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">Node16 </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">NodeNext </span><span class="s2">= </span><span class="s6">99</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ModuleDetectionKind </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Files with imports, exports and/or import.meta are considered modules</span>
         <span class="s5">*/</span>
        <span class="s1">Legacy </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s5">/**</span>
         <span class="s5">* Legacy, but also files with jsx under react-jsx or react-jsxdev and esm mode files under moduleResolution: node16+</span>
         <span class="s5">*/</span>
        <span class="s1">Auto </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s5">/**</span>
         <span class="s5">* Consider all non-declaration files modules, regardless of present syntax</span>
         <span class="s5">*/</span>
        <span class="s1">Force </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PluginImport </span><span class="s2">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ProjectReference </span><span class="s2">{</span>
        <span class="s5">/** A normalized path on disk */</span>
        <span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** The path as the user originally wrote it */</span>
        <span class="s1">originalPath</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** True if the output of this reference should be prepended to the output of this project. Only valid for --outFile compilations */</span>
        <span class="s1">prepend</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/** True if it is intended that this reference form a circularity */</span>
        <span class="s1">circular</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">WatchFileKind </span><span class="s2">{</span>
        <span class="s1">FixedPollingInterval </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">PriorityPollingInterval </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">DynamicPriorityPolling </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">FixedChunkSizePolling </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">UseFsEvents </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">UseFsEventsOnParentDirectory </span><span class="s2">= </span><span class="s6">5</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">WatchDirectoryKind </span><span class="s2">{</span>
        <span class="s1">UseFsEvents </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">FixedPollingInterval </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">DynamicPriorityPolling </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">FixedChunkSizePolling </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">PollingWatchKind </span><span class="s2">{</span>
        <span class="s1">FixedInterval </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">PriorityInterval </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">DynamicPriority </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">FixedChunkSize </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type CompilerOptionsValue </span><span class="s2">= </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number </span><span class="s2">| </span><span class="s1">boolean </span><span class="s2">| (</span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s2">)[] | </span><span class="s1">string</span><span class="s2">[] | </span><span class="s1">MapLike</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">[]&gt; | </span><span class="s1">PluginImport</span><span class="s2">[] | </span><span class="s1">ProjectReference</span><span class="s2">[] | </span><span class="s3">null </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">CompilerOptions </span><span class="s2">{</span>
        <span class="s1">allowJs</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">allowSyntheticDefaultImports</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">allowUmdGlobalAccess</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">allowUnreachableCode</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">allowUnusedLabels</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">alwaysStrict</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">baseUrl</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">charset</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">checkJs</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">declaration</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">declarationMap</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">emitDeclarationOnly</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">declarationDir</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">disableSizeLimit</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">disableSourceOfProjectReferenceRedirect</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">disableSolutionSearching</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">disableReferencedProjectLoad</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">downlevelIteration</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">emitBOM</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">emitDecoratorMetadata</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">exactOptionalPropertyTypes</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">experimentalDecorators</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">forceConsistentCasingInFileNames</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">importHelpers</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">importsNotUsedAsValues</span><span class="s2">?: </span><span class="s1">ImportsNotUsedAsValues</span><span class="s2">;</span>
        <span class="s1">inlineSourceMap</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">inlineSources</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isolatedModules</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">jsx</span><span class="s2">?: </span><span class="s1">JsxEmit</span><span class="s2">;</span>
        <span class="s1">keyofStringsOnly</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">lib</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">locale</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">mapRoot</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">maxNodeModuleJsDepth</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">module</span><span class="s2">?: </span><span class="s1">ModuleKind</span><span class="s2">;</span>
        <span class="s1">moduleResolution</span><span class="s2">?: </span><span class="s1">ModuleResolutionKind</span><span class="s2">;</span>
        <span class="s1">moduleSuffixes</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">moduleDetection</span><span class="s2">?: </span><span class="s1">ModuleDetectionKind</span><span class="s2">;</span>
        <span class="s1">newLine</span><span class="s2">?: </span><span class="s1">NewLineKind</span><span class="s2">;</span>
        <span class="s1">noEmit</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noEmitHelpers</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noEmitOnError</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noErrorTruncation</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noFallthroughCasesInSwitch</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noImplicitAny</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noImplicitReturns</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noImplicitThis</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noStrictGenericChecks</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noUnusedLocals</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noUnusedParameters</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noImplicitUseStrict</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noPropertyAccessFromIndexSignature</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">assumeChangesOnlyAffectDirectDependencies</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noLib</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noResolve</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noUncheckedIndexedAccess</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">out</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">outDir</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">outFile</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">paths</span><span class="s2">?: </span><span class="s1">MapLike</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">[]&gt;;</span>
        <span class="s1">preserveConstEnums</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noImplicitOverride</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">preserveSymlinks</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">preserveValueImports</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">project</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">reactNamespace</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">jsxFactory</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">jsxFragmentFactory</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">jsxImportSource</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">composite</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">incremental</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">tsBuildInfoFile</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">removeComments</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">rootDir</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">rootDirs</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">skipLibCheck</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">skipDefaultLibCheck</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">sourceMap</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">sourceRoot</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">strict</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">strictFunctionTypes</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">strictBindCallApply</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">strictNullChecks</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">strictPropertyInitialization</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">stripInternal</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">suppressExcessPropertyErrors</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">suppressImplicitAnyIndexErrors</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">target</span><span class="s2">?: </span><span class="s1">ScriptTarget</span><span class="s2">;</span>
        <span class="s1">traceResolution</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">useUnknownInCatchVariables</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">resolveJsonModule</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">types</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s5">/** Paths used to compute primary types search locations */</span>
        <span class="s1">typeRoots</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">esModuleInterop</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">useDefineForClassFields</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s2">[</span><span class="s1">option</span><span class="s2">: </span><span class="s1">string</span><span class="s2">]: </span><span class="s1">CompilerOptionsValue </span><span class="s2">| </span><span class="s1">TsConfigSourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">WatchOptions </span><span class="s2">{</span>
        <span class="s1">watchFile</span><span class="s2">?: </span><span class="s1">WatchFileKind</span><span class="s2">;</span>
        <span class="s1">watchDirectory</span><span class="s2">?: </span><span class="s1">WatchDirectoryKind</span><span class="s2">;</span>
        <span class="s1">fallbackPolling</span><span class="s2">?: </span><span class="s1">PollingWatchKind</span><span class="s2">;</span>
        <span class="s1">synchronousWatchDirectory</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">excludeDirectories</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">excludeFiles</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s2">[</span><span class="s1">option</span><span class="s2">: </span><span class="s1">string</span><span class="s2">]: </span><span class="s1">CompilerOptionsValue </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TypeAcquisition </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">typingOptions.enableAutoDiscovery</span>
         <span class="s5">* Use typeAcquisition.enable instead.</span>
         <span class="s5">*/</span>
        <span class="s1">enableAutoDiscovery</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">enable</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">include</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">exclude</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">disableFilenameBasedTypeAcquisition</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s2">[</span><span class="s1">option</span><span class="s2">: </span><span class="s1">string</span><span class="s2">]: </span><span class="s1">CompilerOptionsValue </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ModuleKind </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">CommonJS </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">AMD </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">UMD </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">System </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">ES2015 </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">ES2020 </span><span class="s2">= </span><span class="s6">6</span><span class="s2">,</span>
        <span class="s1">ES2022 </span><span class="s2">= </span><span class="s6">7</span><span class="s2">,</span>
        <span class="s1">ESNext </span><span class="s2">= </span><span class="s6">99</span><span class="s2">,</span>
        <span class="s1">Node16 </span><span class="s2">= </span><span class="s6">100</span><span class="s2">,</span>
        <span class="s1">NodeNext </span><span class="s2">= </span><span class="s6">199</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">JsxEmit </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Preserve </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">React </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">ReactNative </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">ReactJSX </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">ReactJSXDev </span><span class="s2">= </span><span class="s6">5</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ImportsNotUsedAsValues </span><span class="s2">{</span>
        <span class="s1">Remove </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Preserve </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Error </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">NewLineKind </span><span class="s2">{</span>
        <span class="s1">CarriageReturnLineFeed </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">LineFeed </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">LineAndCharacter </span><span class="s2">{</span>
        <span class="s5">/** 0-based. */</span>
        <span class="s1">line</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">character</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ScriptKind </span><span class="s2">{</span>
        <span class="s1">Unknown </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">JS </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">JSX </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">TS </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">TSX </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">External </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">JSON </span><span class="s2">= </span><span class="s6">6</span><span class="s2">,</span>
        <span class="s5">/**</span>
         <span class="s5">* Used on extensions that doesn't define the ScriptKind but the content defines it.</span>
         <span class="s5">* Deferred extensions are going to be included in all project contexts.</span>
         <span class="s5">*/</span>
        <span class="s1">Deferred </span><span class="s2">= </span><span class="s6">7</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ScriptTarget </span><span class="s2">{</span>
        <span class="s1">ES3 </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">ES5 </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">ES2015 </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">ES2016 </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">ES2017 </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">ES2018 </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">ES2019 </span><span class="s2">= </span><span class="s6">6</span><span class="s2">,</span>
        <span class="s1">ES2020 </span><span class="s2">= </span><span class="s6">7</span><span class="s2">,</span>
        <span class="s1">ES2021 </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">ES2022 </span><span class="s2">= </span><span class="s6">9</span><span class="s2">,</span>
        <span class="s1">ESNext </span><span class="s2">= </span><span class="s6">99</span><span class="s2">,</span>
        <span class="s1">JSON </span><span class="s2">= </span><span class="s6">100</span><span class="s2">,</span>
        <span class="s1">Latest </span><span class="s2">= </span><span class="s6">99</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">LanguageVariant </span><span class="s2">{</span>
        <span class="s1">Standard </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">JSX </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s2">}</span>
    <span class="s5">/** Either a parsed command line or a parsed tsconfig.json */</span>
    <span class="s3">export interface </span><span class="s1">ParsedCommandLine </span><span class="s2">{</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">typeAcquisition</span><span class="s2">?: </span><span class="s1">TypeAcquisition</span><span class="s2">;</span>
        <span class="s1">fileNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[];</span>
        <span class="s1">watchOptions</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">;</span>
        <span class="s1">raw</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s1">Diagnostic</span><span class="s2">[];</span>
        <span class="s1">wildcardDirectories</span><span class="s2">?: </span><span class="s1">MapLike</span><span class="s2">&lt;</span><span class="s1">WatchDirectoryFlags</span><span class="s2">&gt;;</span>
        <span class="s1">compileOnSave</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">WatchDirectoryFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Recursive </span><span class="s2">= </span><span class="s6">1</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CreateProgramOptions </span><span class="s2">{</span>
        <span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[];</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[];</span>
        <span class="s1">host</span><span class="s2">?: </span><span class="s1">CompilerHost</span><span class="s2">;</span>
        <span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">Program</span><span class="s2">;</span>
        <span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ModuleResolutionHost </span><span class="s2">{</span>
        <span class="s1">fileExists</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">trace</span><span class="s2">?(</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">directoryExists</span><span class="s2">?(</span><span class="s1">directoryName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Resolve a symbolic link.</span>
         <span class="s5">* </span><span class="s7">@see </span><span class="s5">https://nodejs.org/api/fs.html#fs_fs_realpathsync_path_options</span>
         <span class="s5">*/</span>
        <span class="s1">realpath</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">?(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getDirectories</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| (() =&gt; </span><span class="s1">boolean</span><span class="s2">) | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Used by services to specify the minimum host area required to set up source files under any compilation settings</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">MinimalResolutionCacheHost </span><span class="s3">extends </span><span class="s1">ModuleResolutionHost </span><span class="s2">{</span>
        <span class="s1">getCompilationSettings</span><span class="s2">(): </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">getCompilerHost</span><span class="s2">?(): </span><span class="s1">CompilerHost </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Represents the result of module resolution.</span>
     <span class="s5">* Module resolution will pick up tsx/jsx/js files even if '--jsx' and '--allowJs' are turned off.</span>
     <span class="s5">* The Program will then filter results based on these flags.</span>
     <span class="s5">*</span>
     <span class="s5">* Prefer to return a `ResolvedModuleFull` so that the file type does not have to be inferred.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">ResolvedModule </span><span class="s2">{</span>
        <span class="s5">/** Path of the file the module was resolved to. */</span>
        <span class="s1">resolvedFileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** True if `resolvedFileName` comes from `node_modules`. */</span>
        <span class="s1">isExternalLibraryImport</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* ResolvedModule with an explicitly provided `extension` property.</span>
     <span class="s5">* Prefer this over `ResolvedModule`.</span>
     <span class="s5">* If changing this, remember to change `moduleResolutionIsEqualTo`.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">ResolvedModuleFull </span><span class="s3">extends </span><span class="s1">ResolvedModule </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Extension of resolvedFileName. This must match what's at the end of resolvedFileName.</span>
         <span class="s5">* This is optional for backwards-compatibility, but will be added if not provided.</span>
         <span class="s5">*/</span>
        <span class="s1">extension</span><span class="s2">: </span><span class="s1">Extension</span><span class="s2">;</span>
        <span class="s1">packageId</span><span class="s2">?: </span><span class="s1">PackageId</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Unique identifier with a package name and version.</span>
     <span class="s5">* If changing this, remember to change `packageIdIsEqual`.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">PackageId </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Name of the package.</span>
         <span class="s5">* Should not include `@types`.</span>
         <span class="s5">* If accessing a non-index file, this should include its name e.g. &quot;foo/bar&quot;.</span>
         <span class="s5">*/</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Name of a submodule within this package.</span>
         <span class="s5">* May be &quot;&quot;.</span>
         <span class="s5">*/</span>
        <span class="s1">subModuleName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** Version of the package, e.g. &quot;1.2.3&quot; */</span>
        <span class="s1">version</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">Extension </span><span class="s2">{</span>
        <span class="s1">Ts </span><span class="s2">= </span><span class="s4">&quot;.ts&quot;</span><span class="s2">,</span>
        <span class="s1">Tsx </span><span class="s2">= </span><span class="s4">&quot;.tsx&quot;</span><span class="s2">,</span>
        <span class="s1">Dts </span><span class="s2">= </span><span class="s4">&quot;.d.ts&quot;</span><span class="s2">,</span>
        <span class="s1">Js </span><span class="s2">= </span><span class="s4">&quot;.js&quot;</span><span class="s2">,</span>
        <span class="s1">Jsx </span><span class="s2">= </span><span class="s4">&quot;.jsx&quot;</span><span class="s2">,</span>
        <span class="s1">Json </span><span class="s2">= </span><span class="s4">&quot;.json&quot;</span><span class="s2">,</span>
        <span class="s1">TsBuildInfo </span><span class="s2">= </span><span class="s4">&quot;.tsbuildinfo&quot;</span><span class="s2">,</span>
        <span class="s1">Mjs </span><span class="s2">= </span><span class="s4">&quot;.mjs&quot;</span><span class="s2">,</span>
        <span class="s1">Mts </span><span class="s2">= </span><span class="s4">&quot;.mts&quot;</span><span class="s2">,</span>
        <span class="s1">Dmts </span><span class="s2">= </span><span class="s4">&quot;.d.mts&quot;</span><span class="s2">,</span>
        <span class="s1">Cjs </span><span class="s2">= </span><span class="s4">&quot;.cjs&quot;</span><span class="s2">,</span>
        <span class="s1">Cts </span><span class="s2">= </span><span class="s4">&quot;.cts&quot;</span><span class="s2">,</span>
        <span class="s1">Dcts </span><span class="s2">= </span><span class="s4">&quot;.d.cts&quot;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ResolvedModuleWithFailedLookupLocations </span><span class="s2">{</span>
        <span class="s1">readonly resolvedModule</span><span class="s2">: </span><span class="s1">ResolvedModuleFull </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ResolvedTypeReferenceDirective </span><span class="s2">{</span>
        <span class="s1">primary</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">resolvedFileName</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">packageId</span><span class="s2">?: </span><span class="s1">PackageId</span><span class="s2">;</span>
        <span class="s5">/** True if `resolvedFileName` comes from `node_modules`. */</span>
        <span class="s1">isExternalLibraryImport</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ResolvedTypeReferenceDirectiveWithFailedLookupLocations </span><span class="s2">{</span>
        <span class="s1">readonly resolvedTypeReferenceDirective</span><span class="s2">: </span><span class="s1">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">readonly failedLookupLocations</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CompilerHost </span><span class="s3">extends </span><span class="s1">ModuleResolutionHost </span><span class="s2">{</span>
        <span class="s1">getSourceFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">languageVersionOrOptions</span><span class="s2">: </span><span class="s1">ScriptTarget </span><span class="s2">| </span><span class="s1">CreateSourceFileOptions</span><span class="s2">, </span><span class="s1">onError</span><span class="s2">?: (</span><span class="s1">message</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">, </span><span class="s1">shouldCreateNewSourceFile</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSourceFileByPath</span><span class="s2">?(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">languageVersionOrOptions</span><span class="s2">: </span><span class="s1">ScriptTarget </span><span class="s2">| </span><span class="s1">CreateSourceFileOptions</span><span class="s2">, </span><span class="s1">onError</span><span class="s2">?: (</span><span class="s1">message</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">, </span><span class="s1">shouldCreateNewSourceFile</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getCancellationToken</span><span class="s2">?(): </span><span class="s1">CancellationToken</span><span class="s2">;</span>
        <span class="s1">getDefaultLibFileName</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getDefaultLibLocation</span><span class="s2">?(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">writeFile</span><span class="s2">: </span><span class="s1">WriteFileCallback</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getCanonicalFileName</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getNewLine</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readDirectory</span><span class="s2">?(</span><span class="s1">rootDir</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">extensions</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">excludes</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">includes</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">depth</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">resolveModuleNames</span><span class="s2">?(</span><span class="s1">moduleNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[], </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">reusedNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">: </span><span class="s1">ResolvedProjectReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">containingSourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): (</span><span class="s1">ResolvedModule </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it</span>
         <span class="s5">*/</span>
        <span class="s1">getModuleResolutionCache</span><span class="s2">?(): </span><span class="s1">ModuleResolutionCache </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* This method is a companion for 'resolveModuleNames' and is used to resolve 'types' references to actual type declaration files</span>
         <span class="s5">*/</span>
        <span class="s1">resolveTypeReferenceDirectives</span><span class="s2">?(</span><span class="s1">typeReferenceDirectiveNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[] | </span><span class="s1">readonly FileReference</span><span class="s2">[], </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">: </span><span class="s1">ResolvedProjectReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">containingFileMode</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">] | </span><span class="s1">undefined</span><span class="s2">): (</span><span class="s1">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[];</span>
        <span class="s1">getEnvironmentVariable</span><span class="s2">?(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */</span>
        <span class="s1">hasInvalidatedResolutions</span><span class="s2">?(</span><span class="s1">filePath</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">createHash</span><span class="s2">?(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getParsedCommandLine</span><span class="s2">?(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ParsedCommandLine </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SourceMapRange </span><span class="s3">extends </span><span class="s1">TextRange </span><span class="s2">{</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s1">SourceMapSource</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SourceMapSource </span><span class="s2">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">skipTrivia</span><span class="s2">?: (</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">) =&gt; </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">EmitFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">SingleLine </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">AdviseOnEmitNode </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">NoSubstitution </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">CapturesThis </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">NoLeadingSourceMap </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">NoTrailingSourceMap </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">NoSourceMap </span><span class="s2">= </span><span class="s6">48</span><span class="s2">,</span>
        <span class="s1">NoNestedSourceMaps </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">NoTokenLeadingSourceMaps </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">NoTokenTrailingSourceMaps </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">NoTokenSourceMaps </span><span class="s2">= </span><span class="s6">384</span><span class="s2">,</span>
        <span class="s1">NoLeadingComments </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">NoTrailingComments </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">NoComments </span><span class="s2">= </span><span class="s6">1536</span><span class="s2">,</span>
        <span class="s1">NoNestedComments </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">HelperName </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">ExportName </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">LocalName </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">InternalName </span><span class="s2">= </span><span class="s6">32768</span><span class="s2">,</span>
        <span class="s1">Indented </span><span class="s2">= </span><span class="s6">65536</span><span class="s2">,</span>
        <span class="s1">NoIndentation </span><span class="s2">= </span><span class="s6">131072</span><span class="s2">,</span>
        <span class="s1">AsyncFunctionBody </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">ReuseTempVariableScope </span><span class="s2">= </span><span class="s6">524288</span><span class="s2">,</span>
        <span class="s1">CustomPrologue </span><span class="s2">= </span><span class="s6">1048576</span><span class="s2">,</span>
        <span class="s1">NoHoisting </span><span class="s2">= </span><span class="s6">2097152</span><span class="s2">,</span>
        <span class="s1">HasEndOfDeclarationMarker </span><span class="s2">= </span><span class="s6">4194304</span><span class="s2">,</span>
        <span class="s1">Iterator </span><span class="s2">= </span><span class="s6">8388608</span><span class="s2">,</span>
        <span class="s1">NoAsciiEscaping </span><span class="s2">= </span><span class="s6">16777216</span><span class="s2">,</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">EmitHelperBase </span><span class="s2">{</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly scoped</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| ((</span><span class="s1">node</span><span class="s2">: </span><span class="s1">EmitHelperUniqueNameCallback</span><span class="s2">) =&gt; </span><span class="s1">string</span><span class="s2">);</span>
        <span class="s1">readonly priority</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">readonly dependencies</span><span class="s2">?: </span><span class="s1">EmitHelper</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ScopedEmitHelper </span><span class="s3">extends </span><span class="s1">EmitHelperBase </span><span class="s2">{</span>
        <span class="s1">readonly scoped</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UnscopedEmitHelper </span><span class="s3">extends </span><span class="s1">EmitHelperBase </span><span class="s2">{</span>
        <span class="s1">readonly scoped</span><span class="s2">: </span><span class="s3">false</span><span class="s2">;</span>
        <span class="s1">readonly text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type EmitHelper </span><span class="s2">= </span><span class="s1">ScopedEmitHelper </span><span class="s2">| </span><span class="s1">UnscopedEmitHelper</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type EmitHelperUniqueNameCallback </span><span class="s2">= (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">export enum </span><span class="s1">EmitHint </span><span class="s2">{</span>
        <span class="s1">SourceFile </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Expression </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">IdentifierName </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">MappedTypeParameter </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">Unspecified </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">EmbeddedStatement </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">JsxAttributeValue </span><span class="s2">= </span><span class="s6">6</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">OuterExpressionKinds </span><span class="s2">{</span>
        <span class="s1">Parentheses </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">TypeAssertions </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">NonNullAssertions </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">PartiallyEmittedExpressions </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">Assertions </span><span class="s2">= </span><span class="s6">6</span><span class="s2">,</span>
        <span class="s1">All </span><span class="s2">= </span><span class="s6">15</span><span class="s2">,</span>
        <span class="s1">ExcludeJSDocTypeAssertion </span><span class="s2">= </span><span class="s6">16</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type TypeOfTag </span><span class="s2">= </span><span class="s4">&quot;undefined&quot; </span><span class="s2">| </span><span class="s4">&quot;number&quot; </span><span class="s2">| </span><span class="s4">&quot;bigint&quot; </span><span class="s2">| </span><span class="s4">&quot;boolean&quot; </span><span class="s2">| </span><span class="s4">&quot;string&quot; </span><span class="s2">| </span><span class="s4">&quot;symbol&quot; </span><span class="s2">| </span><span class="s4">&quot;object&quot; </span><span class="s2">| </span><span class="s4">&quot;function&quot;</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">NodeFactory </span><span class="s2">{</span>
        <span class="s1">createNodeArray</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">elements</span><span class="s2">?: </span><span class="s1">readonly T</span><span class="s2">[], </span><span class="s1">hasTrailingComma</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
        <span class="s1">createNumericLiteral</span><span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s2">, </span><span class="s1">numericLiteralFlags</span><span class="s2">?: </span><span class="s1">TokenFlags</span><span class="s2">): </span><span class="s1">NumericLiteral</span><span class="s2">;</span>
        <span class="s1">createBigIntLiteral</span><span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PseudoBigInt</span><span class="s2">): </span><span class="s1">BigIntLiteral</span><span class="s2">;</span>
        <span class="s1">createStringLiteral</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">isSingleQuote</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">StringLiteral</span><span class="s2">;</span>
        <span class="s1">createStringLiteralFromNode</span><span class="s2">(</span><span class="s1">sourceNode</span><span class="s2">: </span><span class="s1">PropertyNameLiteral </span><span class="s2">| </span><span class="s1">PrivateIdentifier</span><span class="s2">, </span><span class="s1">isSingleQuote</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">StringLiteral</span><span class="s2">;</span>
        <span class="s1">createRegularExpressionLiteral</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">RegularExpressionLiteral</span><span class="s2">;</span>
        <span class="s1">createIdentifier</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Create a unique temporary variable.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">recordTempVariable An optional callback used to record the temporary variable name. This</span>
         <span class="s5">* should usually be a reference to `hoistVariableDeclaration` from a `TransformationContext`, but</span>
         <span class="s5">* can be `undefined` if you plan to record the temporary variable manually.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes</span>
         <span class="s5">* during emit so that the variable can be referenced in a nested function body. This is an alternative to</span>
         <span class="s5">* setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.</span>
         <span class="s5">*/</span>
        <span class="s1">createTempVariable</span><span class="s2">(</span><span class="s1">recordTempVariable</span><span class="s2">: ((</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">) | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">reservedInNestedScopes</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Create a unique temporary variable for use in a loop.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">reservedInNestedScopes When `true`, reserves the temporary variable name in all nested scopes</span>
         <span class="s5">* during emit so that the variable can be referenced in a nested function body. This is an alternative to</span>
         <span class="s5">* setting `EmitFlags.ReuseTempVariableScope` on the nested function itself.</span>
         <span class="s5">*/</span>
        <span class="s1">createLoopVariable</span><span class="s2">(</span><span class="s1">reservedInNestedScopes</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s5">/** Create a unique name based on the supplied text. */</span>
        <span class="s1">createUniqueName</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">GeneratedIdentifierFlags</span><span class="s2">): </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s5">/** Create a unique name generated for a node. */</span>
        <span class="s1">getGeneratedNameForNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">GeneratedIdentifierFlags</span><span class="s2">): </span><span class="s1">Identifier</span><span class="s2">;</span>
        <span class="s1">createPrivateIdentifier</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">PrivateIdentifier</span><span class="s2">;</span>
        <span class="s1">createUniquePrivateName</span><span class="s2">(</span><span class="s1">text</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">PrivateIdentifier</span><span class="s2">;</span>
        <span class="s1">getGeneratedPrivateNameForNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">PrivateIdentifier</span><span class="s2">;</span>
        <span class="s1">createToken</span><span class="s2">(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SuperKeyword</span><span class="s2">): </span><span class="s1">SuperExpression</span><span class="s2">;</span>
        <span class="s1">createToken</span><span class="s2">(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ThisKeyword</span><span class="s2">): </span><span class="s1">ThisExpression</span><span class="s2">;</span>
        <span class="s1">createToken</span><span class="s2">(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NullKeyword</span><span class="s2">): </span><span class="s1">NullLiteral</span><span class="s2">;</span>
        <span class="s1">createToken</span><span class="s2">(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">TrueKeyword</span><span class="s2">): </span><span class="s1">TrueLiteral</span><span class="s2">;</span>
        <span class="s1">createToken</span><span class="s2">(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">FalseKeyword</span><span class="s2">): </span><span class="s1">FalseLiteral</span><span class="s2">;</span>
        <span class="s1">createToken</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">PunctuationSyntaxKind</span><span class="s2">&gt;(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">): </span><span class="s1">PunctuationToken</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;;</span>
        <span class="s1">createToken</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">KeywordTypeSyntaxKind</span><span class="s2">&gt;(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">): </span><span class="s1">KeywordTypeNode</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;;</span>
        <span class="s1">createToken</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">ModifierSyntaxKind</span><span class="s2">&gt;(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">): </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;;</span>
        <span class="s1">createToken</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">KeywordSyntaxKind</span><span class="s2">&gt;(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">): </span><span class="s1">KeywordToken</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;;</span>
        <span class="s1">createToken</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">Unknown </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">EndOfFileToken</span><span class="s2">&gt;(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">): </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;;</span>
        <span class="s1">createSuper</span><span class="s2">(): </span><span class="s1">SuperExpression</span><span class="s2">;</span>
        <span class="s1">createThis</span><span class="s2">(): </span><span class="s1">ThisExpression</span><span class="s2">;</span>
        <span class="s1">createNull</span><span class="s2">(): </span><span class="s1">NullLiteral</span><span class="s2">;</span>
        <span class="s1">createTrue</span><span class="s2">(): </span><span class="s1">TrueLiteral</span><span class="s2">;</span>
        <span class="s1">createFalse</span><span class="s2">(): </span><span class="s1">FalseLiteral</span><span class="s2">;</span>
        <span class="s1">createModifier</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">ModifierSyntaxKind</span><span class="s2">&gt;(</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
        <span class="s1">createModifiersFromModifierFlags</span><span class="s2">(</span><span class="s1">flags</span><span class="s2">: </span><span class="s1">ModifierFlags</span><span class="s2">): </span><span class="s1">Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">createQualifiedName</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">QualifiedName</span><span class="s2">;</span>
        <span class="s1">updateQualifiedName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">QualifiedName</span><span class="s2">, </span><span class="s1">left</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">QualifiedName</span><span class="s2">;</span>
        <span class="s1">createComputedPropertyName</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ComputedPropertyName</span><span class="s2">;</span>
        <span class="s1">updateComputedPropertyName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ComputedPropertyName</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ComputedPropertyName</span><span class="s2">;</span>
        <span class="s1">createTypeParameterDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">defaultType</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
        <span class="s1">updateTypeParameterDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">defaultType</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
        <span class="s1">createParameterDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken</span><span class="s2">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
        <span class="s1">updateParameterDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
        <span class="s1">createDecorator</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">Decorator</span><span class="s2">;</span>
        <span class="s1">updateDecorator</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Decorator</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">Decorator</span><span class="s2">;</span>
        <span class="s1">createPropertySignature</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName </span><span class="s2">| </span><span class="s1">string</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertySignature</span><span class="s2">;</span>
        <span class="s1">updatePropertySignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertySignature</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertySignature</span><span class="s2">;</span>
        <span class="s1">createPropertyDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionOrExclamationToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
        <span class="s1">updatePropertyDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionOrExclamationToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
        <span class="s1">createMethodSignature</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodSignature</span><span class="s2">;</span>
        <span class="s1">updateMethodSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MethodSignature</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodSignature</span><span class="s2">;</span>
        <span class="s1">createMethodDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
        <span class="s1">updateMethodDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MethodDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
        <span class="s1">createConstructorDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
        <span class="s1">updateConstructorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructorDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
        <span class="s1">createGetAccessorDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s1">updateGetAccessorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">GetAccessorDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s1">createSetAccessorDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s1">updateSetAccessorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SetAccessorDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s1">createCallSignature</span><span class="s2">(</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">CallSignatureDeclaration</span><span class="s2">;</span>
        <span class="s1">updateCallSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CallSignatureDeclaration</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">CallSignatureDeclaration</span><span class="s2">;</span>
        <span class="s1">createConstructSignature</span><span class="s2">(</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructSignatureDeclaration</span><span class="s2">;</span>
        <span class="s1">updateConstructSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructSignatureDeclaration</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructSignatureDeclaration</span><span class="s2">;</span>
        <span class="s1">createIndexSignature</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
        <span class="s1">updateIndexSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
        <span class="s1">createTemplateLiteralTypeSpan</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">literal</span><span class="s2">: </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">): </span><span class="s1">TemplateLiteralTypeSpan</span><span class="s2">;</span>
        <span class="s1">updateTemplateLiteralTypeSpan</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TemplateLiteralTypeSpan</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">literal</span><span class="s2">: </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">): </span><span class="s1">TemplateLiteralTypeSpan</span><span class="s2">;</span>
        <span class="s1">createClassStaticBlockDeclaration</span><span class="s2">(</span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">): </span><span class="s1">ClassStaticBlockDeclaration</span><span class="s2">;</span>
        <span class="s1">updateClassStaticBlockDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassStaticBlockDeclaration</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">): </span><span class="s1">ClassStaticBlockDeclaration</span><span class="s2">;</span>
        <span class="s1">createKeywordTypeNode</span><span class="s2">&lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">KeywordTypeSyntaxKind</span><span class="s2">&gt;(</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">): </span><span class="s1">KeywordTypeNode</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;;</span>
        <span class="s1">createTypePredicateNode</span><span class="s2">(</span><span class="s1">assertsModifier</span><span class="s2">: </span><span class="s1">AssertsKeyword </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameterName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">ThisTypeNode </span><span class="s2">| </span><span class="s1">string</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypePredicateNode</span><span class="s2">;</span>
        <span class="s1">updateTypePredicateNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypePredicateNode</span><span class="s2">, </span><span class="s1">assertsModifier</span><span class="s2">: </span><span class="s1">AssertsKeyword </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameterName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">ThisTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypePredicateNode</span><span class="s2">;</span>
        <span class="s1">createTypeReferenceNode</span><span class="s2">(</span><span class="s1">typeName</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[]): </span><span class="s1">TypeReferenceNode</span><span class="s2">;</span>
        <span class="s1">updateTypeReferenceNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeReferenceNode</span><span class="s2">, </span><span class="s1">typeName</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeReferenceNode</span><span class="s2">;</span>
        <span class="s1">createFunctionTypeNode</span><span class="s2">(</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">FunctionTypeNode</span><span class="s2">;</span>
        <span class="s1">updateFunctionTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionTypeNode</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">FunctionTypeNode</span><span class="s2">;</span>
        <span class="s1">createConstructorTypeNode</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
        <span class="s1">updateConstructorTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructorTypeNode</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
        <span class="s1">createTypeQueryNode</span><span class="s2">(</span><span class="s1">exprName</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[]): </span><span class="s1">TypeQueryNode</span><span class="s2">;</span>
        <span class="s1">updateTypeQueryNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeQueryNode</span><span class="s2">, </span><span class="s1">exprName</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[]): </span><span class="s1">TypeQueryNode</span><span class="s2">;</span>
        <span class="s1">createTypeLiteralNode</span><span class="s2">(</span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeLiteralNode</span><span class="s2">;</span>
        <span class="s1">updateTypeLiteralNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeLiteralNode</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt;): </span><span class="s1">TypeLiteralNode</span><span class="s2">;</span>
        <span class="s1">createArrayTypeNode</span><span class="s2">(</span><span class="s1">elementType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ArrayTypeNode</span><span class="s2">;</span>
        <span class="s1">updateArrayTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrayTypeNode</span><span class="s2">, </span><span class="s1">elementType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ArrayTypeNode</span><span class="s2">;</span>
        <span class="s1">createTupleTypeNode</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">NamedTupleMember</span><span class="s2">)[]): </span><span class="s1">TupleTypeNode</span><span class="s2">;</span>
        <span class="s1">updateTupleTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TupleTypeNode</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">NamedTupleMember</span><span class="s2">)[]): </span><span class="s1">TupleTypeNode</span><span class="s2">;</span>
        <span class="s1">createNamedTupleMember</span><span class="s2">(</span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">NamedTupleMember</span><span class="s2">;</span>
        <span class="s1">updateNamedTupleMember</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamedTupleMember</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">NamedTupleMember</span><span class="s2">;</span>
        <span class="s1">createOptionalTypeNode</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">OptionalTypeNode</span><span class="s2">;</span>
        <span class="s1">updateOptionalTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">OptionalTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">OptionalTypeNode</span><span class="s2">;</span>
        <span class="s1">createRestTypeNode</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">RestTypeNode</span><span class="s2">;</span>
        <span class="s1">updateRestTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">RestTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">RestTypeNode</span><span class="s2">;</span>
        <span class="s1">createUnionTypeNode</span><span class="s2">(</span><span class="s1">types</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[]): </span><span class="s1">UnionTypeNode</span><span class="s2">;</span>
        <span class="s1">updateUnionTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">UnionTypeNode</span><span class="s2">, </span><span class="s1">types</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;): </span><span class="s1">UnionTypeNode</span><span class="s2">;</span>
        <span class="s1">createIntersectionTypeNode</span><span class="s2">(</span><span class="s1">types</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[]): </span><span class="s1">IntersectionTypeNode</span><span class="s2">;</span>
        <span class="s1">updateIntersectionTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IntersectionTypeNode</span><span class="s2">, </span><span class="s1">types</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;): </span><span class="s1">IntersectionTypeNode</span><span class="s2">;</span>
        <span class="s1">createConditionalTypeNode</span><span class="s2">(</span><span class="s1">checkType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">extendsType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">trueType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">falseType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ConditionalTypeNode</span><span class="s2">;</span>
        <span class="s1">updateConditionalTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConditionalTypeNode</span><span class="s2">, </span><span class="s1">checkType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">extendsType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">trueType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">falseType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ConditionalTypeNode</span><span class="s2">;</span>
        <span class="s1">createInferTypeNode</span><span class="s2">(</span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">): </span><span class="s1">InferTypeNode</span><span class="s2">;</span>
        <span class="s1">updateInferTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">InferTypeNode</span><span class="s2">, </span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">): </span><span class="s1">InferTypeNode</span><span class="s2">;</span>
        <span class="s1">createImportTypeNode</span><span class="s2">(</span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">?: </span><span class="s1">ImportTypeAssertionContainer</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">?: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[], </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
        <span class="s1">updateImportTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportTypeNode</span><span class="s2">, </span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">: </span><span class="s1">ImportTypeAssertionContainer </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
        <span class="s1">createParenthesizedType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ParenthesizedTypeNode</span><span class="s2">;</span>
        <span class="s1">updateParenthesizedType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParenthesizedTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ParenthesizedTypeNode</span><span class="s2">;</span>
        <span class="s1">createThisTypeNode</span><span class="s2">(): </span><span class="s1">ThisTypeNode</span><span class="s2">;</span>
        <span class="s1">createTypeOperatorNode</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">KeyOfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UniqueKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ReadonlyKeyword</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeOperatorNode</span><span class="s2">;</span>
        <span class="s1">updateTypeOperatorNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeOperatorNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeOperatorNode</span><span class="s2">;</span>
        <span class="s1">createIndexedAccessTypeNode</span><span class="s2">(</span><span class="s1">objectType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">indexType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">IndexedAccessTypeNode</span><span class="s2">;</span>
        <span class="s1">updateIndexedAccessTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IndexedAccessTypeNode</span><span class="s2">, </span><span class="s1">objectType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">indexType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">IndexedAccessTypeNode</span><span class="s2">;</span>
        <span class="s1">createMappedTypeNode</span><span class="s2">(</span><span class="s1">readonlyToken</span><span class="s2">: </span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">, </span><span class="s1">nameType</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MappedTypeNode</span><span class="s2">;</span>
        <span class="s1">updateMappedTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MappedTypeNode</span><span class="s2">, </span><span class="s1">readonlyToken</span><span class="s2">: </span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">, </span><span class="s1">nameType</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MappedTypeNode</span><span class="s2">;</span>
        <span class="s1">createLiteralTypeNode</span><span class="s2">(</span><span class="s1">literal</span><span class="s2">: </span><span class="s1">LiteralTypeNode</span><span class="s2">[</span><span class="s4">&quot;literal&quot;</span><span class="s2">]): </span><span class="s1">LiteralTypeNode</span><span class="s2">;</span>
        <span class="s1">updateLiteralTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">LiteralTypeNode</span><span class="s2">, </span><span class="s1">literal</span><span class="s2">: </span><span class="s1">LiteralTypeNode</span><span class="s2">[</span><span class="s4">&quot;literal&quot;</span><span class="s2">]): </span><span class="s1">LiteralTypeNode</span><span class="s2">;</span>
        <span class="s1">createTemplateLiteralType</span><span class="s2">(</span><span class="s1">head</span><span class="s2">: </span><span class="s1">TemplateHead</span><span class="s2">, </span><span class="s1">templateSpans</span><span class="s2">: </span><span class="s1">readonly TemplateLiteralTypeSpan</span><span class="s2">[]): </span><span class="s1">TemplateLiteralTypeNode</span><span class="s2">;</span>
        <span class="s1">updateTemplateLiteralType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TemplateLiteralTypeNode</span><span class="s2">, </span><span class="s1">head</span><span class="s2">: </span><span class="s1">TemplateHead</span><span class="s2">, </span><span class="s1">templateSpans</span><span class="s2">: </span><span class="s1">readonly TemplateLiteralTypeSpan</span><span class="s2">[]): </span><span class="s1">TemplateLiteralTypeNode</span><span class="s2">;</span>
        <span class="s1">createObjectBindingPattern</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly BindingElement</span><span class="s2">[]): </span><span class="s1">ObjectBindingPattern</span><span class="s2">;</span>
        <span class="s1">updateObjectBindingPattern</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ObjectBindingPattern</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly BindingElement</span><span class="s2">[]): </span><span class="s1">ObjectBindingPattern</span><span class="s2">;</span>
        <span class="s1">createArrayBindingPattern</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ArrayBindingElement</span><span class="s2">[]): </span><span class="s1">ArrayBindingPattern</span><span class="s2">;</span>
        <span class="s1">updateArrayBindingPattern</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrayBindingPattern</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ArrayBindingElement</span><span class="s2">[]): </span><span class="s1">ArrayBindingPattern</span><span class="s2">;</span>
        <span class="s1">createBindingElement</span><span class="s2">(</span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BindingElement</span><span class="s2">;</span>
        <span class="s1">updateBindingElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">BindingElement</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">PropertyName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">BindingElement</span><span class="s2">;</span>
        <span class="s1">createArrayLiteralExpression</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">?: </span><span class="s1">readonly Expression</span><span class="s2">[], </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
        <span class="s1">updateArrayLiteralExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrayLiteralExpression</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]): </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
        <span class="s1">createObjectLiteralExpression</span><span class="s2">(</span><span class="s1">properties</span><span class="s2">?: </span><span class="s1">readonly ObjectLiteralElementLike</span><span class="s2">[], </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
        <span class="s1">updateObjectLiteralExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ObjectLiteralExpression</span><span class="s2">, </span><span class="s1">properties</span><span class="s2">: </span><span class="s1">readonly ObjectLiteralElementLike</span><span class="s2">[]): </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
        <span class="s1">createPropertyAccessExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">MemberName</span><span class="s2">): </span><span class="s1">PropertyAccessExpression</span><span class="s2">;</span>
        <span class="s1">updatePropertyAccessExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyAccessExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">MemberName</span><span class="s2">): </span><span class="s1">PropertyAccessExpression</span><span class="s2">;</span>
        <span class="s1">createPropertyAccessChain</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">MemberName</span><span class="s2">): </span><span class="s1">PropertyAccessChain</span><span class="s2">;</span>
        <span class="s1">updatePropertyAccessChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyAccessChain</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">MemberName</span><span class="s2">): </span><span class="s1">PropertyAccessChain</span><span class="s2">;</span>
        <span class="s1">createElementAccessExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ElementAccessExpression</span><span class="s2">;</span>
        <span class="s1">updateElementAccessExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ElementAccessExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">argumentExpression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ElementAccessExpression</span><span class="s2">;</span>
        <span class="s1">createElementAccessChain</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ElementAccessChain</span><span class="s2">;</span>
        <span class="s1">updateElementAccessChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ElementAccessChain</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentExpression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ElementAccessChain</span><span class="s2">;</span>
        <span class="s1">createCallExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s1">updateCallExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CallExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]): </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s1">createCallChain</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">CallChain</span><span class="s2">;</span>
        <span class="s1">updateCallChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CallChain</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]): </span><span class="s1">CallChain</span><span class="s2">;</span>
        <span class="s1">createNewExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">NewExpression</span><span class="s2">;</span>
        <span class="s1">updateNewExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NewExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">NewExpression</span><span class="s2">;</span>
        <span class="s1">createTaggedTemplateExpression</span><span class="s2">(</span><span class="s1">tag</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">template</span><span class="s2">: </span><span class="s1">TemplateLiteral</span><span class="s2">): </span><span class="s1">TaggedTemplateExpression</span><span class="s2">;</span>
        <span class="s1">updateTaggedTemplateExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TaggedTemplateExpression</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">template</span><span class="s2">: </span><span class="s1">TemplateLiteral</span><span class="s2">): </span><span class="s1">TaggedTemplateExpression</span><span class="s2">;</span>
        <span class="s1">createTypeAssertion</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">TypeAssertion</span><span class="s2">;</span>
        <span class="s1">updateTypeAssertion</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeAssertion</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">TypeAssertion</span><span class="s2">;</span>
        <span class="s1">createParenthesizedExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ParenthesizedExpression</span><span class="s2">;</span>
        <span class="s1">updateParenthesizedExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParenthesizedExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ParenthesizedExpression</span><span class="s2">;</span>
        <span class="s1">createFunctionExpression</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">): </span><span class="s1">FunctionExpression</span><span class="s2">;</span>
        <span class="s1">updateFunctionExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionExpression</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">): </span><span class="s1">FunctionExpression</span><span class="s2">;</span>
        <span class="s1">createArrowFunction</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">equalsGreaterThanToken</span><span class="s2">: </span><span class="s1">EqualsGreaterThanToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ConciseBody</span><span class="s2">): </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
        <span class="s1">updateArrowFunction</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrowFunction</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">equalsGreaterThanToken</span><span class="s2">: </span><span class="s1">EqualsGreaterThanToken</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ConciseBody</span><span class="s2">): </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
        <span class="s1">createDeleteExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">DeleteExpression</span><span class="s2">;</span>
        <span class="s1">updateDeleteExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">DeleteExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">DeleteExpression</span><span class="s2">;</span>
        <span class="s1">createTypeOfExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">TypeOfExpression</span><span class="s2">;</span>
        <span class="s1">updateTypeOfExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeOfExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">TypeOfExpression</span><span class="s2">;</span>
        <span class="s1">createVoidExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">VoidExpression</span><span class="s2">;</span>
        <span class="s1">updateVoidExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VoidExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">VoidExpression</span><span class="s2">;</span>
        <span class="s1">createAwaitExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">AwaitExpression</span><span class="s2">;</span>
        <span class="s1">updateAwaitExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">AwaitExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">AwaitExpression</span><span class="s2">;</span>
        <span class="s1">createPrefixUnaryExpression</span><span class="s2">(</span><span class="s1">operator</span><span class="s2">: </span><span class="s1">PrefixUnaryOperator</span><span class="s2">, </span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">updatePrefixUnaryExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PrefixUnaryExpression</span><span class="s2">, </span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createPostfixUnaryExpression</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">: </span><span class="s1">PostfixUnaryOperator</span><span class="s2">): </span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">updatePostfixUnaryExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PostfixUnaryExpression</span><span class="s2">, </span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createBinaryExpression</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">: </span><span class="s1">BinaryOperator </span><span class="s2">| </span><span class="s1">BinaryOperatorToken</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">updateBinaryExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">BinaryExpression</span><span class="s2">, </span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">: </span><span class="s1">BinaryOperator </span><span class="s2">| </span><span class="s1">BinaryOperatorToken</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createConditionalExpression</span><span class="s2">(</span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">whenTrue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">colonToken</span><span class="s2">: </span><span class="s1">ColonToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">whenFalse</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ConditionalExpression</span><span class="s2">;</span>
        <span class="s1">updateConditionalExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConditionalExpression</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken</span><span class="s2">, </span><span class="s1">whenTrue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">colonToken</span><span class="s2">: </span><span class="s1">ColonToken</span><span class="s2">, </span><span class="s1">whenFalse</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ConditionalExpression</span><span class="s2">;</span>
        <span class="s1">createTemplateExpression</span><span class="s2">(</span><span class="s1">head</span><span class="s2">: </span><span class="s1">TemplateHead</span><span class="s2">, </span><span class="s1">templateSpans</span><span class="s2">: </span><span class="s1">readonly TemplateSpan</span><span class="s2">[]): </span><span class="s1">TemplateExpression</span><span class="s2">;</span>
        <span class="s1">updateTemplateExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TemplateExpression</span><span class="s2">, </span><span class="s1">head</span><span class="s2">: </span><span class="s1">TemplateHead</span><span class="s2">, </span><span class="s1">templateSpans</span><span class="s2">: </span><span class="s1">readonly TemplateSpan</span><span class="s2">[]): </span><span class="s1">TemplateExpression</span><span class="s2">;</span>
        <span class="s1">createTemplateHead</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags</span><span class="s2">): </span><span class="s1">TemplateHead</span><span class="s2">;</span>
        <span class="s1">createTemplateHead</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags</span><span class="s2">): </span><span class="s1">TemplateHead</span><span class="s2">;</span>
        <span class="s1">createTemplateMiddle</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags</span><span class="s2">): </span><span class="s1">TemplateMiddle</span><span class="s2">;</span>
        <span class="s1">createTemplateMiddle</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags</span><span class="s2">): </span><span class="s1">TemplateMiddle</span><span class="s2">;</span>
        <span class="s1">createTemplateTail</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags</span><span class="s2">): </span><span class="s1">TemplateTail</span><span class="s2">;</span>
        <span class="s1">createTemplateTail</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags</span><span class="s2">): </span><span class="s1">TemplateTail</span><span class="s2">;</span>
        <span class="s1">createNoSubstitutionTemplateLiteral</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
        <span class="s1">createNoSubstitutionTemplateLiteral</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
        <span class="s1">createYieldExpression</span><span class="s2">(</span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">YieldExpression</span><span class="s2">;</span>
        <span class="s1">createYieldExpression</span><span class="s2">(</span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">YieldExpression</span><span class="s2">;</span>
        <span class="s1">updateYieldExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">YieldExpression</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">YieldExpression</span><span class="s2">;</span>
        <span class="s1">createSpreadElement</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">SpreadElement</span><span class="s2">;</span>
        <span class="s1">updateSpreadElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SpreadElement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">SpreadElement</span><span class="s2">;</span>
        <span class="s1">createClassExpression</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassExpression</span><span class="s2">;</span>
        <span class="s1">updateClassExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassExpression</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassExpression</span><span class="s2">;</span>
        <span class="s1">createOmittedExpression</span><span class="s2">(): </span><span class="s1">OmittedExpression</span><span class="s2">;</span>
        <span class="s1">createExpressionWithTypeArguments</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">;</span>
        <span class="s1">updateExpressionWithTypeArguments</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">;</span>
        <span class="s1">createAsExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">AsExpression</span><span class="s2">;</span>
        <span class="s1">updateAsExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">AsExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">AsExpression</span><span class="s2">;</span>
        <span class="s1">createNonNullExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">NonNullExpression</span><span class="s2">;</span>
        <span class="s1">updateNonNullExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NonNullExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">NonNullExpression</span><span class="s2">;</span>
        <span class="s1">createNonNullChain</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">NonNullChain</span><span class="s2">;</span>
        <span class="s1">updateNonNullChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NonNullChain</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">NonNullChain</span><span class="s2">;</span>
        <span class="s1">createMetaProperty</span><span class="s2">(</span><span class="s1">keywordToken</span><span class="s2">: </span><span class="s1">MetaProperty</span><span class="s2">[</span><span class="s4">&quot;keywordToken&quot;</span><span class="s2">], </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">MetaProperty</span><span class="s2">;</span>
        <span class="s1">updateMetaProperty</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MetaProperty</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">MetaProperty</span><span class="s2">;</span>
        <span class="s1">createSatisfiesExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">SatisfiesExpression</span><span class="s2">;</span>
        <span class="s1">updateSatisfiesExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SatisfiesExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">SatisfiesExpression</span><span class="s2">;</span>
        <span class="s1">createTemplateSpan</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">literal</span><span class="s2">: </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">): </span><span class="s1">TemplateSpan</span><span class="s2">;</span>
        <span class="s1">updateTemplateSpan</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TemplateSpan</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">literal</span><span class="s2">: </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">): </span><span class="s1">TemplateSpan</span><span class="s2">;</span>
        <span class="s1">createSemicolonClassElement</span><span class="s2">(): </span><span class="s1">SemicolonClassElement</span><span class="s2">;</span>
        <span class="s1">createBlock</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">Block</span><span class="s2">;</span>
        <span class="s1">updateBlock</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">Block</span><span class="s2">;</span>
        <span class="s1">createVariableStatement</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">declarationList</span><span class="s2">: </span><span class="s1">VariableDeclarationList </span><span class="s2">| </span><span class="s1">readonly VariableDeclaration</span><span class="s2">[]): </span><span class="s1">VariableStatement</span><span class="s2">;</span>
        <span class="s1">updateVariableStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VariableStatement</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">declarationList</span><span class="s2">: </span><span class="s1">VariableDeclarationList</span><span class="s2">): </span><span class="s1">VariableStatement</span><span class="s2">;</span>
        <span class="s1">createEmptyStatement</span><span class="s2">(): </span><span class="s1">EmptyStatement</span><span class="s2">;</span>
        <span class="s1">createExpressionStatement</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExpressionStatement</span><span class="s2">;</span>
        <span class="s1">updateExpressionStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExpressionStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExpressionStatement</span><span class="s2">;</span>
        <span class="s1">createIfStatement</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">thenStatement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">elseStatement</span><span class="s2">?: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">IfStatement</span><span class="s2">;</span>
        <span class="s1">updateIfStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IfStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">thenStatement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">elseStatement</span><span class="s2">: </span><span class="s1">Statement </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">IfStatement</span><span class="s2">;</span>
        <span class="s1">createDoStatement</span><span class="s2">(</span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">DoStatement</span><span class="s2">;</span>
        <span class="s1">updateDoStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">DoStatement</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">DoStatement</span><span class="s2">;</span>
        <span class="s1">createWhileStatement</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">WhileStatement</span><span class="s2">;</span>
        <span class="s1">updateWhileStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">WhileStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">WhileStatement</span><span class="s2">;</span>
        <span class="s1">createForStatement</span><span class="s2">(</span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">incrementor</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">ForStatement</span><span class="s2">;</span>
        <span class="s1">updateForStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ForStatement</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">incrementor</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">ForStatement</span><span class="s2">;</span>
        <span class="s1">createForInStatement</span><span class="s2">(</span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">ForInStatement</span><span class="s2">;</span>
        <span class="s1">updateForInStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ForInStatement</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">ForInStatement</span><span class="s2">;</span>
        <span class="s1">createForOfStatement</span><span class="s2">(</span><span class="s1">awaitModifier</span><span class="s2">: </span><span class="s1">AwaitKeyword </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">ForOfStatement</span><span class="s2">;</span>
        <span class="s1">updateForOfStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ForOfStatement</span><span class="s2">, </span><span class="s1">awaitModifier</span><span class="s2">: </span><span class="s1">AwaitKeyword </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">ForOfStatement</span><span class="s2">;</span>
        <span class="s1">createContinueStatement</span><span class="s2">(</span><span class="s1">label</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">ContinueStatement</span><span class="s2">;</span>
        <span class="s1">updateContinueStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ContinueStatement</span><span class="s2">, </span><span class="s1">label</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ContinueStatement</span><span class="s2">;</span>
        <span class="s1">createBreakStatement</span><span class="s2">(</span><span class="s1">label</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">BreakStatement</span><span class="s2">;</span>
        <span class="s1">updateBreakStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">BreakStatement</span><span class="s2">, </span><span class="s1">label</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">BreakStatement</span><span class="s2">;</span>
        <span class="s1">createReturnStatement</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ReturnStatement</span><span class="s2">;</span>
        <span class="s1">updateReturnStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ReturnStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ReturnStatement</span><span class="s2">;</span>
        <span class="s1">createWithStatement</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">WithStatement</span><span class="s2">;</span>
        <span class="s1">updateWithStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">WithStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">WithStatement</span><span class="s2">;</span>
        <span class="s1">createSwitchStatement</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">caseBlock</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">): </span><span class="s1">SwitchStatement</span><span class="s2">;</span>
        <span class="s1">updateSwitchStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SwitchStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">caseBlock</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">): </span><span class="s1">SwitchStatement</span><span class="s2">;</span>
        <span class="s1">createLabeledStatement</span><span class="s2">(</span><span class="s1">label</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">LabeledStatement</span><span class="s2">;</span>
        <span class="s1">updateLabeledStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">LabeledStatement</span><span class="s2">, </span><span class="s1">label</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">): </span><span class="s1">LabeledStatement</span><span class="s2">;</span>
        <span class="s1">createThrowStatement</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ThrowStatement</span><span class="s2">;</span>
        <span class="s1">updateThrowStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ThrowStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ThrowStatement</span><span class="s2">;</span>
        <span class="s1">createTryStatement</span><span class="s2">(</span><span class="s1">tryBlock</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">, </span><span class="s1">catchClause</span><span class="s2">: </span><span class="s1">CatchClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">finallyBlock</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TryStatement</span><span class="s2">;</span>
        <span class="s1">updateTryStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TryStatement</span><span class="s2">, </span><span class="s1">tryBlock</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">, </span><span class="s1">catchClause</span><span class="s2">: </span><span class="s1">CatchClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">finallyBlock</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TryStatement</span><span class="s2">;</span>
        <span class="s1">createDebuggerStatement</span><span class="s2">(): </span><span class="s1">DebuggerStatement</span><span class="s2">;</span>
        <span class="s1">createVariableDeclaration</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">exclamationToken</span><span class="s2">?: </span><span class="s1">ExclamationToken</span><span class="s2">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
        <span class="s1">updateVariableDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VariableDeclaration</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">exclamationToken</span><span class="s2">: </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
        <span class="s1">createVariableDeclarationList</span><span class="s2">(</span><span class="s1">declarations</span><span class="s2">: </span><span class="s1">readonly VariableDeclaration</span><span class="s2">[], </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">NodeFlags</span><span class="s2">): </span><span class="s1">VariableDeclarationList</span><span class="s2">;</span>
        <span class="s1">updateVariableDeclarationList</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VariableDeclarationList</span><span class="s2">, </span><span class="s1">declarations</span><span class="s2">: </span><span class="s1">readonly VariableDeclaration</span><span class="s2">[]): </span><span class="s1">VariableDeclarationList</span><span class="s2">;</span>
        <span class="s1">createFunctionDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
        <span class="s1">updateFunctionDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
        <span class="s1">createClassDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
        <span class="s1">updateClassDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
        <span class="s1">createInterfaceDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[]): </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s1">updateInterfaceDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">InterfaceDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[]): </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s1">createTypeAliasDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
        <span class="s1">updateTypeAliasDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeAliasDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
        <span class="s1">createEnumDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly EnumMember</span><span class="s2">[]): </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
        <span class="s1">updateEnumDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">EnumDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly EnumMember</span><span class="s2">[]): </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
        <span class="s1">createModuleDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">NodeFlags</span><span class="s2">): </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
        <span class="s1">updateModuleDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ModuleDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
        <span class="s1">createModuleBlock</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">ModuleBlock</span><span class="s2">;</span>
        <span class="s1">updateModuleBlock</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ModuleBlock</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">ModuleBlock</span><span class="s2">;</span>
        <span class="s1">createCaseBlock</span><span class="s2">(</span><span class="s1">clauses</span><span class="s2">: </span><span class="s1">readonly CaseOrDefaultClause</span><span class="s2">[]): </span><span class="s1">CaseBlock</span><span class="s2">;</span>
        <span class="s1">updateCaseBlock</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">, </span><span class="s1">clauses</span><span class="s2">: </span><span class="s1">readonly CaseOrDefaultClause</span><span class="s2">[]): </span><span class="s1">CaseBlock</span><span class="s2">;</span>
        <span class="s1">createNamespaceExportDeclaration</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">NamespaceExportDeclaration</span><span class="s2">;</span>
        <span class="s1">updateNamespaceExportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamespaceExportDeclaration</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">NamespaceExportDeclaration</span><span class="s2">;</span>
        <span class="s1">createImportEqualsDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">): </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
        <span class="s1">updateImportEqualsDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">): </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
        <span class="s1">createImportDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">importClause</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">?: </span><span class="s1">AssertClause</span><span class="s2">): </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
        <span class="s1">updateImportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">importClause</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">: </span><span class="s1">AssertClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
        <span class="s1">createImportClause</span><span class="s2">(</span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">namedBindings</span><span class="s2">: </span><span class="s1">NamedImportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportClause</span><span class="s2">;</span>
        <span class="s1">updateImportClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportClause</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">namedBindings</span><span class="s2">: </span><span class="s1">NamedImportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportClause</span><span class="s2">;</span>
        <span class="s1">createAssertClause</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">AssertEntry</span><span class="s2">&gt;, </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">AssertClause</span><span class="s2">;</span>
        <span class="s1">updateAssertClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">AssertClause</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">AssertEntry</span><span class="s2">&gt;, </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">AssertClause</span><span class="s2">;</span>
        <span class="s1">createAssertEntry</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">AssertionKey</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">AssertEntry</span><span class="s2">;</span>
        <span class="s1">updateAssertEntry</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">AssertEntry</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">AssertionKey</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">AssertEntry</span><span class="s2">;</span>
        <span class="s1">createImportTypeAssertionContainer</span><span class="s2">(</span><span class="s1">clause</span><span class="s2">: </span><span class="s1">AssertClause</span><span class="s2">, </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ImportTypeAssertionContainer</span><span class="s2">;</span>
        <span class="s1">updateImportTypeAssertionContainer</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportTypeAssertionContainer</span><span class="s2">, </span><span class="s1">clause</span><span class="s2">: </span><span class="s1">AssertClause</span><span class="s2">, </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ImportTypeAssertionContainer</span><span class="s2">;</span>
        <span class="s1">createNamespaceImport</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">NamespaceImport</span><span class="s2">;</span>
        <span class="s1">updateNamespaceImport</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamespaceImport</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">NamespaceImport</span><span class="s2">;</span>
        <span class="s1">createNamespaceExport</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">NamespaceExport</span><span class="s2">;</span>
        <span class="s1">updateNamespaceExport</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamespaceExport</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">NamespaceExport</span><span class="s2">;</span>
        <span class="s1">createNamedImports</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ImportSpecifier</span><span class="s2">[]): </span><span class="s1">NamedImports</span><span class="s2">;</span>
        <span class="s1">updateNamedImports</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamedImports</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ImportSpecifier</span><span class="s2">[]): </span><span class="s1">NamedImports</span><span class="s2">;</span>
        <span class="s1">createImportSpecifier</span><span class="s2">(</span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">ImportSpecifier</span><span class="s2">;</span>
        <span class="s1">updateImportSpecifier</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportSpecifier</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">ImportSpecifier</span><span class="s2">;</span>
        <span class="s1">createExportAssignment</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isExportEquals</span><span class="s2">: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
        <span class="s1">updateExportAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportAssignment</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
        <span class="s1">createExportDeclaration</span><span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">exportClause</span><span class="s2">: </span><span class="s1">NamedExportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">?: </span><span class="s1">AssertClause</span><span class="s2">): </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
        <span class="s1">updateExportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">exportClause</span><span class="s2">: </span><span class="s1">NamedExportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">: </span><span class="s1">AssertClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
        <span class="s1">createNamedExports</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ExportSpecifier</span><span class="s2">[]): </span><span class="s1">NamedExports</span><span class="s2">;</span>
        <span class="s1">updateNamedExports</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamedExports</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ExportSpecifier</span><span class="s2">[]): </span><span class="s1">NamedExports</span><span class="s2">;</span>
        <span class="s1">createExportSpecifier</span><span class="s2">(</span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">ExportSpecifier</span><span class="s2">;</span>
        <span class="s1">updateExportSpecifier</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportSpecifier</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">ExportSpecifier</span><span class="s2">;</span>
        <span class="s1">createExternalModuleReference</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExternalModuleReference</span><span class="s2">;</span>
        <span class="s1">updateExternalModuleReference</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExternalModuleReference</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExternalModuleReference</span><span class="s2">;</span>
        <span class="s1">createJSDocAllType</span><span class="s2">(): </span><span class="s1">JSDocAllType</span><span class="s2">;</span>
        <span class="s1">createJSDocUnknownType</span><span class="s2">(): </span><span class="s1">JSDocUnknownType</span><span class="s2">;</span>
        <span class="s1">createJSDocNonNullableType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">postfix</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">JSDocNonNullableType</span><span class="s2">;</span>
        <span class="s1">updateJSDocNonNullableType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocNonNullableType</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocNonNullableType</span><span class="s2">;</span>
        <span class="s1">createJSDocNullableType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">postfix</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">JSDocNullableType</span><span class="s2">;</span>
        <span class="s1">updateJSDocNullableType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocNullableType</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocNullableType</span><span class="s2">;</span>
        <span class="s1">createJSDocOptionalType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocOptionalType</span><span class="s2">;</span>
        <span class="s1">updateJSDocOptionalType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocOptionalType</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocOptionalType</span><span class="s2">;</span>
        <span class="s1">createJSDocFunctionType</span><span class="s2">(</span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocFunctionType</span><span class="s2">;</span>
        <span class="s1">updateJSDocFunctionType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocFunctionType</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocFunctionType</span><span class="s2">;</span>
        <span class="s1">createJSDocVariadicType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocVariadicType</span><span class="s2">;</span>
        <span class="s1">updateJSDocVariadicType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocVariadicType</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocVariadicType</span><span class="s2">;</span>
        <span class="s1">createJSDocNamepathType</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocNamepathType</span><span class="s2">;</span>
        <span class="s1">updateJSDocNamepathType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocNamepathType</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocNamepathType</span><span class="s2">;</span>
        <span class="s1">createJSDocTypeExpression</span><span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
        <span class="s1">updateJSDocTypeExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
        <span class="s1">createJSDocNameReference</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">): </span><span class="s1">JSDocNameReference</span><span class="s2">;</span>
        <span class="s1">updateJSDocNameReference</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocNameReference</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">): </span><span class="s1">JSDocNameReference</span><span class="s2">;</span>
        <span class="s1">createJSDocMemberName</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
        <span class="s1">updateJSDocMemberName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocMemberName</span><span class="s2">, </span><span class="s1">left</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
        <span class="s1">createJSDocLink</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JSDocLink</span><span class="s2">;</span>
        <span class="s1">updateJSDocLink</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocLink</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JSDocLink</span><span class="s2">;</span>
        <span class="s1">createJSDocLinkCode</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JSDocLinkCode</span><span class="s2">;</span>
        <span class="s1">updateJSDocLinkCode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocLinkCode</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JSDocLinkCode</span><span class="s2">;</span>
        <span class="s1">createJSDocLinkPlain</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JSDocLinkPlain</span><span class="s2">;</span>
        <span class="s1">updateJSDocLinkPlain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocLinkPlain</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">JSDocMemberName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JSDocLinkPlain</span><span class="s2">;</span>
        <span class="s1">createJSDocTypeLiteral</span><span class="s2">(</span><span class="s1">jsDocPropertyTags</span><span class="s2">?: </span><span class="s1">readonly JSDocPropertyLikeTag</span><span class="s2">[], </span><span class="s1">isArrayType</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">JSDocTypeLiteral</span><span class="s2">;</span>
        <span class="s1">updateJSDocTypeLiteral</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocTypeLiteral</span><span class="s2">, </span><span class="s1">jsDocPropertyTags</span><span class="s2">: </span><span class="s1">readonly JSDocPropertyLikeTag</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isArrayType</span><span class="s2">: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocTypeLiteral</span><span class="s2">;</span>
        <span class="s1">createJSDocSignature</span><span class="s2">(</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly JSDocTemplateTag</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly JSDocParameterTag</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">JSDocReturnTag</span><span class="s2">): </span><span class="s1">JSDocSignature</span><span class="s2">;</span>
        <span class="s1">updateJSDocSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocSignature</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly JSDocTemplateTag</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly JSDocParameterTag</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">JSDocReturnTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocSignature</span><span class="s2">;</span>
        <span class="s1">createJSDocTemplateTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[], </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocTemplateTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocTemplateTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocTemplateTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[], </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocTemplateTag</span><span class="s2">;</span>
        <span class="s1">createJSDocTypedefTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">JSDocTypeLiteral</span><span class="s2">, </span><span class="s1">fullName</span><span class="s2">?: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">JSDocNamespaceDeclaration</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocTypedefTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocTypedefTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocTypedefTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">JSDocTypeLiteral </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">fullName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocTypedefTag</span><span class="s2">;</span>
        <span class="s1">createJSDocParameterTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">isBracketed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">isNameFirst</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocParameterTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocParameterTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocParameterTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">isBracketed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isNameFirst</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocParameterTag</span><span class="s2">;</span>
        <span class="s1">createJSDocPropertyTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">isBracketed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">isNameFirst</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocPropertyTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocPropertyTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocPropertyTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">isBracketed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isNameFirst</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocPropertyTag</span><span class="s2">;</span>
        <span class="s1">createJSDocTypeTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocTypeTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocTypeTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocTypeTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocTypeTag</span><span class="s2">;</span>
        <span class="s1">createJSDocSeeTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">nameExpression</span><span class="s2">: </span><span class="s1">JSDocNameReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocSeeTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocSeeTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocSeeTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">nameExpression</span><span class="s2">: </span><span class="s1">JSDocNameReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocSeeTag</span><span class="s2">;</span>
        <span class="s1">createJSDocReturnTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocReturnTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocReturnTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocReturnTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocReturnTag</span><span class="s2">;</span>
        <span class="s1">createJSDocThisTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocThisTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocThisTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocThisTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocThisTag</span><span class="s2">;</span>
        <span class="s1">createJSDocEnumTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocEnumTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocEnumTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocEnumTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocEnumTag</span><span class="s2">;</span>
        <span class="s1">createJSDocCallbackTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocSignature</span><span class="s2">, </span><span class="s1">fullName</span><span class="s2">?: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">JSDocNamespaceDeclaration</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocCallbackTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocCallbackTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocCallbackTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocSignature</span><span class="s2">, </span><span class="s1">fullName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocCallbackTag</span><span class="s2">;</span>
        <span class="s1">createJSDocAugmentsTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">className</span><span class="s2">: </span><span class="s1">JSDocAugmentsTag</span><span class="s2">[</span><span class="s4">&quot;class&quot;</span><span class="s2">], </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocAugmentsTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocAugmentsTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocAugmentsTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">className</span><span class="s2">: </span><span class="s1">JSDocAugmentsTag</span><span class="s2">[</span><span class="s4">&quot;class&quot;</span><span class="s2">], </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocAugmentsTag</span><span class="s2">;</span>
        <span class="s1">createJSDocImplementsTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">className</span><span class="s2">: </span><span class="s1">JSDocImplementsTag</span><span class="s2">[</span><span class="s4">&quot;class&quot;</span><span class="s2">], </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocImplementsTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocImplementsTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocImplementsTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">className</span><span class="s2">: </span><span class="s1">JSDocImplementsTag</span><span class="s2">[</span><span class="s4">&quot;class&quot;</span><span class="s2">], </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocImplementsTag</span><span class="s2">;</span>
        <span class="s1">createJSDocAuthorTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocAuthorTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocAuthorTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocAuthorTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocAuthorTag</span><span class="s2">;</span>
        <span class="s1">createJSDocClassTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocClassTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocClassTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocClassTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocClassTag</span><span class="s2">;</span>
        <span class="s1">createJSDocPublicTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocPublicTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocPublicTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocPublicTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocPublicTag</span><span class="s2">;</span>
        <span class="s1">createJSDocPrivateTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocPrivateTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocPrivateTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocPrivateTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocPrivateTag</span><span class="s2">;</span>
        <span class="s1">createJSDocProtectedTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocProtectedTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocProtectedTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocProtectedTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocProtectedTag</span><span class="s2">;</span>
        <span class="s1">createJSDocReadonlyTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocReadonlyTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocReadonlyTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocReadonlyTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocReadonlyTag</span><span class="s2">;</span>
        <span class="s1">createJSDocUnknownTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocUnknownTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocUnknownTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocUnknownTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDocUnknownTag</span><span class="s2">;</span>
        <span class="s1">createJSDocDeprecatedTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocDeprecatedTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocDeprecatedTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocDeprecatedTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocDeprecatedTag</span><span class="s2">;</span>
        <span class="s1">createJSDocOverrideTag</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocOverrideTag</span><span class="s2">;</span>
        <span class="s1">updateJSDocOverrideTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocOverrideTag</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">JSDocOverrideTag</span><span class="s2">;</span>
        <span class="s1">createJSDocText</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JSDocText</span><span class="s2">;</span>
        <span class="s1">updateJSDocText</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDocText</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JSDocText</span><span class="s2">;</span>
        <span class="s1">createJSDocComment</span><span class="s2">(</span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">tags</span><span class="s2">?: </span><span class="s1">readonly JSDocTag</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDoc</span><span class="s2">;</span>
        <span class="s1">updateJSDocComment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JSDoc</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">tags</span><span class="s2">: </span><span class="s1">readonly JSDocTag</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JSDoc</span><span class="s2">;</span>
        <span class="s1">createJsxElement</span><span class="s2">(</span><span class="s1">openingElement</span><span class="s2">: </span><span class="s1">JsxOpeningElement</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">readonly JsxChild</span><span class="s2">[], </span><span class="s1">closingElement</span><span class="s2">: </span><span class="s1">JsxClosingElement</span><span class="s2">): </span><span class="s1">JsxElement</span><span class="s2">;</span>
        <span class="s1">updateJsxElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxElement</span><span class="s2">, </span><span class="s1">openingElement</span><span class="s2">: </span><span class="s1">JsxOpeningElement</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">readonly JsxChild</span><span class="s2">[], </span><span class="s1">closingElement</span><span class="s2">: </span><span class="s1">JsxClosingElement</span><span class="s2">): </span><span class="s1">JsxElement</span><span class="s2">;</span>
        <span class="s1">createJsxSelfClosingElement</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">): </span><span class="s1">JsxSelfClosingElement</span><span class="s2">;</span>
        <span class="s1">updateJsxSelfClosingElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxSelfClosingElement</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">): </span><span class="s1">JsxSelfClosingElement</span><span class="s2">;</span>
        <span class="s1">createJsxOpeningElement</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">): </span><span class="s1">JsxOpeningElement</span><span class="s2">;</span>
        <span class="s1">updateJsxOpeningElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxOpeningElement</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">): </span><span class="s1">JsxOpeningElement</span><span class="s2">;</span>
        <span class="s1">createJsxClosingElement</span><span class="s2">(</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">): </span><span class="s1">JsxClosingElement</span><span class="s2">;</span>
        <span class="s1">updateJsxClosingElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxClosingElement</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">): </span><span class="s1">JsxClosingElement</span><span class="s2">;</span>
        <span class="s1">createJsxFragment</span><span class="s2">(</span><span class="s1">openingFragment</span><span class="s2">: </span><span class="s1">JsxOpeningFragment</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">readonly JsxChild</span><span class="s2">[], </span><span class="s1">closingFragment</span><span class="s2">: </span><span class="s1">JsxClosingFragment</span><span class="s2">): </span><span class="s1">JsxFragment</span><span class="s2">;</span>
        <span class="s1">createJsxText</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containsOnlyTriviaWhiteSpaces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">JsxText</span><span class="s2">;</span>
        <span class="s1">updateJsxText</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxText</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containsOnlyTriviaWhiteSpaces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">JsxText</span><span class="s2">;</span>
        <span class="s1">createJsxOpeningFragment</span><span class="s2">(): </span><span class="s1">JsxOpeningFragment</span><span class="s2">;</span>
        <span class="s1">createJsxJsxClosingFragment</span><span class="s2">(): </span><span class="s1">JsxClosingFragment</span><span class="s2">;</span>
        <span class="s1">updateJsxFragment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxFragment</span><span class="s2">, </span><span class="s1">openingFragment</span><span class="s2">: </span><span class="s1">JsxOpeningFragment</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">readonly JsxChild</span><span class="s2">[], </span><span class="s1">closingFragment</span><span class="s2">: </span><span class="s1">JsxClosingFragment</span><span class="s2">): </span><span class="s1">JsxFragment</span><span class="s2">;</span>
        <span class="s1">createJsxAttribute</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">JsxAttributeValue </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JsxAttribute</span><span class="s2">;</span>
        <span class="s1">updateJsxAttribute</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxAttribute</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">JsxAttributeValue </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JsxAttribute</span><span class="s2">;</span>
        <span class="s1">createJsxAttributes</span><span class="s2">(</span><span class="s1">properties</span><span class="s2">: </span><span class="s1">readonly JsxAttributeLike</span><span class="s2">[]): </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
        <span class="s1">updateJsxAttributes</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">, </span><span class="s1">properties</span><span class="s2">: </span><span class="s1">readonly JsxAttributeLike</span><span class="s2">[]): </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
        <span class="s1">createJsxSpreadAttribute</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">JsxSpreadAttribute</span><span class="s2">;</span>
        <span class="s1">updateJsxSpreadAttribute</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxSpreadAttribute</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">JsxSpreadAttribute</span><span class="s2">;</span>
        <span class="s1">createJsxExpression</span><span class="s2">(</span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JsxExpression</span><span class="s2">;</span>
        <span class="s1">updateJsxExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">JsxExpression</span><span class="s2">;</span>
        <span class="s1">createCaseClause</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">CaseClause</span><span class="s2">;</span>
        <span class="s1">updateCaseClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CaseClause</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">CaseClause</span><span class="s2">;</span>
        <span class="s1">createDefaultClause</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">DefaultClause</span><span class="s2">;</span>
        <span class="s1">updateDefaultClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">DefaultClause</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">DefaultClause</span><span class="s2">;</span>
        <span class="s1">createHeritageClause</span><span class="s2">(</span><span class="s1">token</span><span class="s2">: </span><span class="s1">HeritageClause</span><span class="s2">[</span><span class="s4">&quot;token&quot;</span><span class="s2">], </span><span class="s1">types</span><span class="s2">: </span><span class="s1">readonly ExpressionWithTypeArguments</span><span class="s2">[]): </span><span class="s1">HeritageClause</span><span class="s2">;</span>
        <span class="s1">updateHeritageClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">HeritageClause</span><span class="s2">, </span><span class="s1">types</span><span class="s2">: </span><span class="s1">readonly ExpressionWithTypeArguments</span><span class="s2">[]): </span><span class="s1">HeritageClause</span><span class="s2">;</span>
        <span class="s1">createCatchClause</span><span class="s2">(</span><span class="s1">variableDeclaration</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName </span><span class="s2">| </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">block</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">): </span><span class="s1">CatchClause</span><span class="s2">;</span>
        <span class="s1">updateCatchClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CatchClause</span><span class="s2">, </span><span class="s1">variableDeclaration</span><span class="s2">: </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">block</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">): </span><span class="s1">CatchClause</span><span class="s2">;</span>
        <span class="s1">createPropertyAssignment</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PropertyAssignment</span><span class="s2">;</span>
        <span class="s1">updatePropertyAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyAssignment</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PropertyAssignment</span><span class="s2">;</span>
        <span class="s1">createShorthandPropertyAssignment</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">objectAssignmentInitializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ShorthandPropertyAssignment</span><span class="s2">;</span>
        <span class="s1">updateShorthandPropertyAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ShorthandPropertyAssignment</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">objectAssignmentInitializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ShorthandPropertyAssignment</span><span class="s2">;</span>
        <span class="s1">createSpreadAssignment</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">SpreadAssignment</span><span class="s2">;</span>
        <span class="s1">updateSpreadAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SpreadAssignment</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">SpreadAssignment</span><span class="s2">;</span>
        <span class="s1">createEnumMember</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">EnumMember</span><span class="s2">;</span>
        <span class="s1">updateEnumMember</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">EnumMember</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">EnumMember</span><span class="s2">;</span>
        <span class="s1">createSourceFile</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">endOfFileToken</span><span class="s2">: </span><span class="s1">EndOfFileToken</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">: </span><span class="s1">NodeFlags</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">updateSourceFile</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">isDeclarationFile</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">referencedFiles</span><span class="s2">?: </span><span class="s1">readonly FileReference</span><span class="s2">[], </span><span class="s1">typeReferences</span><span class="s2">?: </span><span class="s1">readonly FileReference</span><span class="s2">[], </span><span class="s1">hasNoDefaultLib</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">libReferences</span><span class="s2">?: </span><span class="s1">readonly FileReference</span><span class="s2">[]): </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">createNotEmittedStatement</span><span class="s2">(</span><span class="s1">original</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">NotEmittedStatement</span><span class="s2">;</span>
        <span class="s1">createPartiallyEmittedExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">original</span><span class="s2">?: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">PartiallyEmittedExpression</span><span class="s2">;</span>
        <span class="s1">updatePartiallyEmittedExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PartiallyEmittedExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PartiallyEmittedExpression</span><span class="s2">;</span>
        <span class="s1">createCommaListExpression</span><span class="s2">(</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]): </span><span class="s1">CommaListExpression</span><span class="s2">;</span>
        <span class="s1">updateCommaListExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CommaListExpression</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]): </span><span class="s1">CommaListExpression</span><span class="s2">;</span>
        <span class="s1">createBundle</span><span class="s2">(</span><span class="s1">sourceFiles</span><span class="s2">: </span><span class="s1">readonly SourceFile</span><span class="s2">[], </span><span class="s1">prepends</span><span class="s2">?: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">UnparsedSource </span><span class="s2">| </span><span class="s1">InputFiles</span><span class="s2">)[]): </span><span class="s1">Bundle</span><span class="s2">;</span>
        <span class="s1">updateBundle</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Bundle</span><span class="s2">, </span><span class="s1">sourceFiles</span><span class="s2">: </span><span class="s1">readonly SourceFile</span><span class="s2">[], </span><span class="s1">prepends</span><span class="s2">?: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">UnparsedSource </span><span class="s2">| </span><span class="s1">InputFiles</span><span class="s2">)[]): </span><span class="s1">Bundle</span><span class="s2">;</span>
        <span class="s1">createComma</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createAssignment</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">ObjectLiteralExpression </span><span class="s2">| </span><span class="s1">ArrayLiteralExpression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">DestructuringAssignment</span><span class="s2">;</span>
        <span class="s1">createAssignment</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">AssignmentExpression</span><span class="s2">&lt;</span><span class="s1">EqualsToken</span><span class="s2">&gt;;</span>
        <span class="s1">createLogicalOr</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createLogicalAnd</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createBitwiseOr</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createBitwiseXor</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createBitwiseAnd</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createStrictEquality</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createStrictInequality</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createEquality</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createInequality</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createLessThan</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createLessThanEquals</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createGreaterThan</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createGreaterThanEquals</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createLeftShift</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createRightShift</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createUnsignedRightShift</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createAdd</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createSubtract</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createMultiply</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createDivide</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createModulo</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createExponent</span><span class="s2">(</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
        <span class="s1">createPrefixPlus</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createPrefixMinus</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createPrefixIncrement</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createPrefixDecrement</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createBitwiseNot</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createLogicalNot</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createPostfixIncrement</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createPostfixDecrement</span><span class="s2">(</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
        <span class="s1">createImmediatelyInvokedFunctionExpression</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s1">createImmediatelyInvokedFunctionExpression</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">param</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">paramValue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s1">createImmediatelyInvokedArrowFunction</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s1">createImmediatelyInvokedArrowFunction</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">param</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">paramValue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s1">createVoidZero</span><span class="s2">(): </span><span class="s1">VoidExpression</span><span class="s2">;</span>
        <span class="s1">createExportDefault</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
        <span class="s1">createExternalModuleExport</span><span class="s2">(</span><span class="s1">exportName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
        <span class="s1">restoreOuterExpressions</span><span class="s2">(</span><span class="s1">outerExpression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">innerExpression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">kinds</span><span class="s2">?: </span><span class="s1">OuterExpressionKinds</span><span class="s2">): </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">CoreTransformationContext </span><span class="s2">{</span>
        <span class="s1">readonly factory</span><span class="s2">: </span><span class="s1">NodeFactory</span><span class="s2">;</span>
        <span class="s5">/** Gets the compiler options supplied to the transformer. */</span>
        <span class="s1">getCompilerOptions</span><span class="s2">(): </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s5">/** Starts a new lexical environment. */</span>
        <span class="s1">startLexicalEnvironment</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/** Suspends the current lexical environment, usually after visiting a parameter list. */</span>
        <span class="s1">suspendLexicalEnvironment</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/** Resumes a suspended lexical environment, usually before visiting a function body. */</span>
        <span class="s1">resumeLexicalEnvironment</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/** Ends a lexical environment, returning any declarations. */</span>
        <span class="s1">endLexicalEnvironment</span><span class="s2">(): </span><span class="s1">Statement</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Hoists a function declaration to the containing scope. */</span>
        <span class="s1">hoistFunctionDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionDeclaration</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/** Hoists a variable declaration to the containing scope. */</span>
        <span class="s1">hoistVariableDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TransformationContext </span><span class="s3">extends </span><span class="s1">CoreTransformationContext </span><span class="s2">{</span>
        <span class="s5">/** Records a request for a non-scoped emit helper in the current context. */</span>
        <span class="s1">requestEmitHelper</span><span class="s2">(</span><span class="s1">helper</span><span class="s2">: </span><span class="s1">EmitHelper</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/** Gets and resets the requested non-scoped emit helpers. */</span>
        <span class="s1">readEmitHelpers</span><span class="s2">(): </span><span class="s1">EmitHelper</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Enables expression substitutions in the pretty printer for the provided SyntaxKind. */</span>
        <span class="s1">enableSubstitution</span><span class="s2">(</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/** Determines whether expression substitutions are enabled for the provided node. */</span>
        <span class="s1">isSubstitutionEnabled</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Hook used by transformers to substitute expressions just before they</span>
         <span class="s5">* are emitted by the pretty printer.</span>
         <span class="s5">*</span>
         <span class="s5">* NOTE: Transformation hooks should only be modified during `Transformer` initialization,</span>
         <span class="s5">* before returning the `NodeTransformer` callback.</span>
         <span class="s5">*/</span>
        <span class="s1">onSubstituteNode</span><span class="s2">: (</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">Node</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Enables before/after emit notifications in the pretty printer for the provided</span>
         <span class="s5">* SyntaxKind.</span>
         <span class="s5">*/</span>
        <span class="s1">enableEmitNotification</span><span class="s2">(</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Determines whether before/after emit notifications should be raised in the pretty</span>
         <span class="s5">* printer when it emits a node.</span>
         <span class="s5">*/</span>
        <span class="s1">isEmitNotificationEnabled</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Hook used to allow transformers to capture state before or after</span>
         <span class="s5">* the printer emits a node.</span>
         <span class="s5">*</span>
         <span class="s5">* NOTE: Transformation hooks should only be modified during `Transformer` initialization,</span>
         <span class="s5">* before returning the `NodeTransformer` callback.</span>
         <span class="s5">*/</span>
        <span class="s1">onEmitNode</span><span class="s2">: (</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">emitCallback</span><span class="s2">: (</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TransformationResult</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt; {</span>
        <span class="s5">/** Gets the transformed source files. */</span>
        <span class="s1">transformed</span><span class="s2">: </span><span class="s1">T</span><span class="s2">[];</span>
        <span class="s5">/** Gets diagnostics for the transformation. */</span>
        <span class="s1">diagnostics</span><span class="s2">?: </span><span class="s1">DiagnosticWithLocation</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets a substitute for a node, if one is available; otherwise, returns the original node.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">hint A hint as to the intended usage of the node.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The node to substitute.</span>
         <span class="s5">*/</span>
        <span class="s1">substituteNode</span><span class="s2">(</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Node</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Emits a node with possible notification.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">hint A hint as to the intended usage of the node.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The node to emit.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">emitCallback A callback used to emit the node.</span>
         <span class="s5">*/</span>
        <span class="s1">emitNodeWithNotification</span><span class="s2">(</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">emitCallback</span><span class="s2">: (</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Indicates if a given node needs an emit notification</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The node to emit.</span>
         <span class="s5">*/</span>
        <span class="s1">isEmitNotificationEnabled</span><span class="s2">?(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Clean up EmitNode entries on any parse-tree nodes.</span>
         <span class="s5">*/</span>
        <span class="s1">dispose</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* A function that is used to initialize and return a `Transformer` callback, which in turn</span>
     <span class="s5">* will be used to transform one or more nodes.</span>
     <span class="s5">*/</span>
    <span class="s3">export </span><span class="s1">type TransformerFactory</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt; = (</span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">) =&gt; </span><span class="s1">Transformer</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s5">/**</span>
     <span class="s5">* A function that transforms a node.</span>
     <span class="s5">*/</span>
    <span class="s3">export </span><span class="s1">type Transformer</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt; = (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">) =&gt; </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* A function that accepts and possibly transforms a node.</span>
     <span class="s5">*/</span>
    <span class="s3">export </span><span class="s1">type Visitor </span><span class="s2">= (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">VisitResult</span><span class="s2">&lt;</span><span class="s1">Node</span><span class="s2">&gt;;</span>
    <span class="s3">export interface </span><span class="s1">NodeVisitor </span><span class="s2">{</span>
        <span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">test</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">lift</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">readonly Node</span><span class="s2">[]) =&gt; </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
        <span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">test</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">lift</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">readonly Node</span><span class="s2">[]) =&gt; </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">NodesVisitor </span><span class="s2">{</span>
        <span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">test</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">start</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">count</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
        <span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">test</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">start</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">count</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type VisitResult</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt; = </span><span class="s1">T </span><span class="s2">| </span><span class="s1">readonly T</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">Printer </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Print a node and its subtree as-is, without any emit transformations.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">hint A value indicating the purpose of a node. This is primarily used to</span>
         <span class="s5">* distinguish between an `Identifier` used in an expression position, versus an</span>
         <span class="s5">* `Identifier` used as an `IdentifierName` as part of a declaration. For most nodes you</span>
         <span class="s5">* should just pass `Unspecified`.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The node to print. The node and its subtree are printed as-is, without any</span>
         <span class="s5">* emit transformations.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">sourceFile A source file that provides context for the node. The source text of</span>
         <span class="s5">* the file is used to emit the original source content for literals and identifiers, while</span>
         <span class="s5">* the identifiers of the source file are used when generating unique names to avoid</span>
         <span class="s5">* collisions.</span>
         <span class="s5">*/</span>
        <span class="s1">printNode</span><span class="s2">(</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Prints a list of nodes using the given format flags</span>
         <span class="s5">*/</span>
        <span class="s1">printList</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">format</span><span class="s2">: </span><span class="s1">ListFormat</span><span class="s2">, </span><span class="s1">list</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Prints a source file as-is, without any emit transformations.</span>
         <span class="s5">*/</span>
        <span class="s1">printFile</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Prints a bundle of source files as-is, without any emit transformations.</span>
         <span class="s5">*/</span>
        <span class="s1">printBundle</span><span class="s2">(</span><span class="s1">bundle</span><span class="s2">: </span><span class="s1">Bundle</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PrintHandlers </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* A hook used by the Printer when generating unique names to avoid collisions with</span>
         <span class="s5">* globally defined names that exist outside of the current source file.</span>
         <span class="s5">*/</span>
        <span class="s1">hasGlobalName</span><span class="s2">?(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* A hook used by the Printer to provide notifications prior to emitting a node. A</span>
         <span class="s5">* compatible implementation **must** invoke `emitCallback` with the provided `hint` and</span>
         <span class="s5">* `node` values.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">hint A hint indicating the intended purpose of the node.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The node to emit.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">emitCallback A callback that, when invoked, will emit the node.</span>
         <span class="s5">* </span><span class="s7">@example</span>
         <span class="s5">* ```ts</span>
         <span class="s5">* var printer = createPrinter(printerOptions, {</span>
         <span class="s5">*   onEmitNode(hint, node, emitCallback) {</span>
         <span class="s5">*     // set up or track state prior to emitting the node...</span>
         <span class="s5">*     emitCallback(hint, node);</span>
         <span class="s5">*     // restore state after emitting the node...</span>
         <span class="s5">*   }</span>
         <span class="s5">* });</span>
         <span class="s5">* ```</span>
         <span class="s5">*/</span>
        <span class="s1">onEmitNode</span><span class="s2">?(</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">emitCallback</span><span class="s2">: (</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* A hook used to check if an emit notification is required for a node.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The node to emit.</span>
         <span class="s5">*/</span>
        <span class="s1">isEmitNotificationEnabled</span><span class="s2">?(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* A hook used by the Printer to perform just-in-time substitution of a node. This is</span>
         <span class="s5">* primarily used by node transformations that need to substitute one node for another,</span>
         <span class="s5">* such as replacing `myExportedVar` with `exports.myExportedVar`.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">hint A hint indicating the intended purpose of the node.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The node to emit.</span>
         <span class="s5">* </span><span class="s7">@example</span>
         <span class="s5">* ```ts</span>
         <span class="s5">* var printer = createPrinter(printerOptions, {</span>
         <span class="s5">*   substituteNode(hint, node) {</span>
         <span class="s5">*     // perform substitution if necessary...</span>
         <span class="s5">*     return node;</span>
         <span class="s5">*   }</span>
         <span class="s5">* });</span>
         <span class="s5">* ```</span>
         <span class="s5">*/</span>
        <span class="s1">substituteNode</span><span class="s2">?(</span><span class="s1">hint</span><span class="s2">: </span><span class="s1">EmitHint</span><span class="s2">, </span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Node</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PrinterOptions </span><span class="s2">{</span>
        <span class="s1">removeComments</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">newLine</span><span class="s2">?: </span><span class="s1">NewLineKind</span><span class="s2">;</span>
        <span class="s1">omitTrailingSemicolon</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">noEmitHelpers</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">GetEffectiveTypeRootsHost </span><span class="s2">{</span>
        <span class="s1">directoryExists</span><span class="s2">?(</span><span class="s1">directoryName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">?(): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TextSpan </span><span class="s2">{</span>
        <span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">TextChangeRange </span><span class="s2">{</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">newLength</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">SyntaxList </span><span class="s3">extends </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SyntaxList</span><span class="s2">;</span>
        <span class="s1">_children</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">export enum </span><span class="s1">ListFormat </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">SingleLine </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">MultiLine </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">PreserveLines </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">LinesMask </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">NotDelimited </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">BarDelimited </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">AmpersandDelimited </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">CommaDelimited </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">AsteriskDelimited </span><span class="s2">= </span><span class="s6">32</span><span class="s2">,</span>
        <span class="s1">DelimitersMask </span><span class="s2">= </span><span class="s6">60</span><span class="s2">,</span>
        <span class="s1">AllowTrailingComma </span><span class="s2">= </span><span class="s6">64</span><span class="s2">,</span>
        <span class="s1">Indented </span><span class="s2">= </span><span class="s6">128</span><span class="s2">,</span>
        <span class="s1">SpaceBetweenBraces </span><span class="s2">= </span><span class="s6">256</span><span class="s2">,</span>
        <span class="s1">SpaceBetweenSiblings </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">Braces </span><span class="s2">= </span><span class="s6">1024</span><span class="s2">,</span>
        <span class="s1">Parenthesis </span><span class="s2">= </span><span class="s6">2048</span><span class="s2">,</span>
        <span class="s1">AngleBrackets </span><span class="s2">= </span><span class="s6">4096</span><span class="s2">,</span>
        <span class="s1">SquareBrackets </span><span class="s2">= </span><span class="s6">8192</span><span class="s2">,</span>
        <span class="s1">BracketsMask </span><span class="s2">= </span><span class="s6">15360</span><span class="s2">,</span>
        <span class="s1">OptionalIfUndefined </span><span class="s2">= </span><span class="s6">16384</span><span class="s2">,</span>
        <span class="s1">OptionalIfEmpty </span><span class="s2">= </span><span class="s6">32768</span><span class="s2">,</span>
        <span class="s1">Optional </span><span class="s2">= </span><span class="s6">49152</span><span class="s2">,</span>
        <span class="s1">PreferNewLine </span><span class="s2">= </span><span class="s6">65536</span><span class="s2">,</span>
        <span class="s1">NoTrailingNewLine </span><span class="s2">= </span><span class="s6">131072</span><span class="s2">,</span>
        <span class="s1">NoInterveningComments </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">NoSpaceIfEmpty </span><span class="s2">= </span><span class="s6">524288</span><span class="s2">,</span>
        <span class="s1">SingleElement </span><span class="s2">= </span><span class="s6">1048576</span><span class="s2">,</span>
        <span class="s1">SpaceAfterList </span><span class="s2">= </span><span class="s6">2097152</span><span class="s2">,</span>
        <span class="s1">Modifiers </span><span class="s2">= </span><span class="s6">2359808</span><span class="s2">,</span>
        <span class="s1">HeritageClauses </span><span class="s2">= </span><span class="s6">512</span><span class="s2">,</span>
        <span class="s1">SingleLineTypeLiteralMembers </span><span class="s2">= </span><span class="s6">768</span><span class="s2">,</span>
        <span class="s1">MultiLineTypeLiteralMembers </span><span class="s2">= </span><span class="s6">32897</span><span class="s2">,</span>
        <span class="s1">SingleLineTupleTypeElements </span><span class="s2">= </span><span class="s6">528</span><span class="s2">,</span>
        <span class="s1">MultiLineTupleTypeElements </span><span class="s2">= </span><span class="s6">657</span><span class="s2">,</span>
        <span class="s1">UnionTypeConstituents </span><span class="s2">= </span><span class="s6">516</span><span class="s2">,</span>
        <span class="s1">IntersectionTypeConstituents </span><span class="s2">= </span><span class="s6">520</span><span class="s2">,</span>
        <span class="s1">ObjectBindingPatternElements </span><span class="s2">= </span><span class="s6">525136</span><span class="s2">,</span>
        <span class="s1">ArrayBindingPatternElements </span><span class="s2">= </span><span class="s6">524880</span><span class="s2">,</span>
        <span class="s1">ObjectLiteralExpressionProperties </span><span class="s2">= </span><span class="s6">526226</span><span class="s2">,</span>
        <span class="s1">ImportClauseEntries </span><span class="s2">= </span><span class="s6">526226</span><span class="s2">,</span>
        <span class="s1">ArrayLiteralExpressionElements </span><span class="s2">= </span><span class="s6">8914</span><span class="s2">,</span>
        <span class="s1">CommaListElements </span><span class="s2">= </span><span class="s6">528</span><span class="s2">,</span>
        <span class="s1">CallExpressionArguments </span><span class="s2">= </span><span class="s6">2576</span><span class="s2">,</span>
        <span class="s1">NewExpressionArguments </span><span class="s2">= </span><span class="s6">18960</span><span class="s2">,</span>
        <span class="s1">TemplateExpressionSpans </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">SingleLineBlockStatements </span><span class="s2">= </span><span class="s6">768</span><span class="s2">,</span>
        <span class="s1">MultiLineBlockStatements </span><span class="s2">= </span><span class="s6">129</span><span class="s2">,</span>
        <span class="s1">VariableDeclarationList </span><span class="s2">= </span><span class="s6">528</span><span class="s2">,</span>
        <span class="s1">SingleLineFunctionBodyStatements </span><span class="s2">= </span><span class="s6">768</span><span class="s2">,</span>
        <span class="s1">MultiLineFunctionBodyStatements </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">ClassHeritageClauses </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">ClassMembers </span><span class="s2">= </span><span class="s6">129</span><span class="s2">,</span>
        <span class="s1">InterfaceMembers </span><span class="s2">= </span><span class="s6">129</span><span class="s2">,</span>
        <span class="s1">EnumMembers </span><span class="s2">= </span><span class="s6">145</span><span class="s2">,</span>
        <span class="s1">CaseBlockClauses </span><span class="s2">= </span><span class="s6">129</span><span class="s2">,</span>
        <span class="s1">NamedImportsOrExportsElements </span><span class="s2">= </span><span class="s6">525136</span><span class="s2">,</span>
        <span class="s1">JsxElementOrFragmentChildren </span><span class="s2">= </span><span class="s6">262144</span><span class="s2">,</span>
        <span class="s1">JsxElementAttributes </span><span class="s2">= </span><span class="s6">262656</span><span class="s2">,</span>
        <span class="s1">CaseOrDefaultClauseStatements </span><span class="s2">= </span><span class="s6">163969</span><span class="s2">,</span>
        <span class="s1">HeritageClauseTypes </span><span class="s2">= </span><span class="s6">528</span><span class="s2">,</span>
        <span class="s1">SourceFileStatements </span><span class="s2">= </span><span class="s6">131073</span><span class="s2">,</span>
        <span class="s1">Decorators </span><span class="s2">= </span><span class="s6">2146305</span><span class="s2">,</span>
        <span class="s1">TypeArguments </span><span class="s2">= </span><span class="s6">53776</span><span class="s2">,</span>
        <span class="s1">TypeParameters </span><span class="s2">= </span><span class="s6">53776</span><span class="s2">,</span>
        <span class="s1">Parameters </span><span class="s2">= </span><span class="s6">2576</span><span class="s2">,</span>
        <span class="s1">IndexSignatureParameters </span><span class="s2">= </span><span class="s6">8848</span><span class="s2">,</span>
        <span class="s1">JSDocComment </span><span class="s2">= </span><span class="s6">33</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">UserPreferences </span><span class="s2">{</span>
        <span class="s1">readonly disableSuggestions</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly quotePreference</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;double&quot; </span><span class="s2">| </span><span class="s4">&quot;single&quot;</span><span class="s2">;</span>
        <span class="s1">readonly includeCompletionsForModuleExports</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeCompletionsForImportStatements</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeCompletionsWithSnippetText</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeAutomaticOptionalChainCompletions</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeCompletionsWithInsertText</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeCompletionsWithClassMemberSnippets</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeCompletionsWithObjectLiteralMethodSnippets</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly useLabelDetailsInCompletionEntries</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly allowIncompleteCompletions</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly importModuleSpecifierPreference</span><span class="s2">?: </span><span class="s4">&quot;shortest&quot; </span><span class="s2">| </span><span class="s4">&quot;project-relative&quot; </span><span class="s2">| </span><span class="s4">&quot;relative&quot; </span><span class="s2">| </span><span class="s4">&quot;non-relative&quot;</span><span class="s2">;</span>
        <span class="s5">/** Determines whether we import `foo/index.ts` as &quot;foo&quot;, &quot;foo/index&quot;, or &quot;foo/index.js&quot; */</span>
        <span class="s1">readonly importModuleSpecifierEnding</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;minimal&quot; </span><span class="s2">| </span><span class="s4">&quot;index&quot; </span><span class="s2">| </span><span class="s4">&quot;js&quot;</span><span class="s2">;</span>
        <span class="s1">readonly allowTextChangesInNewFiles</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly providePrefixAndSuffixTextForRename</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includePackageJsonAutoImports</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;on&quot; </span><span class="s2">| </span><span class="s4">&quot;off&quot;</span><span class="s2">;</span>
        <span class="s1">readonly provideRefactorNotApplicableReason</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly jsxAttributeCompletionStyle</span><span class="s2">?: </span><span class="s4">&quot;auto&quot; </span><span class="s2">| </span><span class="s4">&quot;braces&quot; </span><span class="s2">| </span><span class="s4">&quot;none&quot;</span><span class="s2">;</span>
        <span class="s1">readonly includeInlayParameterNameHints</span><span class="s2">?: </span><span class="s4">&quot;none&quot; </span><span class="s2">| </span><span class="s4">&quot;literals&quot; </span><span class="s2">| </span><span class="s4">&quot;all&quot;</span><span class="s2">;</span>
        <span class="s1">readonly includeInlayParameterNameHintsWhenArgumentMatchesName</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeInlayFunctionParameterTypeHints</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeInlayVariableTypeHints</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeInlayVariableTypeHintsWhenTypeMatchesName</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeInlayPropertyDeclarationTypeHints</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeInlayFunctionLikeReturnTypeHints</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly includeInlayEnumMemberValueHints</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly allowRenameOfImportPath</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly autoImportFileExcludePatterns</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s5">/** Represents a bigint literal value without requiring bigint support */</span>
    <span class="s3">export interface </span><span class="s1">PseudoBigInt </span><span class="s2">{</span>
        <span class="s1">negative</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">base10Value</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s2">{};</span>
<span class="s2">}</span>
<span class="s1">declare </span><span class="s3">function </span><span class="s1">setTimeout</span><span class="s2">(</span><span class="s1">handler</span><span class="s2">: (</span><span class="s1">...args</span><span class="s2">: </span><span class="s1">any</span><span class="s2">[]) =&gt; </span><span class="s3">void</span><span class="s2">, </span><span class="s1">timeout</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">any</span><span class="s2">;</span>
<span class="s1">declare </span><span class="s3">function </span><span class="s1">clearTimeout</span><span class="s2">(</span><span class="s1">handle</span><span class="s2">: </span><span class="s1">any</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">export enum </span><span class="s1">FileWatcherEventKind </span><span class="s2">{</span>
        <span class="s1">Created </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Changed </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Deleted </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s2">}</span>
    <span class="s3">export </span><span class="s1">type FileWatcherCallback </span><span class="s2">= (</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">eventKind</span><span class="s2">: </span><span class="s1">FileWatcherEventKind</span><span class="s2">, </span><span class="s1">modifiedTime</span><span class="s2">?: </span><span class="s1">Date</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type DirectoryWatcherCallback </span><span class="s2">= (</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">System </span><span class="s2">{</span>
        <span class="s1">args</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">newLine</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">write</span><span class="s2">(</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">writeOutputIsTTY</span><span class="s2">?(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getWidthOfTerminal</span><span class="s2">?(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">readFile</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getFileSize</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">writeFile</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">writeByteOrderMark</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@pollingInterval </span><span class="s5">- this parameter is used in polling-based watchers and ignored in watchers that</span>
         <span class="s5">* use native OS file watching</span>
         <span class="s5">*/</span>
        <span class="s1">watchFile</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">: </span><span class="s1">FileWatcherCallback</span><span class="s2">, </span><span class="s1">pollingInterval</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">): </span><span class="s1">FileWatcher</span><span class="s2">;</span>
        <span class="s1">watchDirectory</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">: </span><span class="s1">DirectoryWatcherCallback</span><span class="s2">, </span><span class="s1">recursive</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">): </span><span class="s1">FileWatcher</span><span class="s2">;</span>
        <span class="s1">resolvePath</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">fileExists</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">directoryExists</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">createDirectory</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">getExecutingFilePath</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getDirectories</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">readDirectory</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">extensions</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">exclude</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">include</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">depth</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">getModifiedTime</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">Date </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">setModifiedTime</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">time</span><span class="s2">: </span><span class="s1">Date</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">deleteFile</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* A good implementation is node.js' `crypto.createHash`. (https://nodejs.org/api/crypto.html#crypto_crypto_createhash_algorithm)</span>
         <span class="s5">*/</span>
        <span class="s1">createHash</span><span class="s2">?(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** This must be cryptographically secure. Only implement this method using `crypto.createHash(&quot;sha256&quot;)`. */</span>
        <span class="s1">createSHA256Hash</span><span class="s2">?(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getMemoryUsage</span><span class="s2">?(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">exit</span><span class="s2">(</span><span class="s1">exitCode</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">realpath</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">setTimeout</span><span class="s2">?(</span><span class="s1">callback</span><span class="s2">: (</span><span class="s1">...args</span><span class="s2">: </span><span class="s1">any</span><span class="s2">[]) =&gt; </span><span class="s3">void</span><span class="s2">, </span><span class="s1">ms</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">...args</span><span class="s2">: </span><span class="s1">any</span><span class="s2">[]): </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">clearTimeout</span><span class="s2">?(</span><span class="s1">timeoutId</span><span class="s2">: </span><span class="s1">any</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">clearScreen</span><span class="s2">?(): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">base64decode</span><span class="s2">?(</span><span class="s1">input</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">base64encode</span><span class="s2">?(</span><span class="s1">input</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">FileWatcher </span><span class="s2">{</span>
        <span class="s1">close</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export function </span><span class="s1">getNodeMajorVersion</span><span class="s2">(): </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">export let </span><span class="s1">sys</span><span class="s2">: </span><span class="s1">System</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s2">{};</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s1">type ErrorCallback </span><span class="s2">= (</span><span class="s1">message</span><span class="s2">: </span><span class="s1">DiagnosticMessage</span><span class="s2">, </span><span class="s1">length</span><span class="s2">: </span><span class="s1">number</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">Scanner </span><span class="s2">{</span>
        <span class="s1">getStartPos</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getToken</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">getTextPos</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getTokenPos</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getTokenText</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getTokenValue</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">hasUnicodeEscape</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">hasExtendedUnicodeEscape</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">hasPrecedingLineBreak</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isIdentifier</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isReservedWord</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isUnterminated</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">reScanGreaterToken</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanSlashToken</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanAsteriskEqualsToken</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanTemplateToken</span><span class="s2">(</span><span class="s1">isTaggedTemplate</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanTemplateHeadOrNoSubstitutionTemplate</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">scanJsxIdentifier</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">scanJsxAttributeValue</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanJsxAttributeValue</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanJsxToken</span><span class="s2">(</span><span class="s1">allowMultilineJsxText</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">JsxTokenSyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanLessThanToken</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanHashToken</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanQuestionToken</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">reScanInvalidIdentifier</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">scanJsxToken</span><span class="s2">(): </span><span class="s1">JsxTokenSyntaxKind</span><span class="s2">;</span>
        <span class="s1">scanJsDocToken</span><span class="s2">(): </span><span class="s1">JSDocSyntaxKind</span><span class="s2">;</span>
        <span class="s1">scan</span><span class="s2">(): </span><span class="s1">SyntaxKind</span><span class="s2">;</span>
        <span class="s1">getText</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">setText</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">start</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">length</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">setOnError</span><span class="s2">(</span><span class="s1">onError</span><span class="s2">: </span><span class="s1">ErrorCallback </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">setScriptTarget</span><span class="s2">(</span><span class="s1">scriptTarget</span><span class="s2">: </span><span class="s1">ScriptTarget</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">setLanguageVariant</span><span class="s2">(</span><span class="s1">variant</span><span class="s2">: </span><span class="s1">LanguageVariant</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">setTextPos</span><span class="s2">(</span><span class="s1">textPos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">lookAhead</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;(</span><span class="s1">callback</span><span class="s2">: () =&gt; </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
        <span class="s1">scanRange</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;(</span><span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">length</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">: () =&gt; </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
        <span class="s1">tryScan</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;(</span><span class="s1">callback</span><span class="s2">: () =&gt; </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">function </span><span class="s1">tokenToString</span><span class="s2">(</span><span class="s1">t</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getPositionOfLineAndCharacter</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFileLike</span><span class="s2">, </span><span class="s1">line</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">character</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getLineAndCharacterOfPosition</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFileLike</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">LineAndCharacter</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isWhiteSpaceLike</span><span class="s2">(</span><span class="s1">ch</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s5">/** Does not include line breaks. For that, see isWhiteSpaceLike. */</span>
    <span class="s3">function </span><span class="s1">isWhiteSpaceSingleLine</span><span class="s2">(</span><span class="s1">ch</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isLineBreak</span><span class="s2">(</span><span class="s1">ch</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">couldStartTrivia</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">forEachLeadingCommentRange</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt;(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">: (</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">CommentKind</span><span class="s2">, </span><span class="s1">hasTrailingNewLine</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">) =&gt; </span><span class="s1">U</span><span class="s2">): </span><span class="s1">U </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">forEachLeadingCommentRange</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">U</span><span class="s2">&gt;(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">: (</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">CommentKind</span><span class="s2">, </span><span class="s1">hasTrailingNewLine</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">state</span><span class="s2">: </span><span class="s1">T</span><span class="s2">) =&gt; </span><span class="s1">U</span><span class="s2">, </span><span class="s1">state</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">U </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">forEachTrailingCommentRange</span><span class="s2">&lt;</span><span class="s1">U</span><span class="s2">&gt;(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">: (</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">CommentKind</span><span class="s2">, </span><span class="s1">hasTrailingNewLine</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">) =&gt; </span><span class="s1">U</span><span class="s2">): </span><span class="s1">U </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">forEachTrailingCommentRange</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">U</span><span class="s2">&gt;(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">: (</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">CommentKind</span><span class="s2">, </span><span class="s1">hasTrailingNewLine</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">state</span><span class="s2">: </span><span class="s1">T</span><span class="s2">) =&gt; </span><span class="s1">U</span><span class="s2">, </span><span class="s1">state</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s1">U </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">reduceEachLeadingCommentRange</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">U</span><span class="s2">&gt;(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">: (</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">CommentKind</span><span class="s2">, </span><span class="s1">hasTrailingNewLine</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">state</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">: </span><span class="s1">U</span><span class="s2">) =&gt; </span><span class="s1">U</span><span class="s2">, </span><span class="s1">state</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">: </span><span class="s1">U</span><span class="s2">): </span><span class="s1">U </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">reduceEachTrailingCommentRange</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">, </span><span class="s1">U</span><span class="s2">&gt;(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">cb</span><span class="s2">: (</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">CommentKind</span><span class="s2">, </span><span class="s1">hasTrailingNewLine</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">state</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">memo</span><span class="s2">: </span><span class="s1">U</span><span class="s2">) =&gt; </span><span class="s1">U</span><span class="s2">, </span><span class="s1">state</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">initial</span><span class="s2">: </span><span class="s1">U</span><span class="s2">): </span><span class="s1">U </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getLeadingCommentRanges</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">CommentRange</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getTrailingCommentRanges</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">CommentRange</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Optionally, get the shebang */</span>
    <span class="s3">function </span><span class="s1">getShebang</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIdentifierStart</span><span class="s2">(</span><span class="s1">ch</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">languageVersion</span><span class="s2">: </span><span class="s1">ScriptTarget </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIdentifierPart</span><span class="s2">(</span><span class="s1">ch</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">languageVersion</span><span class="s2">: </span><span class="s1">ScriptTarget </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">identifierVariant</span><span class="s2">?: </span><span class="s1">LanguageVariant</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createScanner</span><span class="s2">(</span><span class="s1">languageVersion</span><span class="s2">: </span><span class="s1">ScriptTarget</span><span class="s2">, </span><span class="s1">skipTrivia</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">languageVariant</span><span class="s2">?: </span><span class="s1">LanguageVariant</span><span class="s2">, </span><span class="s1">textInitial</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">onError</span><span class="s2">?: </span><span class="s1">ErrorCallback</span><span class="s2">, </span><span class="s1">start</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">length</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">Scanner</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">function </span><span class="s1">isExternalModuleNameRelative</span><span class="s2">(</span><span class="s1">moduleName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">sortAndDeduplicateDiagnostics</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Diagnostic</span><span class="s2">&gt;(</span><span class="s1">diagnostics</span><span class="s2">: </span><span class="s1">readonly T</span><span class="s2">[]): </span><span class="s1">SortedReadonlyArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s3">function </span><span class="s1">getDefaultLibFileName</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanEnd</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanIsEmpty</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanContainsPosition</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanContainsTextSpan</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">other</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanOverlapsWith</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">other</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanOverlap</span><span class="s2">(</span><span class="s1">span1</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">span2</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">TextSpan </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanIntersectsWithTextSpan</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">other</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanIntersectsWith</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">length</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">decodedTextSpanIntersectsWith</span><span class="s2">(</span><span class="s1">start1</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">length1</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">start2</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">length2</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanIntersectsWithPosition</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textSpanIntersection</span><span class="s2">(</span><span class="s1">span1</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">span2</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">TextSpan </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createTextSpan</span><span class="s2">(</span><span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">length</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">TextSpan</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createTextSpanFromBounds</span><span class="s2">(</span><span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">TextSpan</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textChangeRangeNewSpan</span><span class="s2">(</span><span class="s1">range</span><span class="s2">: </span><span class="s1">TextChangeRange</span><span class="s2">): </span><span class="s1">TextSpan</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">textChangeRangeIsUnchanged</span><span class="s2">(</span><span class="s1">range</span><span class="s2">: </span><span class="s1">TextChangeRange</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createTextChangeRange</span><span class="s2">(</span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">newLength</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">TextChangeRange</span><span class="s2">;</span>
    <span class="s3">let </span><span class="s1">unchangedTextChangeRange</span><span class="s2">: </span><span class="s1">TextChangeRange</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Called to merge all the changes that occurred across several versions of a script snapshot</span>
     <span class="s5">* into a single change.  i.e. if a user keeps making successive edits to a script we will</span>
     <span class="s5">* have a text change from V1 to V2, V2 to V3, ..., Vn.</span>
     <span class="s5">*</span>
     <span class="s5">* This function will then merge those changes into a single change range valid between V1 and</span>
     <span class="s5">* Vn.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">collapseTextChangeRangesAcrossMultipleVersions</span><span class="s2">(</span><span class="s1">changes</span><span class="s2">: </span><span class="s1">readonly TextChangeRange</span><span class="s2">[]): </span><span class="s1">TextChangeRange</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getTypeParameterOwner</span><span class="s2">(</span><span class="s1">d</span><span class="s2">: </span><span class="s1">Declaration</span><span class="s2">): </span><span class="s1">Declaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s1">type ParameterPropertyDeclaration </span><span class="s2">= </span><span class="s1">ParameterDeclaration </span><span class="s2">&amp; {</span>
        <span class="s1">parent</span><span class="s2">: </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s3">function </span><span class="s1">isParameterPropertyDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ParameterPropertyDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isEmptyBindingPattern</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">BindingPattern</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isEmptyBindingElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">BindingElement</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">walkUpBindingElementsAndPatterns</span><span class="s2">(</span><span class="s1">binding</span><span class="s2">: </span><span class="s1">BindingElement</span><span class="s2">): </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getCombinedModifierFlags</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Declaration</span><span class="s2">): </span><span class="s1">ModifierFlags</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getCombinedNodeFlags</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">NodeFlags</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Checks to see if the locale is in the appropriate format,</span>
     <span class="s5">* and if it is, attempts to set the appropriate language.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">validateLocaleAndSetLanguage</span><span class="s2">(</span><span class="s1">locale</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">sys</span><span class="s2">: {</span>
        <span class="s1">getExecutingFilePath</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">resolvePath</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">fileExists</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}, </span><span class="s1">errors</span><span class="s2">?: </span><span class="s1">Push</span><span class="s2">&lt;</span><span class="s1">Diagnostic</span><span class="s2">&gt;): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getOriginalNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Node</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getOriginalNode</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">nodeTest</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">node </span><span class="s2">is </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getOriginalNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getOriginalNode</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">nodeTest</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">node </span><span class="s2">is </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Iterates through the parent chain of a node and performs the callback on each parent until the callback</span>
     <span class="s5">* returns a truthy value, then returns that value.</span>
     <span class="s5">* If no such value is found, it applies the callback until the parent pointer is undefined or the callback returns &quot;quit&quot;</span>
     <span class="s5">* At that point findAncestor returns undefined.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">findAncestor</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">: (</span><span class="s1">element</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">element </span><span class="s2">is </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">findAncestor</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">: (</span><span class="s1">element</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean </span><span class="s2">| </span><span class="s4">&quot;quit&quot;</span><span class="s2">): </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets a value indicating whether a node originated in the parse tree.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The node to test.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">isParseTreeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the original parse tree node for a node.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The original node.</span>
     <span class="s5">* </span><span class="s7">@returns </span><span class="s5">The original parse tree node if found; otherwise, undefined.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getParseTreeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the original parse tree node for a node.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The original node.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">nodeTest A callback used to ensure the correct type of parse tree node is returned.</span>
     <span class="s5">* </span><span class="s7">@returns </span><span class="s5">The original parse tree node if found; otherwise, undefined.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getParseTreeNode</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">nodeTest</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">node </span><span class="s2">is </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */</span>
    <span class="s3">function </span><span class="s1">escapeLeadingUnderscores</span><span class="s2">(</span><span class="s1">identifier</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">__String</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Remove extra underscore from escaped identifier text content.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">identifier The escaped identifier text.</span>
     <span class="s5">* </span><span class="s7">@returns </span><span class="s5">The unescaped identifier text.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">unescapeLeadingUnderscores</span><span class="s2">(</span><span class="s1">identifier</span><span class="s2">: </span><span class="s1">__String</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">idText</span><span class="s2">(</span><span class="s1">identifierOrPrivateName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PrivateIdentifier</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">symbolName</span><span class="s2">(</span><span class="s1">symbol</span><span class="s2">: </span><span class="s1">Symbol</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getNameOfJSDocTypedef</span><span class="s2">(</span><span class="s1">declaration</span><span class="s2">: </span><span class="s1">JSDocTypedefTag</span><span class="s2">): </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PrivateIdentifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getNameOfDeclaration</span><span class="s2">(</span><span class="s1">declaration</span><span class="s2">: </span><span class="s1">Declaration </span><span class="s2">| </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">DeclarationName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getDecorators</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">HasDecorators</span><span class="s2">): </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getModifiers</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">HasModifiers</span><span class="s2">): </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the JSDoc parameter tags for the node if present.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@remarks </span><span class="s5">Returns any JSDoc param tag whose name matches the provided</span>
     <span class="s5">* parameter, whether a param tag on a containing function</span>
     <span class="s5">* expression, or a param tag on a variable declaration whose</span>
     <span class="s5">* initializer is the containing function. The tags closest to the</span>
     <span class="s5">* node are returned first, so in the previous example, the param</span>
     <span class="s5">* tag on the containing function expression would be first.</span>
     <span class="s5">*</span>
     <span class="s5">* For binding patterns, parameter tags are matched by position.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getJSDocParameterTags</span><span class="s2">(</span><span class="s1">param</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">): </span><span class="s1">readonly JSDocParameterTag</span><span class="s2">[];</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the JSDoc type parameter tags for the node if present.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@remarks </span><span class="s5">Returns any JSDoc template tag whose names match the provided</span>
     <span class="s5">* parameter, whether a template tag on a containing function</span>
     <span class="s5">* expression, or a template tag on a variable declaration whose</span>
     <span class="s5">* initializer is the containing function. The tags closest to the</span>
     <span class="s5">* node are returned first, so in the previous example, the template</span>
     <span class="s5">* tag on the containing function expression would be first.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getJSDocTypeParameterTags</span><span class="s2">(</span><span class="s1">param</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">): </span><span class="s1">readonly JSDocTemplateTag</span><span class="s2">[];</span>
    <span class="s5">/**</span>
     <span class="s5">* Return true if the node has JSDoc parameter tags.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@remarks </span><span class="s5">Includes parameter tags that are not directly on the node,</span>
     <span class="s5">* for example on a variable declaration whose initializer is a function expression.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">hasJSDocParameterTags</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionLikeDeclaration </span><span class="s2">| </span><span class="s1">SignatureDeclaration</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc augments tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocAugmentsTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocAugmentsTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc implements tags for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocImplementsTags</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">readonly JSDocImplementsTag</span><span class="s2">[];</span>
    <span class="s5">/** Gets the JSDoc class tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocClassTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocClassTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc public tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocPublicTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocPublicTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc private tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocPrivateTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocPrivateTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc protected tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocProtectedTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocProtectedTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc protected tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocReadonlyTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocReadonlyTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getJSDocOverrideTagNoCache</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocOverrideTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc deprecated tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocDeprecatedTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocDeprecatedTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc enum tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocEnumTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocEnumTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc this tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocThisTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocThisTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc return tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocReturnTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocReturnTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc template tag for the node if present */</span>
    <span class="s3">function </span><span class="s1">getJSDocTemplateTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocTemplateTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Gets the JSDoc type tag for the node if present and valid */</span>
    <span class="s3">function </span><span class="s1">getJSDocTypeTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">JSDocTypeTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the type node for the node if provided via JSDoc.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@remarks </span><span class="s5">The search includes any JSDoc param tag that relates</span>
     <span class="s5">* to the provided parameter, for example a type tag on the</span>
     <span class="s5">* parameter itself, or a param tag on a containing function</span>
     <span class="s5">* expression, or a param tag on a variable declaration whose</span>
     <span class="s5">* initializer is the containing function. The tags closest to the</span>
     <span class="s5">* node are examined first, so in the previous example, the type</span>
     <span class="s5">* tag directly on the node would be returned.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getJSDocType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the return type node for the node if provided via JSDoc return tag or type tag.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@remarks </span><span class="s5">`getJSDocReturnTag` just gets the whole JSDoc tag. This function</span>
     <span class="s5">* gets the type from inside the braces, after the fat arrow, etc.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getJSDocReturnType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** Get all JSDoc tags related to a node, including those on parent nodes. */</span>
    <span class="s3">function </span><span class="s1">getJSDocTags</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">readonly JSDocTag</span><span class="s2">[];</span>
    <span class="s5">/** Gets all JSDoc tags that match a specified predicate */</span>
    <span class="s3">function </span><span class="s1">getAllJSDocTags</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">JSDocTag</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">predicate</span><span class="s2">: (</span><span class="s1">tag</span><span class="s2">: </span><span class="s1">JSDocTag</span><span class="s2">) =&gt; </span><span class="s1">tag </span><span class="s2">is </span><span class="s1">T</span><span class="s2">): </span><span class="s1">readonly T</span><span class="s2">[];</span>
    <span class="s5">/** Gets all JSDoc tags of a specified kind */</span>
    <span class="s3">function </span><span class="s1">getAllJSDocTagsOfKind</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">): </span><span class="s1">readonly JSDocTag</span><span class="s2">[];</span>
    <span class="s5">/** Gets the text of a jsdoc comment, flattening links to their text. */</span>
    <span class="s3">function </span><span class="s1">getTextOfJSDocComment</span><span class="s2">(</span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt;): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the effective type parameters. If the node was parsed in a</span>
     <span class="s5">* JavaScript file, gets the type parameters from the `@template` tag from JSDoc.</span>
     <span class="s5">*</span>
     <span class="s5">* This does *not* return type parameters from a jsdoc reference to a generic type, eg</span>
     <span class="s5">*</span>
     <span class="s5">* type Id = &lt;T&gt;(x: T) =&gt; T</span>
     <span class="s5">* /** @type {Id} /</span>
     <span class="s5">* function id(x) { return x }</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getEffectiveTypeParameterDeclarations</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">DeclarationWithTypeParameters</span><span class="s2">): </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[];</span>
    <span class="s3">function </span><span class="s1">getEffectiveConstraintOfTypeParameter</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">): </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isMemberName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">MemberName</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPropertyAccessChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PropertyAccessChain</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isElementAccessChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ElementAccessChain</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCallChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CallChain</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isOptionalChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PropertyAccessChain </span><span class="s2">| </span><span class="s1">ElementAccessChain </span><span class="s2">| </span><span class="s1">CallChain </span><span class="s2">| </span><span class="s1">NonNullChain</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNullishCoalesce</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isConstTypeReference</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">skipPartiallyEmittedExpressions</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">skipPartiallyEmittedExpressions</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">Node</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNonNullChain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NonNullChain</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isBreakOrContinueStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">BreakOrContinueStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNamedExportBindings</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NamedExportBindings</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isUnparsedTextLike</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">UnparsedTextLike</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isUnparsedNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">UnparsedNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocPropertyLikeTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocPropertyLikeTag</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* True if kind is of some token syntax kind.</span>
     <span class="s5">* For example, this is true for an IfKeyword but not for an IfStatement.</span>
     <span class="s5">* Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">isTokenKind</span><span class="s2">(</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* True if node is of some token syntax kind.</span>
     <span class="s5">* For example, this is true for an IfKeyword but not for an IfStatement.</span>
     <span class="s5">* Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">isToken</span><span class="s2">(</span><span class="s1">n</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isLiteralExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">LiteralExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateLiteralToken</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateLiteralToken</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateMiddleOrTemplateTail</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isImportOrExportSpecifier</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ImportSpecifier </span><span class="s2">| </span><span class="s1">ExportSpecifier</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeOnlyImportOrExportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeOnlyAliasDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAssertionKey</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AssertionKey</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isStringTextContainingNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">TemplateLiteralToken</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isModifier</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">Modifier</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isEntityName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">EntityName</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPropertyName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PropertyName</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isBindingName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">BindingName</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isFunctionLike</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SignatureDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isClassElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ClassElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isClassLike</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ClassLikeDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAccessor</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AccessorDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAutoAccessorPropertyDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AutoAccessorPropertyDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isModifierLike</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ModifierLike</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isClassOrTypeElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ClassElement </span><span class="s2">| </span><span class="s1">TypeElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isObjectLiteralElementLike</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ObjectLiteralElementLike</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Node test that determines whether a node is a valid type node.</span>
     <span class="s5">* This differs from the `isPartOfTypeNode` function which determines whether a node is *part*</span>
     <span class="s5">* of a TypeNode.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">isTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isFunctionOrConstructorTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">FunctionTypeNode </span><span class="s2">| </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPropertyAccessOrQualifiedName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PropertyAccessExpression </span><span class="s2">| </span><span class="s1">QualifiedName</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCallLikeExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CallLikeExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCallOrNewExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CallExpression </span><span class="s2">| </span><span class="s1">NewExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateLiteral</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateLiteral</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAssertionExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AssertionExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIterationStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">lookInLabeledStatements</span><span class="s2">: </span><span class="s3">false</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">IterationStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIterationStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">lookInLabeledStatements</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">IterationStatement </span><span class="s2">| </span><span class="s1">LabeledStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxOpeningLikeElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxOpeningLikeElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCaseOrDefaultClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CaseOrDefaultClause</span><span class="s2">;</span>
    <span class="s5">/** True if node is of a kind that may contain comment text. */</span>
    <span class="s3">function </span><span class="s1">isJSDocCommentContainingNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSetAccessor</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isGetAccessor</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s5">/** True if has initializer node attached to it. */</span>
    <span class="s3">function </span><span class="s1">hasOnlyExpressionInitializer</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">HasExpressionInitializer</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isObjectLiteralElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ObjectLiteralElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isStringLiteralLike</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">StringLiteralLike</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocLinkLike</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocLink </span><span class="s2">| </span><span class="s1">JSDocLinkCode </span><span class="s2">| </span><span class="s1">JSDocLinkPlain</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">hasRestParameter</span><span class="s2">(</span><span class="s1">s</span><span class="s2">: </span><span class="s1">SignatureDeclaration </span><span class="s2">| </span><span class="s1">JSDocSignature</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isRestParameter</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParameterDeclaration </span><span class="s2">| </span><span class="s1">JSDocParameterTag</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">const </span><span class="s1">factory</span><span class="s2">: </span><span class="s1">NodeFactory</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createUnparsedSourceFile</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createUnparsedSourceFile</span><span class="s2">(</span><span class="s1">inputFile</span><span class="s2">: </span><span class="s1">InputFiles</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s4">&quot;js&quot; </span><span class="s2">| </span><span class="s4">&quot;dts&quot;</span><span class="s2">, </span><span class="s1">stripInternal</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createUnparsedSourceFile</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">mapPath</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">map</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createInputFiles</span><span class="s2">(</span><span class="s1">javascriptText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">declarationText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">InputFiles</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createInputFiles</span><span class="s2">(</span><span class="s1">readFileText</span><span class="s2">: (</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">javascriptPath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">javascriptMapPath</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">declarationPath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">declarationMapPath</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">buildInfoPath</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">InputFiles</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createInputFiles</span><span class="s2">(</span><span class="s1">javascriptText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">declarationText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">javascriptMapPath</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">javascriptMapText</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">declarationMapPath</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">declarationMapText</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">InputFiles</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Create an external source map source file reference</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">createSourceMapSource</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">skipTrivia</span><span class="s2">?: (</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">) =&gt; </span><span class="s1">number</span><span class="s2">): </span><span class="s1">SourceMapSource</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">setOriginalNode</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">original</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/**</span>
     <span class="s5">* Clears any `EmitNode` entries from parse-tree nodes.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">sourceFile A source file.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">disposeEmitNodes</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Sets flags that control emit behavior of a node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">setEmitFlags</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">emitFlags</span><span class="s2">: </span><span class="s1">EmitFlags</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets a custom text range to use when emitting source maps.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getSourceMapRange</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">SourceMapRange</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Sets a custom text range to use when emitting source maps.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">setSourceMapRange</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">range</span><span class="s2">: </span><span class="s1">SourceMapRange </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the TextRange to use for source maps for a token of a node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getTokenSourceMapRange</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">): </span><span class="s1">SourceMapRange </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Sets the TextRange to use for source maps for a token of a node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">setTokenSourceMapRange</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">, </span><span class="s1">range</span><span class="s2">: </span><span class="s1">SourceMapRange </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets a custom text range to use when emitting comments.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getCommentRange</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">TextRange</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Sets a custom text range to use when emitting comments.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">setCommentRange</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">range</span><span class="s2">: </span><span class="s1">TextRange</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getSyntheticLeadingComments</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">SynthesizedComment</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">setSyntheticLeadingComments</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">comments</span><span class="s2">: </span><span class="s1">SynthesizedComment</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">addSyntheticLeadingComment</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SingleLineCommentTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MultiLineCommentTrivia</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">hasTrailingNewLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getSyntheticTrailingComments</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">SynthesizedComment</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">setSyntheticTrailingComments</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">comments</span><span class="s2">: </span><span class="s1">SynthesizedComment</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">addSyntheticTrailingComment</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">SingleLineCommentTrivia </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">MultiLineCommentTrivia</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">hasTrailingNewLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">moveSyntheticComments</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">original</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the constant value to emit for an expression representing an enum.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getConstantValue</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">AccessExpression</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Sets the constant value to emit for an expression.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">setConstantValue</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">AccessExpression</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s2">): </span><span class="s1">AccessExpression</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Adds an EmitHelper to a node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">addEmitHelper</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">: </span><span class="s1">EmitHelper</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Add EmitHelpers to a node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">addEmitHelpers</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">helpers</span><span class="s2">: </span><span class="s1">EmitHelper</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Removes an EmitHelper from a node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">removeEmitHelper</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">helper</span><span class="s2">: </span><span class="s1">EmitHelper</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Gets the EmitHelpers of a node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getEmitHelpers</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">EmitHelper</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Moves matching emit helpers from a source node to a target node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">moveEmitHelpers</span><span class="s2">(</span><span class="s1">source</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">target</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">predicate</span><span class="s2">: (</span><span class="s1">helper</span><span class="s2">: </span><span class="s1">EmitHelper</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">function </span><span class="s1">isNumericLiteral</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NumericLiteral</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isBigIntLiteral</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">BigIntLiteral</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isStringLiteral</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">StringLiteral</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxText</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxText</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isRegularExpressionLiteral</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">RegularExpressionLiteral</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNoSubstitutionTemplateLiteral</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateHead</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateHead</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateMiddle</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateMiddle</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateTail</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateTail</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isDotDotDotToken</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">DotDotDotToken</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPlusToken</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PlusToken</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isMinusToken</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">MinusToken</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAsteriskToken</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AsteriskToken</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIdentifier</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPrivateIdentifier</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PrivateIdentifier</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isQualifiedName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">QualifiedName</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isComputedPropertyName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ComputedPropertyName</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeParameterDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isParameter</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isDecorator</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">Decorator</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPropertySignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PropertySignature</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPropertyDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isMethodSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">MethodSignature</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isMethodDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isClassStaticBlockDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ClassStaticBlockDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isConstructorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isGetAccessorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSetAccessorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCallSignatureDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CallSignatureDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isConstructSignatureDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ConstructSignatureDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIndexSignatureDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypePredicateNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypePredicateNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeReferenceNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeReferenceNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isFunctionTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">FunctionTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isConstructorTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeQueryNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeQueryNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeLiteralNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeLiteralNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isArrayTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ArrayTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTupleTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TupleTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNamedTupleMember</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NamedTupleMember</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isOptionalTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">OptionalTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isRestTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">RestTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isUnionTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">UnionTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIntersectionTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">IntersectionTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isConditionalTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ConditionalTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isInferTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">InferTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isParenthesizedTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ParenthesizedTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isThisTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ThisTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeOperatorNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeOperatorNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIndexedAccessTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">IndexedAccessTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isMappedTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">MappedTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isLiteralTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">LiteralTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isImportTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateLiteralTypeSpan</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateLiteralTypeSpan</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateLiteralTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateLiteralTypeNode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isObjectBindingPattern</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ObjectBindingPattern</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isArrayBindingPattern</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ArrayBindingPattern</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isBindingElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">BindingElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isArrayLiteralExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isObjectLiteralExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPropertyAccessExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PropertyAccessExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isElementAccessExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ElementAccessExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCallExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CallExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNewExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NewExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTaggedTemplateExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TaggedTemplateExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeAssertionExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeAssertion</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isParenthesizedExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ParenthesizedExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isFunctionExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">FunctionExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isArrowFunction</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isDeleteExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">DeleteExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeOfExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeOfExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isVoidExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">VoidExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAwaitExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AwaitExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPrefixUnaryExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPostfixUnaryExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isBinaryExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isConditionalExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ConditionalExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isYieldExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">YieldExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSpreadElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SpreadElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isClassExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ClassExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isOmittedExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">OmittedExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isExpressionWithTypeArguments</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAsExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AsExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSatisfiesExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SatisfiesExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNonNullExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NonNullExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isMetaProperty</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">MetaProperty</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSyntheticExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SyntheticExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPartiallyEmittedExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PartiallyEmittedExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCommaListExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CommaListExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTemplateSpan</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TemplateSpan</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSemicolonClassElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SemicolonClassElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isBlock</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">Block</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isVariableStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">VariableStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isEmptyStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">EmptyStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isExpressionStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ExpressionStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isIfStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">IfStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isDoStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">DoStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isWhileStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">WhileStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isForStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ForStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isForInStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ForInStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isForOfStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ForOfStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isContinueStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ContinueStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isBreakStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">BreakStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isReturnStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ReturnStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isWithStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">WithStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSwitchStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SwitchStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isLabeledStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">LabeledStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isThrowStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ThrowStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTryStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TryStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isDebuggerStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">DebuggerStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isVariableDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isVariableDeclarationList</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">VariableDeclarationList</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isFunctionDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isClassDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isInterfaceDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isTypeAliasDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isEnumDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isModuleDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isModuleBlock</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ModuleBlock</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCaseBlock</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CaseBlock</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNamespaceExportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NamespaceExportDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isImportEqualsDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isImportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isImportClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ImportClause</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isImportTypeAssertionContainer</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ImportTypeAssertionContainer</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAssertClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AssertClause</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isAssertEntry</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">AssertEntry</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNamespaceImport</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NamespaceImport</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNamespaceExport</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NamespaceExport</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNamedImports</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NamedImports</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isImportSpecifier</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ImportSpecifier</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isExportAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isExportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNamedExports</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NamedExports</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isExportSpecifier</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ExportSpecifier</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isMissingDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">MissingDeclaration</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isNotEmittedStatement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">NotEmittedStatement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isExternalModuleReference</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ExternalModuleReference</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxSelfClosingElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxSelfClosingElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxOpeningElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxOpeningElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxClosingElement</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxClosingElement</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxFragment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxFragment</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxOpeningFragment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxOpeningFragment</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxClosingFragment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxClosingFragment</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxAttribute</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxAttribute</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxAttributes</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxSpreadAttribute</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxSpreadAttribute</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJsxExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JsxExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCaseClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CaseClause</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isDefaultClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">DefaultClause</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isHeritageClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">HeritageClause</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isCatchClause</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">CatchClause</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isPropertyAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">PropertyAssignment</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isShorthandPropertyAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">ShorthandPropertyAssignment</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSpreadAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SpreadAssignment</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isEnumMember</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">EnumMember</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isUnparsedPrepend</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">UnparsedPrepend</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isSourceFile</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">SourceFile</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isBundle</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">Bundle</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isUnparsedSource</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">UnparsedSource</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocTypeExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocNameReference</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocNameReference</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocMemberName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocMemberName</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocLink</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocLink</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocLinkCode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocLinkCode</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocLinkPlain</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocLinkPlain</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocAllType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocAllType</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocUnknownType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocUnknownType</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocNullableType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocNullableType</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocNonNullableType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocNonNullableType</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocOptionalType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocOptionalType</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocFunctionType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocFunctionType</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocVariadicType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocVariadicType</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocNamepathType</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocNamepathType</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDoc</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDoc</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocTypeLiteral</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocTypeLiteral</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocSignature</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocAugmentsTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocAugmentsTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocAuthorTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocAuthorTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocClassTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocClassTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocCallbackTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocCallbackTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocPublicTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocPublicTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocPrivateTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocPrivateTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocProtectedTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocProtectedTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocReadonlyTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocReadonlyTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocOverrideTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocOverrideTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocDeprecatedTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocDeprecatedTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocSeeTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocSeeTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocEnumTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocEnumTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocParameterTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocParameterTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocReturnTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocReturnTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocThisTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocThisTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocTypeTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocTypeTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocTemplateTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocTemplateTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocTypedefTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocTypedefTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocUnknownTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocUnknownTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocPropertyTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocPropertyTag</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">isJSDocImplementsTag</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">JSDocImplementsTag</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">function </span><span class="s1">setTextRange</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">TextRange</span><span class="s2">&gt;(</span><span class="s1">range</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">location</span><span class="s2">: </span><span class="s1">TextRange </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">canHaveModifiers</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">HasModifiers</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">canHaveDecorators</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">): </span><span class="s1">node </span><span class="s2">is </span><span class="s1">HasDecorators</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/**</span>
     <span class="s5">* Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes</span>
     <span class="s5">* stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,</span>
     <span class="s5">* embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns</span>
     <span class="s5">* a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">node a given node to visit its children</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">cbNode a callback to be invoked for all child nodes</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">cbNodes a callback to be invoked for embedded array</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@remarks </span><span class="s5">`forEachChild` must visit the children of a node in the order</span>
     <span class="s5">* that they appear in the source code. The language service depends on this property to locate nodes by position.</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">forEachChild</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">, </span><span class="s1">cbNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">cbNodes</span><span class="s2">?: (</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Node</span><span class="s2">&gt;) =&gt; </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">CreateSourceFileOptions </span><span class="s2">{</span>
        <span class="s1">languageVersion</span><span class="s2">: </span><span class="s1">ScriptTarget</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Controls the format the file is detected as - this can be derived from only the path</span>
         <span class="s5">* and files on disk, but needs to be done with a module resolution cache in scope to be performant.</span>
         <span class="s5">* This is usually `undefined` for compilations that do not have `moduleResolution` values of `node16` or `nodenext`.</span>
         <span class="s5">*/</span>
        <span class="s1">impliedNodeFormat</span><span class="s2">?: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Controls how module-y-ness is set for the given file. Usually the result of calling</span>
         <span class="s5">* `getSetExternalModuleIndicator` on a valid `CompilerOptions` object. If not present, the default</span>
         <span class="s5">* check specified by `isFileProbablyExternalModule` will be used to set the field.</span>
         <span class="s5">*/</span>
        <span class="s1">setExternalModuleIndicator</span><span class="s2">?: (</span><span class="s1">file</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export function </span><span class="s1">createSourceFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">sourceText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">languageVersionOrOptions</span><span class="s2">: </span><span class="s1">ScriptTarget </span><span class="s2">| </span><span class="s1">CreateSourceFileOptions</span><span class="s2">, </span><span class="s1">setParentNodes</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">parseIsolatedEntityName</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">languageVersion</span><span class="s2">: </span><span class="s1">ScriptTarget</span><span class="s2">): </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Parse json text into SyntaxTree and return node and parse errors if any</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">sourceText</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">parseJsonText</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">sourceText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">JsonSourceFile</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">isExternalModule</span><span class="s2">(</span><span class="s1">file</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">updateSourceFile</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">newText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">textChangeRange</span><span class="s2">: </span><span class="s1">TextChangeRange</span><span class="s2">, </span><span class="s1">aggressiveChecks</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s2">{};</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">export function </span><span class="s1">parseCommandLine</span><span class="s2">(</span><span class="s1">commandLine</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">readFile</span><span class="s2">?: (</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ParsedCommandLine</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s1">type DiagnosticReporter </span><span class="s2">= (</span><span class="s1">diagnostic</span><span class="s2">: </span><span class="s1">Diagnostic</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Reports config file diagnostics</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">ConfigFileDiagnosticsReporter </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Reports unrecoverable error when parsing config file</span>
         <span class="s5">*/</span>
        <span class="s1">onUnRecoverableConfigFileDiagnostic</span><span class="s2">: </span><span class="s1">DiagnosticReporter</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Interface extending ParseConfigHost to support ParseConfigFile that reads config file and reports errors</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">ParseConfigFileHost </span><span class="s3">extends </span><span class="s1">ParseConfigHost</span><span class="s2">, </span><span class="s1">ConfigFileDiagnosticsReporter </span><span class="s2">{</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Reads the config file, reports errors if any and exits if the config file cannot be found</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">getParsedCommandLineOfConfigFile</span><span class="s2">(</span><span class="s1">configFileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">optionsToExtend</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ParseConfigFileHost</span><span class="s2">, </span><span class="s1">extendedConfigCache</span><span class="s2">?: </span><span class="s1">Map</span><span class="s2">&lt;</span><span class="s1">ExtendedConfigCacheEntry</span><span class="s2">&gt;, </span><span class="s1">watchOptionsToExtend</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">, </span><span class="s1">extraFileExtensions</span><span class="s2">?: </span><span class="s1">readonly FileExtensionInfo</span><span class="s2">[]): </span><span class="s1">ParsedCommandLine </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Read tsconfig.json file</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The path to the config file</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">readConfigFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">readFile</span><span class="s2">: (</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): {</span>
        <span class="s1">config</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">error</span><span class="s2">?: </span><span class="s1">Diagnostic</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/**</span>
     <span class="s5">* Parse the text of the tsconfig.json file</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The path to the config file</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">jsonText The text of the config file</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">parseConfigFileTextToJson</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">jsonText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): {</span>
        <span class="s1">config</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">error</span><span class="s2">?: </span><span class="s1">Diagnostic</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/**</span>
     <span class="s5">* Read tsconfig.json file</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The path to the config file</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">readJsonConfigFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">readFile</span><span class="s2">: (</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TsConfigSourceFile</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Convert the json syntax tree into the json value</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">convertToObject</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">JsonSourceFile</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">: </span><span class="s1">Push</span><span class="s2">&lt;</span><span class="s1">Diagnostic</span><span class="s2">&gt;): </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Parse the contents of a config file (tsconfig.json).</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">json The contents of the config file to parse</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">host Instance of ParseConfigHost used to enumerate files in folder.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">basePath A root directory to resolve relative path entries in the config</span>
     <span class="s5">*    file to. e.g. outDir</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">parseJsonConfigFileContent</span><span class="s2">(</span><span class="s1">json</span><span class="s2">: </span><span class="s1">any</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ParseConfigHost</span><span class="s2">, </span><span class="s1">basePath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">existingOptions</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">configFileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">resolutionStack</span><span class="s2">?: </span><span class="s1">Path</span><span class="s2">[], </span><span class="s1">extraFileExtensions</span><span class="s2">?: </span><span class="s1">readonly FileExtensionInfo</span><span class="s2">[], </span><span class="s1">extendedConfigCache</span><span class="s2">?: </span><span class="s1">Map</span><span class="s2">&lt;</span><span class="s1">ExtendedConfigCacheEntry</span><span class="s2">&gt;, </span><span class="s1">existingWatchOptions</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">): </span><span class="s1">ParsedCommandLine</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Parse the contents of a config file (tsconfig.json).</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">jsonNode The contents of the config file to parse</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">host Instance of ParseConfigHost used to enumerate files in folder.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">basePath A root directory to resolve relative path entries in the config</span>
     <span class="s5">*    file to. e.g. outDir</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">parseJsonSourceFileConfigFileContent</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">TsConfigSourceFile</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ParseConfigHost</span><span class="s2">, </span><span class="s1">basePath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">existingOptions</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">configFileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">resolutionStack</span><span class="s2">?: </span><span class="s1">Path</span><span class="s2">[], </span><span class="s1">extraFileExtensions</span><span class="s2">?: </span><span class="s1">readonly FileExtensionInfo</span><span class="s2">[], </span><span class="s1">extendedConfigCache</span><span class="s2">?: </span><span class="s1">Map</span><span class="s2">&lt;</span><span class="s1">ExtendedConfigCacheEntry</span><span class="s2">&gt;, </span><span class="s1">existingWatchOptions</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">): </span><span class="s1">ParsedCommandLine</span><span class="s2">;</span>
    <span class="s3">export interface </span><span class="s1">ParsedTsconfig </span><span class="s2">{</span>
        <span class="s1">raw</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">options</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">watchOptions</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">;</span>
        <span class="s1">typeAcquisition</span><span class="s2">?: </span><span class="s1">TypeAcquisition</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Note that the case of the config path has not yet been normalized, as no files have been imported into the project yet</span>
         <span class="s5">*/</span>
        <span class="s1">extendedConfigPath</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ExtendedConfigCacheEntry </span><span class="s2">{</span>
        <span class="s1">extendedResult</span><span class="s2">: </span><span class="s1">TsConfigSourceFile</span><span class="s2">;</span>
        <span class="s1">extendedConfig</span><span class="s2">: </span><span class="s1">ParsedTsconfig </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export function </span><span class="s1">convertCompilerOptionsFromJson</span><span class="s2">(</span><span class="s1">jsonOptions</span><span class="s2">: </span><span class="s1">any</span><span class="s2">, </span><span class="s1">basePath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">configFileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): {</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s1">Diagnostic</span><span class="s2">[];</span>
    <span class="s2">};</span>
    <span class="s3">export function </span><span class="s1">convertTypeAcquisitionFromJson</span><span class="s2">(</span><span class="s1">jsonOptions</span><span class="s2">: </span><span class="s1">any</span><span class="s2">, </span><span class="s1">basePath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">configFileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): {</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s1">TypeAcquisition</span><span class="s2">;</span>
        <span class="s1">errors</span><span class="s2">: </span><span class="s1">Diagnostic</span><span class="s2">[];</span>
    <span class="s2">};</span>
    <span class="s3">export </span><span class="s2">{};</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">export function </span><span class="s1">getEffectiveTypeRoots</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">GetEffectiveTypeRootsHost</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">{string | undefined} containingFile - file that contains type reference directive, can be undefined if containing file is unknown.</span>
     <span class="s5">* This is possible in case if resolution is performed for directives specified via 'types' parameter. In this case initial path for secondary lookups</span>
     <span class="s5">* is assumed to be the same as root directory of the project.</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">resolveTypeReferenceDirective</span><span class="s2">(</span><span class="s1">typeReferenceDirectiveName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ModuleResolutionHost</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">?: </span><span class="s1">ResolvedProjectReference</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">?: </span><span class="s1">TypeReferenceDirectiveResolutionCache</span><span class="s2">, </span><span class="s1">resolutionMode</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">]): </span><span class="s1">ResolvedTypeReferenceDirectiveWithFailedLookupLocations</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Given a set of options, returns the set of type directive names</span>
     <span class="s5">*   that should be included for this program automatically.</span>
     <span class="s5">* This list could either come from the config file,</span>
     <span class="s5">*   or from enumerating the types root + initial secondary types lookup location.</span>
     <span class="s5">* More type directives might appear in the program later as a result of loading actual source files;</span>
     <span class="s5">*   this list is only the set of defaults that are implicitly included.</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">getAutomaticTypeDirectiveNames</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ModuleResolutionHost</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
    <span class="s3">export interface </span><span class="s1">TypeReferenceDirectiveResolutionCache </span><span class="s3">extends </span><span class="s1">PerDirectoryResolutionCache</span><span class="s2">&lt;</span><span class="s1">ResolvedTypeReferenceDirectiveWithFailedLookupLocations</span><span class="s2">&gt;, </span><span class="s1">PackageJsonInfoCache </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ModeAwareCache</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s1">get</span><span class="s2">(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">set</span><span class="s2">(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">value</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s3">this</span><span class="s2">;</span>
        <span class="s3">delete</span><span class="s2">(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s3">this</span><span class="s2">;</span>
        <span class="s1">has</span><span class="s2">(</span><span class="s1">key</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">forEach</span><span class="s2">(</span><span class="s1">cb</span><span class="s2">: (</span><span class="s1">elem</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">size</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Cached resolutions per containing directory.</span>
     <span class="s5">* This assumes that any module id will have the same resolution for sibling files located in the same folder.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">PerDirectoryResolutionCache</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s1">getOrCreateCacheForDirectory</span><span class="s2">(</span><span class="s1">directoryName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">?: </span><span class="s1">ResolvedProjectReference</span><span class="s2">): </span><span class="s1">ModeAwareCache</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
        <span class="s1">clear</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">*  Updates with the current compilerOptions the cache will operate with.</span>
         <span class="s5">*  This updates the redirects map as well if needed so module resolutions are cached if they can across the projects</span>
         <span class="s5">*/</span>
        <span class="s1">update</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">ModuleResolutionCache </span><span class="s3">extends </span><span class="s1">PerDirectoryResolutionCache</span><span class="s2">&lt;</span><span class="s1">ResolvedModuleWithFailedLookupLocations</span><span class="s2">&gt;, </span><span class="s1">NonRelativeModuleNameResolutionCache</span><span class="s2">, </span><span class="s1">PackageJsonInfoCache </span><span class="s2">{</span>
        <span class="s1">getPackageJsonInfoCache</span><span class="s2">(): </span><span class="s1">PackageJsonInfoCache</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Stored map from non-relative module name to a table: directory -&gt; result of module lookup in this directory</span>
     <span class="s5">* We support only non-relative module names because resolution of relative module names is usually more deterministic and thus less expensive.</span>
     <span class="s5">*/</span>
    <span class="s3">export interface </span><span class="s1">NonRelativeModuleNameResolutionCache </span><span class="s3">extends </span><span class="s1">PackageJsonInfoCache </span><span class="s2">{</span>
        <span class="s1">getOrCreateCacheForModuleName</span><span class="s2">(</span><span class="s1">nonRelativeModuleName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">?: </span><span class="s1">ResolvedProjectReference</span><span class="s2">): </span><span class="s1">PerModuleNameCache</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PackageJsonInfoCache </span><span class="s2">{</span>
        <span class="s1">clear</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export interface </span><span class="s1">PerModuleNameCache </span><span class="s2">{</span>
        <span class="s1">get</span><span class="s2">(</span><span class="s1">directory</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ResolvedModuleWithFailedLookupLocations </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">set</span><span class="s2">(</span><span class="s1">directory</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">result</span><span class="s2">: </span><span class="s1">ResolvedModuleWithFailedLookupLocations</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export function </span><span class="s1">createModuleResolutionCache</span><span class="s2">(</span><span class="s1">currentDirectory</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">getCanonicalFileName</span><span class="s2">: (</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">string</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">ModuleResolutionCache</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">createTypeReferenceDirectiveResolutionCache</span><span class="s2">(</span><span class="s1">currentDirectory</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">getCanonicalFileName</span><span class="s2">: (</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">string</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">packageJsonInfoCache</span><span class="s2">?: </span><span class="s1">PackageJsonInfoCache</span><span class="s2">): </span><span class="s1">TypeReferenceDirectiveResolutionCache</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">resolveModuleNameFromCache</span><span class="s2">(</span><span class="s1">moduleName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">: </span><span class="s1">ModuleResolutionCache</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">?: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext</span><span class="s2">): </span><span class="s1">ResolvedModuleWithFailedLookupLocations </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">resolveModuleName</span><span class="s2">(</span><span class="s1">moduleName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">compilerOptions</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ModuleResolutionHost</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">?: </span><span class="s1">ModuleResolutionCache</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">?: </span><span class="s1">ResolvedProjectReference</span><span class="s2">, </span><span class="s1">resolutionMode</span><span class="s2">?: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext</span><span class="s2">): </span><span class="s1">ResolvedModuleWithFailedLookupLocations</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">nodeModuleNameResolver</span><span class="s2">(</span><span class="s1">moduleName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">compilerOptions</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ModuleResolutionHost</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">?: </span><span class="s1">ModuleResolutionCache</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">?: </span><span class="s1">ResolvedProjectReference</span><span class="s2">): </span><span class="s1">ResolvedModuleWithFailedLookupLocations</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">classicNameResolver</span><span class="s2">(</span><span class="s1">moduleName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">compilerOptions</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ModuleResolutionHost</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">?: </span><span class="s1">NonRelativeModuleNameResolutionCache</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">?: </span><span class="s1">ResolvedProjectReference</span><span class="s2">): </span><span class="s1">ResolvedModuleWithFailedLookupLocations</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s2">{};</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/**</span>
     <span class="s5">* Visits a Node using the supplied visitor, possibly returning a new Node in its place.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The Node to visit.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">visitor The callback used to visit the Node.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">test A callback to execute to verify the Node is valid.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">lift An optional callback to execute to lift a NodeArray into a valid Node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitNode</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">test</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">lift</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">readonly Node</span><span class="s2">[]) =&gt; </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Visits a Node using the supplied visitor, possibly returning a new Node in its place.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The Node to visit.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">visitor The callback used to visit the Node.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">test A callback to execute to verify the Node is valid.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">lift An optional callback to execute to lift a NodeArray into a valid Node.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitNode</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">test</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">lift</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">readonly Node</span><span class="s2">[]) =&gt; </span><span class="s1">T</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">nodes The NodeArray to visit.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">visitor The callback used to visit a Node.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">test A node test to execute for each node.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">start An optional value indicating the starting offset at which to start visiting.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">count An optional value indicating the maximum number of nodes to visit.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitNodes</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">test</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">start</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">count</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s5">/**</span>
     <span class="s5">* Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">nodes The NodeArray to visit.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">visitor The callback used to visit a Node.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">test A node test to execute for each node.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">start An optional value indicating the starting offset at which to start visiting.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">count An optional value indicating the maximum number of nodes to visit.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitNodes</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">test</span><span class="s2">?: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">start</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">count</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Starts a new lexical environment and visits a statement list, ending the lexical environment</span>
     <span class="s5">* and merging hoisted declarations upon completion.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitLexicalEnvironment</span><span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Statement</span><span class="s2">&gt;, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">, </span><span class="s1">start</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">ensureUseStrict</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">nodesVisitor</span><span class="s2">?: </span><span class="s1">NodesVisitor</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Statement</span><span class="s2">&gt;;</span>
    <span class="s5">/**</span>
     <span class="s5">* Starts a new lexical environment and visits a parameter list, suspending the lexical</span>
     <span class="s5">* environment upon completion.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitParameterList</span><span class="s2">(</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">, </span><span class="s1">nodesVisitor</span><span class="s2">?: </span><span class="s1">NodesVisitor</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;;</span>
    <span class="s3">function </span><span class="s1">visitParameterList</span><span class="s2">(</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">, </span><span class="s1">nodesVisitor</span><span class="s2">?: </span><span class="s1">NodesVisitor</span><span class="s2">): </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Resumes a suspended lexical environment and visits a function body, ending the lexical</span>
     <span class="s5">* environment and merging hoisted declarations upon completion.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitFunctionBody</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionBody</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">): </span><span class="s1">FunctionBody</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Resumes a suspended lexical environment and visits a function body, ending the lexical</span>
     <span class="s5">* environment and merging hoisted declarations upon completion.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitFunctionBody</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">): </span><span class="s1">FunctionBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Resumes a suspended lexical environment and visits a concise body, ending the lexical</span>
     <span class="s5">* environment and merging hoisted declarations upon completion.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitFunctionBody</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConciseBody</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">): </span><span class="s1">ConciseBody</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Visits an iteration body, adding any block-scoped variables required by the transformation.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitIterationBody</span><span class="s2">(</span><span class="s1">body</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">): </span><span class="s1">Statement</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The Node whose children will be visited.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">visitor The callback used to visit each child.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">context A lexical environment context for the visitor.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitEachChild</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Visits each child of a Node using the supplied visitor, possibly returning a new Node of the same kind in its place.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">node The Node whose children will be visited.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">visitor The callback used to visit each child.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">context A lexical environment context for the visitor.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">visitEachChild</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">visitor</span><span class="s2">: </span><span class="s1">Visitor</span><span class="s2">, </span><span class="s1">context</span><span class="s2">: </span><span class="s1">TransformationContext</span><span class="s2">, </span><span class="s1">nodesVisitor</span><span class="s2">?: </span><span class="s3">typeof </span><span class="s1">visitNodes</span><span class="s2">, </span><span class="s1">tokenVisitor</span><span class="s2">?: </span><span class="s1">Visitor</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">function </span><span class="s1">getTsBuildInfoEmitOutputFilePath</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getOutputFileNames</span><span class="s2">(</span><span class="s1">commandLine</span><span class="s2">: </span><span class="s1">ParsedCommandLine</span><span class="s2">, </span><span class="s1">inputFileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">ignoreCase</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">readonly string</span><span class="s2">[];</span>
    <span class="s3">function </span><span class="s1">createPrinter</span><span class="s2">(</span><span class="s1">printerOptions</span><span class="s2">?: </span><span class="s1">PrinterOptions</span><span class="s2">, </span><span class="s1">handlers</span><span class="s2">?: </span><span class="s1">PrintHandlers</span><span class="s2">): </span><span class="s1">Printer</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">export function </span><span class="s1">findConfigFile</span><span class="s2">(</span><span class="s1">searchPath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">fileExists</span><span class="s2">: (</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">configName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">resolveTripleslashReference</span><span class="s2">(</span><span class="s1">moduleName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">createCompilerHost</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">setParentNodes</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">CompilerHost</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">getPreEmitDiagnostics</span><span class="s2">(</span><span class="s1">program</span><span class="s2">: </span><span class="s1">Program</span><span class="s2">, </span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
    <span class="s3">export interface </span><span class="s1">FormatDiagnosticsHost </span><span class="s2">{</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getCanonicalFileName</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getNewLine</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">export function </span><span class="s1">formatDiagnostics</span><span class="s2">(</span><span class="s1">diagnostics</span><span class="s2">: </span><span class="s1">readonly Diagnostic</span><span class="s2">[], </span><span class="s1">host</span><span class="s2">: </span><span class="s1">FormatDiagnosticsHost</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">formatDiagnostic</span><span class="s2">(</span><span class="s1">diagnostic</span><span class="s2">: </span><span class="s1">Diagnostic</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">FormatDiagnosticsHost</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">formatDiagnosticsWithColorAndContext</span><span class="s2">(</span><span class="s1">diagnostics</span><span class="s2">: </span><span class="s1">readonly Diagnostic</span><span class="s2">[], </span><span class="s1">host</span><span class="s2">: </span><span class="s1">FormatDiagnosticsHost</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">flattenDiagnosticMessageText</span><span class="s2">(</span><span class="s1">diag</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">DiagnosticMessageChain </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">newLine</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Calculates the resulting resolution mode for some reference in some file - this is generally the explicitly</span>
     <span class="s5">* provided resolution mode in the reference, unless one is not present, in which case it is the mode of the containing file.</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">getModeForFileReference</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">: </span><span class="s1">FileReference </span><span class="s2">| </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containingFileMode</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">]): </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Calculates the final resolution mode for an import at some index within a file's imports list. This is generally the explicitly</span>
     <span class="s5">* defined mode of the import if provided, or, if not, the mode of the containing file (with some exceptions: import=require is always commonjs, dynamic import is always esm).</span>
     <span class="s5">* If you have an actual import node, prefer using getModeForUsageLocation on the reference string node.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">file File to fetch the resolution mode within</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">index Index into the file's complete resolution list to get the resolution of - this is a concatenation of the file's imports and module augmentations</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">getModeForResolutionAtIndex</span><span class="s2">(</span><span class="s1">file</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Calculates the final resolution mode for a given module reference node. This is generally the explicitly provided resolution mode, if</span>
     <span class="s5">* one exists, or the mode of the containing source file. (Excepting import=require, which is always commonjs, and dynamic import, which is always esm).</span>
     <span class="s5">* Notably, this function always returns `undefined` if the containing file has an `undefined` `impliedNodeFormat` - this field is only set when</span>
     <span class="s5">* `moduleResolution` is `node16`+.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">file The file the import or import-like reference is contained within</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">usage The module reference string</span>
     <span class="s5">* </span><span class="s7">@returns </span><span class="s5">The final resolution mode of the import</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">getModeForUsageLocation</span><span class="s2">(</span><span class="s1">file</span><span class="s2">: {</span>
        <span class="s1">impliedNodeFormat</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">];</span>
    <span class="s2">}, </span><span class="s1">usage</span><span class="s2">: </span><span class="s1">StringLiteralLike</span><span class="s2">): </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">export function </span><span class="s1">getConfigFileParsingDiagnostics</span><span class="s2">(</span><span class="s1">configFileParseResult</span><span class="s2">: </span><span class="s1">ParsedCommandLine</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
    <span class="s5">/**</span>
     <span class="s5">* A function for determining if a given file is esm or cjs format, assuming modern node module resolution rules, as configured by the</span>
     <span class="s5">* `options` parameter.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The normalized absolute path to check the format of (it need not exist on disk)</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">[packageJsonInfoCache] A cache for package file lookups - it's best to have a cache when this function is called often</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">host The ModuleResolutionHost which can perform the filesystem lookups for package json data</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">options The compiler options to perform the analysis under - relevant options are `moduleResolution` and `traceResolution`</span>
     <span class="s5">* </span><span class="s7">@returns </span><span class="s5">`undefined` if the path has no relevant implied format, `ModuleKind.ESNext` for esm format, and `ModuleKind.CommonJS` for cjs format</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">getImpliedNodeFormatForFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">packageJsonInfoCache</span><span class="s2">: </span><span class="s1">PackageJsonInfoCache </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ModuleResolutionHost</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'</span>
     <span class="s5">* that represent a compilation unit.</span>
     <span class="s5">*</span>
     <span class="s5">* Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and</span>
     <span class="s5">* triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">createProgramOptions - The options for creating a program.</span>
     <span class="s5">* </span><span class="s7">@returns </span><span class="s5">A 'Program' object.</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">createProgram</span><span class="s2">(</span><span class="s1">createProgramOptions</span><span class="s2">: </span><span class="s1">CreateProgramOptions</span><span class="s2">): </span><span class="s1">Program</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Create a new 'Program' instance. A Program is an immutable collection of 'SourceFile's and a 'CompilerOptions'</span>
     <span class="s5">* that represent a compilation unit.</span>
     <span class="s5">*</span>
     <span class="s5">* Creating a program proceeds from a set of root files, expanding the set of inputs by following imports and</span>
     <span class="s5">* triple-slash-reference-path directives transitively. '@types' and triple-slash-reference-types are also pulled in.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">rootNames - A set of root files.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">options - The compiler options which should be used.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">host - The host interacts with the underlying file system.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">oldProgram - Reuses an old program structure.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">configFileParsingDiagnostics - error during config file parsing</span>
     <span class="s5">* </span><span class="s7">@returns </span><span class="s5">A 'Program' object.</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">createProgram</span><span class="s2">(</span><span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">host</span><span class="s2">?: </span><span class="s1">CompilerHost</span><span class="s2">, </span><span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">Program</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[]): </span><span class="s1">Program</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">*/ </span><span class="s3">export interface </span><span class="s1">ResolveProjectReferencePathHost </span><span class="s2">{</span>
        <span class="s1">fileExists</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Returns the target config filename of a project reference.</span>
     <span class="s5">* Note: The file might not exist.</span>
     <span class="s5">*/</span>
    <span class="s3">export function </span><span class="s1">resolveProjectReferencePath</span><span class="s2">(</span><span class="s1">ref</span><span class="s2">: </span><span class="s1">ProjectReference</span><span class="s2">): </span><span class="s1">ResolvedConfigFileName</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">*/ </span><span class="s3">export function </span><span class="s1">resolveProjectReferencePath</span><span class="s2">(</span><span class="s1">host</span><span class="s2">: </span><span class="s1">ResolveProjectReferencePathHost</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">: </span><span class="s1">ProjectReference</span><span class="s2">): </span><span class="s1">ResolvedConfigFileName</span><span class="s2">;</span>
    <span class="s3">export </span><span class="s2">{};</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">EmitOutput </span><span class="s2">{</span>
        <span class="s1">outputFiles</span><span class="s2">: </span><span class="s1">OutputFile</span><span class="s2">[];</span>
        <span class="s1">emitSkipped</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">OutputFile </span><span class="s2">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">writeByteOrderMark</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s1">type AffectedFileResult</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; = {</span>
        <span class="s1">result</span><span class="s2">: </span><span class="s1">T</span><span class="s2">;</span>
        <span class="s1">affected</span><span class="s2">: </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">Program</span><span class="s2">;</span>
    <span class="s2">} | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">BuilderProgramHost </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* return true if file names are treated with case sensitivity</span>
         <span class="s5">*/</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* If provided this would be used this hash instead of actual file shape text for detecting changes</span>
         <span class="s5">*/</span>
        <span class="s1">createHash</span><span class="s2">?: (</span><span class="s1">data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* When emit or emitNextAffectedFile are called without writeFile,</span>
         <span class="s5">* this callback if present would be used to write files</span>
         <span class="s5">*/</span>
        <span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Builder to manage the program state changes</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">BuilderProgram </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Returns current program</span>
         <span class="s5">*/</span>
        <span class="s1">getProgram</span><span class="s2">(): </span><span class="s1">Program</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Get compiler options of the program</span>
         <span class="s5">*/</span>
        <span class="s1">getCompilerOptions</span><span class="s2">(): </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Get the source file in the program with file name</span>
         <span class="s5">*/</span>
        <span class="s1">getSourceFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Get a list of files in the program</span>
         <span class="s5">*/</span>
        <span class="s1">getSourceFiles</span><span class="s2">(): </span><span class="s1">readonly SourceFile</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Get the diagnostics for compiler options</span>
         <span class="s5">*/</span>
        <span class="s1">getOptionsDiagnostics</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Get the diagnostics that dont belong to any file</span>
         <span class="s5">*/</span>
        <span class="s1">getGlobalDiagnostics</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Get the diagnostics from config file parsing</span>
         <span class="s5">*/</span>
        <span class="s1">getConfigFileParsingDiagnostics</span><span class="s2">(): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Get the syntax diagnostics, for all source files if source file is not supplied</span>
         <span class="s5">*/</span>
        <span class="s1">getSyntacticDiagnostics</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Get the declaration diagnostics, for all source files if source file is not supplied</span>
         <span class="s5">*/</span>
        <span class="s1">getDeclarationDiagnostics</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly DiagnosticWithLocation</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Get all the dependencies of the file</span>
         <span class="s5">*/</span>
        <span class="s1">getAllDependencies</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">readonly string</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets the semantic diagnostics from the program corresponding to this state of file (if provided) or whole program</span>
         <span class="s5">* The semantic diagnostics are cached and managed here</span>
         <span class="s5">* Note that it is assumed that when asked about semantic diagnostics through this API,</span>
         <span class="s5">* the file has been taken out of affected files so it is safe to use cache or get from program and cache the diagnostics</span>
         <span class="s5">* In case of SemanticDiagnosticsBuilderProgram if the source file is not provided,</span>
         <span class="s5">* it will iterate through all the affected files, to ensure that cache stays valid and yet provide a way to get all semantic diagnostics</span>
         <span class="s5">*/</span>
        <span class="s1">getSemanticDiagnostics</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Emits the JavaScript and declaration files.</span>
         <span class="s5">* When targetSource file is specified, emits the files corresponding to that source file,</span>
         <span class="s5">* otherwise for the whole program.</span>
         <span class="s5">* In case of EmitAndSemanticDiagnosticsBuilderProgram, when targetSourceFile is specified,</span>
         <span class="s5">* it is assumed that that file is handled from affected file list. If targetSourceFile is not specified,</span>
         <span class="s5">* it will only emit all the affected files instead of whole program</span>
         <span class="s5">*</span>
         <span class="s5">* The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host</span>
         <span class="s5">* in that order would be used to write the files</span>
         <span class="s5">*/</span>
        <span class="s1">emit</span><span class="s2">(</span><span class="s1">targetSourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">customTransformers</span><span class="s2">?: </span><span class="s1">CustomTransformers</span><span class="s2">): </span><span class="s1">EmitResult</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Get the current directory of the program</span>
         <span class="s5">*/</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* The builder that caches the semantic diagnostics for the program and handles the changed files and affected files</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">SemanticDiagnosticsBuilderProgram </span><span class="s3">extends </span><span class="s1">BuilderProgram </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets the semantic diagnostics from the program for the next affected file and caches it</span>
         <span class="s5">* Returns undefined if the iteration is complete</span>
         <span class="s5">*/</span>
        <span class="s1">getSemanticDiagnosticsOfNextAffectedFile</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">ignoreSourceFile</span><span class="s2">?: (</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">AffectedFileResult</span><span class="s2">&lt;</span><span class="s1">readonly Diagnostic</span><span class="s2">[]&gt;;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* The builder that can handle the changes in program and iterate through changed file to emit the files</span>
     <span class="s5">* The semantic diagnostics are cached per file and managed by clearing for the changed/affected files</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram </span><span class="s3">extends </span><span class="s1">SemanticDiagnosticsBuilderProgram </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Emits the next affected file's emit result (EmitResult and sourceFiles emitted) or returns undefined if iteration is complete</span>
         <span class="s5">* The first of writeFile if provided, writeFile of BuilderProgramHost if provided, writeFile of compiler host</span>
         <span class="s5">* in that order would be used to write the files</span>
         <span class="s5">*/</span>
        <span class="s1">emitNextAffectedFile</span><span class="s2">(</span><span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">customTransformers</span><span class="s2">?: </span><span class="s1">CustomTransformers</span><span class="s2">): </span><span class="s1">AffectedFileResult</span><span class="s2">&lt;</span><span class="s1">EmitResult</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Create the builder to manage semantic diagnostics and cache them</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">createSemanticDiagnosticsBuilderProgram</span><span class="s2">(</span><span class="s1">newProgram</span><span class="s2">: </span><span class="s1">Program</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">BuilderProgramHost</span><span class="s2">, </span><span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">SemanticDiagnosticsBuilderProgram</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[]): </span><span class="s1">SemanticDiagnosticsBuilderProgram</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createSemanticDiagnosticsBuilderProgram</span><span class="s2">(</span><span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">host</span><span class="s2">?: </span><span class="s1">CompilerHost</span><span class="s2">, </span><span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">SemanticDiagnosticsBuilderProgram</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[], </span><span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[]): </span><span class="s1">SemanticDiagnosticsBuilderProgram</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Create the builder that can handle the changes in program and iterate through changed files</span>
     <span class="s5">* to emit the those files and manage semantic diagnostics cache as well</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">createEmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">(</span><span class="s1">newProgram</span><span class="s2">: </span><span class="s1">Program</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">BuilderProgramHost</span><span class="s2">, </span><span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[]): </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createEmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">(</span><span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">host</span><span class="s2">?: </span><span class="s1">CompilerHost</span><span class="s2">, </span><span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[], </span><span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[]): </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Creates a builder thats just abstraction over program and can be used with watch</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">createAbstractBuilder</span><span class="s2">(</span><span class="s1">newProgram</span><span class="s2">: </span><span class="s1">Program</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">BuilderProgramHost</span><span class="s2">, </span><span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">BuilderProgram</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[]): </span><span class="s1">BuilderProgram</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createAbstractBuilder</span><span class="s2">(</span><span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">host</span><span class="s2">?: </span><span class="s1">CompilerHost</span><span class="s2">, </span><span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">BuilderProgram</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[], </span><span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[]): </span><span class="s1">BuilderProgram</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">ReadBuildProgramHost </span><span class="s2">{</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">function </span><span class="s1">readBuilderProgram</span><span class="s2">(</span><span class="s1">compilerOptions</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">host</span><span class="s2">: </span><span class="s1">ReadBuildProgramHost</span><span class="s2">): </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createIncrementalCompilerHost</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">system</span><span class="s2">?: </span><span class="s1">System</span><span class="s2">): </span><span class="s1">CompilerHost</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">IncrementalProgramOptions</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; {</span>
        <span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[];</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[];</span>
        <span class="s1">host</span><span class="s2">?: </span><span class="s1">CompilerHost</span><span class="s2">;</span>
        <span class="s1">createProgram</span><span class="s2">?: </span><span class="s1">CreateProgram</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s2">}</span>
    <span class="s3">function </span><span class="s1">createIncrementalProgram</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram </span><span class="s2">= </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">&gt;({ </span><span class="s1">rootNames</span><span class="s2">, </span><span class="s1">options</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">, </span><span class="s1">projectReferences</span><span class="s2">, </span><span class="s1">host</span><span class="s2">, </span><span class="s1">createProgram </span><span class="s2">}: </span><span class="s1">IncrementalProgramOptions</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;): </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s1">type WatchStatusReporter </span><span class="s2">= (</span><span class="s1">diagnostic</span><span class="s2">: </span><span class="s1">Diagnostic</span><span class="s2">, </span><span class="s1">newLine</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">errorCount</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s5">/** Create the program with rootNames and options, if they are undefined, oldProgram and new configFile diagnostics create new program */</span>
    <span class="s1">type CreateProgram</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; = (</span><span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">host</span><span class="s2">?: </span><span class="s1">CompilerHost</span><span class="s2">, </span><span class="s1">oldProgram</span><span class="s2">?: </span><span class="s1">T</span><span class="s2">, </span><span class="s1">configFileParsingDiagnostics</span><span class="s2">?: </span><span class="s1">readonly Diagnostic</span><span class="s2">[], </span><span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">T</span><span class="s2">;</span>
    <span class="s5">/** Host that has watch functionality used in --watch mode */</span>
    <span class="s3">interface </span><span class="s1">WatchHost </span><span class="s2">{</span>
        <span class="s5">/** If provided, called with Diagnostic message that informs about change in watch status */</span>
        <span class="s1">onWatchStatusChange</span><span class="s2">?(</span><span class="s1">diagnostic</span><span class="s2">: </span><span class="s1">Diagnostic</span><span class="s2">, </span><span class="s1">newLine</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">errorCount</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/** Used to watch changes in source files, missing files needed to update the program or config file */</span>
        <span class="s1">watchFile</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">: </span><span class="s1">FileWatcherCallback</span><span class="s2">, </span><span class="s1">pollingInterval</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">): </span><span class="s1">FileWatcher</span><span class="s2">;</span>
        <span class="s5">/** Used to watch resolved module's failed lookup locations, config file specs, type roots where auto type reference directives are added */</span>
        <span class="s1">watchDirectory</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">callback</span><span class="s2">: </span><span class="s1">DirectoryWatcherCallback</span><span class="s2">, </span><span class="s1">recursive</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">): </span><span class="s1">FileWatcher</span><span class="s2">;</span>
        <span class="s5">/** If provided, will be used to set delayed compilation, so that multiple changes in short span are compiled together */</span>
        <span class="s1">setTimeout</span><span class="s2">?(</span><span class="s1">callback</span><span class="s2">: (</span><span class="s1">...args</span><span class="s2">: </span><span class="s1">any</span><span class="s2">[]) =&gt; </span><span class="s3">void</span><span class="s2">, </span><span class="s1">ms</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">...args</span><span class="s2">: </span><span class="s1">any</span><span class="s2">[]): </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s5">/** If provided, will be used to reset existing delayed compilation */</span>
        <span class="s1">clearTimeout</span><span class="s2">?(</span><span class="s1">timeoutId</span><span class="s2">: </span><span class="s1">any</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ProgramHost</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; {</span>
        <span class="s5">/**</span>
         <span class="s5">* Used to create the program when need for program creation or recreation detected</span>
         <span class="s5">*/</span>
        <span class="s1">createProgram</span><span class="s2">: </span><span class="s1">CreateProgram</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getNewLine</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getDefaultLibFileName</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getDefaultLibLocation</span><span class="s2">?(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">createHash</span><span class="s2">?(</span><span class="s1">data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Use to check file presence for source files and</span>
         <span class="s5">* if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well</span>
         <span class="s5">*/</span>
        <span class="s1">fileExists</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Use to read file text for source files and</span>
         <span class="s5">* if resolveModuleNames is not provided (complier is in charge of module resolution) then module files as well</span>
         <span class="s5">*/</span>
        <span class="s1">readFile</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** If provided, used for module resolution as well as to handle directory structure */</span>
        <span class="s1">directoryExists</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/** If provided, used in resolutions as well as handling directory structure */</span>
        <span class="s1">getDirectories</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s5">/** If provided, used to cache and handle directory structure modifications */</span>
        <span class="s1">readDirectory</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">extensions</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">exclude</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">include</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">depth</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s5">/** Symbol links resolution */</span>
        <span class="s1">realpath</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** If provided would be used to write log about compilation */</span>
        <span class="s1">trace</span><span class="s2">?(</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/** If provided is used to get the environment variable */</span>
        <span class="s1">getEnvironmentVariable</span><span class="s2">?(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** If provided, used to resolve the module names, otherwise typescript's default module resolution */</span>
        <span class="s1">resolveModuleNames</span><span class="s2">?(</span><span class="s1">moduleNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[], </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">reusedNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">: </span><span class="s1">ResolvedProjectReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">containingSourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): (</span><span class="s1">ResolvedModule </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[];</span>
        <span class="s5">/** If provided, used to resolve type reference directives, otherwise typescript's default resolution */</span>
        <span class="s1">resolveTypeReferenceDirectives</span><span class="s2">?(</span><span class="s1">typeReferenceDirectiveNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[] | </span><span class="s1">readonly FileReference</span><span class="s2">[], </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">: </span><span class="s1">ResolvedProjectReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">containingFileMode</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">] | </span><span class="s1">undefined</span><span class="s2">): (</span><span class="s1">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[];</span>
        <span class="s5">/** If provided along with custom resolveModuleNames or resolveTypeReferenceDirectives, used to determine if unchanged file path needs to re-resolve modules/type reference directives */</span>
        <span class="s1">hasInvalidatedResolutions</span><span class="s2">?(</span><span class="s1">filePath</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Returns the module resolution cache used by a provided `resolveModuleNames` implementation so that any non-name module resolution operations (eg, package.json lookup) can reuse it</span>
         <span class="s5">*/</span>
        <span class="s1">getModuleResolutionCache</span><span class="s2">?(): </span><span class="s1">ModuleResolutionCache </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">WatchCompilerHost</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ProgramHost</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">WatchHost </span><span class="s2">{</span>
        <span class="s5">/** Instead of using output d.ts file from project reference, use its source file */</span>
        <span class="s1">useSourceOfProjectReferenceRedirect</span><span class="s2">?(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/** If provided, use this method to get parsed command lines for referenced projects */</span>
        <span class="s1">getParsedCommandLine</span><span class="s2">?(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ParsedCommandLine </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** If provided, callback to invoke after every new program creation */</span>
        <span class="s1">afterProgramCreate</span><span class="s2">?(</span><span class="s1">program</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Host to create watch with root files and options</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">WatchCompilerHostOfFilesAndCompilerOptions</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">WatchCompilerHost</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s5">/** root files to use to generate program */</span>
        <span class="s1">rootFiles</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s5">/** Compiler options */</span>
        <span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">watchOptions</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">;</span>
        <span class="s5">/** Project References */</span>
        <span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Host to create watch with config file</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">WatchCompilerHostOfConfigFile</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">WatchCompilerHost</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">ConfigFileDiagnosticsReporter </span><span class="s2">{</span>
        <span class="s5">/** Name of the config file to compile */</span>
        <span class="s1">configFileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** Options to extend */</span>
        <span class="s1">optionsToExtend</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">watchOptionsToExtend</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">;</span>
        <span class="s1">extraFileExtensions</span><span class="s2">?: </span><span class="s1">readonly FileExtensionInfo</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Used to generate source file names from the config file and its include, exclude, files rules</span>
         <span class="s5">* and also to cache the directory stucture</span>
         <span class="s5">*/</span>
        <span class="s1">readDirectory</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">extensions</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">exclude</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">include</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">depth</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">Watch</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s5">/** Synchronize with host and get updated program */</span>
        <span class="s1">getProgram</span><span class="s2">(): </span><span class="s1">T</span><span class="s2">;</span>
        <span class="s5">/** Closes the watch */</span>
        <span class="s1">close</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Creates the watch what generates program using the config file</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">WatchOfConfigFile</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">Watch</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Creates the watch that generates program using the root files and compiler options</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">WatchOfFilesAndCompilerOptions</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">Watch</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s5">/** Updates the root files in the program, only if this is not config file compilation */</span>
        <span class="s1">updateRootFileNames</span><span class="s2">(</span><span class="s1">fileNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[]): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Create the watch compiler host for either configFile or fileNames and its options</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">createWatchCompilerHost</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt;(</span><span class="s1">configFileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">optionsToExtend</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">system</span><span class="s2">: </span><span class="s1">System</span><span class="s2">, </span><span class="s1">createProgram</span><span class="s2">?: </span><span class="s1">CreateProgram</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">reportDiagnostic</span><span class="s2">?: </span><span class="s1">DiagnosticReporter</span><span class="s2">, </span><span class="s1">reportWatchStatus</span><span class="s2">?: </span><span class="s1">WatchStatusReporter</span><span class="s2">, </span><span class="s1">watchOptionsToExtend</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">, </span><span class="s1">extraFileExtensions</span><span class="s2">?: </span><span class="s1">readonly FileExtensionInfo</span><span class="s2">[]): </span><span class="s1">WatchCompilerHostOfConfigFile</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s3">function </span><span class="s1">createWatchCompilerHost</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt;(</span><span class="s1">rootFiles</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[], </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">system</span><span class="s2">: </span><span class="s1">System</span><span class="s2">, </span><span class="s1">createProgram</span><span class="s2">?: </span><span class="s1">CreateProgram</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">reportDiagnostic</span><span class="s2">?: </span><span class="s1">DiagnosticReporter</span><span class="s2">, </span><span class="s1">reportWatchStatus</span><span class="s2">?: </span><span class="s1">WatchStatusReporter</span><span class="s2">, </span><span class="s1">projectReferences</span><span class="s2">?: </span><span class="s1">readonly ProjectReference</span><span class="s2">[], </span><span class="s1">watchOptions</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">): </span><span class="s1">WatchCompilerHostOfFilesAndCompilerOptions</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s5">/**</span>
     <span class="s5">* Creates the watch from the host for root files and compiler options</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">createWatchProgram</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt;(</span><span class="s1">host</span><span class="s2">: </span><span class="s1">WatchCompilerHostOfFilesAndCompilerOptions</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;): </span><span class="s1">WatchOfFilesAndCompilerOptions</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s5">/**</span>
     <span class="s5">* Creates the watch from the host for config file</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">createWatchProgram</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt;(</span><span class="s1">host</span><span class="s2">: </span><span class="s1">WatchCompilerHostOfConfigFile</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;): </span><span class="s1">WatchOfConfigFile</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">BuildOptions </span><span class="s2">{</span>
        <span class="s1">dry</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">force</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">verbose</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">incremental</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">assumeChangesOnlyAffectDirectDependencies</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">traceResolution</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s2">[</span><span class="s1">option</span><span class="s2">: </span><span class="s1">string</span><span class="s2">]: </span><span class="s1">CompilerOptionsValue </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">type ReportEmitErrorSummary </span><span class="s2">= (</span><span class="s1">errorCount</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">filesInError</span><span class="s2">: (</span><span class="s1">ReportFileInError </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[]) =&gt; </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">ReportFileInError </span><span class="s2">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">line</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SolutionBuilderHostBase</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ProgramHost</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s1">createDirectory</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Should provide create directory and writeFile if done of invalidatedProjects is not invoked with</span>
         <span class="s5">* writeFileCallback</span>
         <span class="s5">*/</span>
        <span class="s1">writeFile</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">data</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">writeByteOrderMark</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">getCustomTransformers</span><span class="s2">?: (</span><span class="s1">project</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">CustomTransformers </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getModifiedTime</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">Date </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">setModifiedTime</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">date</span><span class="s2">: </span><span class="s1">Date</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">deleteFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">getParsedCommandLine</span><span class="s2">?(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ParsedCommandLine </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">reportDiagnostic</span><span class="s2">: </span><span class="s1">DiagnosticReporter</span><span class="s2">;</span>
        <span class="s1">reportSolutionBuilderStatus</span><span class="s2">: </span><span class="s1">DiagnosticReporter</span><span class="s2">;</span>
        <span class="s1">afterProgramEmitAndDiagnostics</span><span class="s2">?(</span><span class="s1">program</span><span class="s2">: </span><span class="s1">T</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SolutionBuilderHost</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">SolutionBuilderHostBase</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; {</span>
        <span class="s1">reportErrorSummary</span><span class="s2">?: </span><span class="s1">ReportEmitErrorSummary</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SolutionBuilderWithWatchHost</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">SolutionBuilderHostBase</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">WatchHost </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SolutionBuilder</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; {</span>
        <span class="s1">build</span><span class="s2">(</span><span class="s1">project</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">, </span><span class="s1">getCustomTransformers</span><span class="s2">?: (</span><span class="s1">project</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">CustomTransformers</span><span class="s2">): </span><span class="s1">ExitStatus</span><span class="s2">;</span>
        <span class="s1">clean</span><span class="s2">(</span><span class="s1">project</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ExitStatus</span><span class="s2">;</span>
        <span class="s1">buildReferences</span><span class="s2">(</span><span class="s1">project</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">, </span><span class="s1">getCustomTransformers</span><span class="s2">?: (</span><span class="s1">project</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">CustomTransformers</span><span class="s2">): </span><span class="s1">ExitStatus</span><span class="s2">;</span>
        <span class="s1">cleanReferences</span><span class="s2">(</span><span class="s1">project</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ExitStatus</span><span class="s2">;</span>
        <span class="s1">getNextInvalidatedProject</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">InvalidatedProject</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Create a function that reports watch status by writing to the system and handles the formating of the diagnostic</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">createBuilderStatusReporter</span><span class="s2">(</span><span class="s1">system</span><span class="s2">: </span><span class="s1">System</span><span class="s2">, </span><span class="s1">pretty</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">DiagnosticReporter</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createSolutionBuilderHost</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram </span><span class="s2">= </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">&gt;(</span><span class="s1">system</span><span class="s2">?: </span><span class="s1">System</span><span class="s2">, </span><span class="s1">createProgram</span><span class="s2">?: </span><span class="s1">CreateProgram</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">reportDiagnostic</span><span class="s2">?: </span><span class="s1">DiagnosticReporter</span><span class="s2">, </span><span class="s1">reportSolutionBuilderStatus</span><span class="s2">?: </span><span class="s1">DiagnosticReporter</span><span class="s2">, </span><span class="s1">reportErrorSummary</span><span class="s2">?: </span><span class="s1">ReportEmitErrorSummary</span><span class="s2">): </span><span class="s1">SolutionBuilderHost</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s3">function </span><span class="s1">createSolutionBuilderWithWatchHost</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram </span><span class="s2">= </span><span class="s1">EmitAndSemanticDiagnosticsBuilderProgram</span><span class="s2">&gt;(</span><span class="s1">system</span><span class="s2">?: </span><span class="s1">System</span><span class="s2">, </span><span class="s1">createProgram</span><span class="s2">?: </span><span class="s1">CreateProgram</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">reportDiagnostic</span><span class="s2">?: </span><span class="s1">DiagnosticReporter</span><span class="s2">, </span><span class="s1">reportSolutionBuilderStatus</span><span class="s2">?: </span><span class="s1">DiagnosticReporter</span><span class="s2">, </span><span class="s1">reportWatchStatus</span><span class="s2">?: </span><span class="s1">WatchStatusReporter</span><span class="s2">): </span><span class="s1">SolutionBuilderWithWatchHost</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s3">function </span><span class="s1">createSolutionBuilder</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt;(</span><span class="s1">host</span><span class="s2">: </span><span class="s1">SolutionBuilderHost</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">defaultOptions</span><span class="s2">: </span><span class="s1">BuildOptions</span><span class="s2">): </span><span class="s1">SolutionBuilder</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s3">function </span><span class="s1">createSolutionBuilderWithWatch</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt;(</span><span class="s1">host</span><span class="s2">: </span><span class="s1">SolutionBuilderWithWatchHost</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;, </span><span class="s1">rootNames</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">defaultOptions</span><span class="s2">: </span><span class="s1">BuildOptions</span><span class="s2">, </span><span class="s1">baseWatchOptions</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">): </span><span class="s1">SolutionBuilder</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s3">enum </span><span class="s1">InvalidatedProjectKind </span><span class="s2">{</span>
        <span class="s1">Build </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">UpdateBundle </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">UpdateOutputFileStamps </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">InvalidatedProjectBase </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">InvalidatedProjectKind</span><span class="s2">;</span>
        <span class="s1">readonly project</span><span class="s2">: </span><span class="s1">ResolvedConfigFileName</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">*  To dispose this project and ensure that all the necessary actions are taken and state is updated accordingly</span>
         <span class="s5">*/</span>
        <span class="s1">done</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">, </span><span class="s1">customTransformers</span><span class="s2">?: </span><span class="s1">CustomTransformers</span><span class="s2">): </span><span class="s1">ExitStatus</span><span class="s2">;</span>
        <span class="s1">getCompilerOptions</span><span class="s2">(): </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">UpdateOutputFileStampsProject </span><span class="s3">extends </span><span class="s1">InvalidatedProjectBase </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">InvalidatedProjectKind</span><span class="s2">.</span><span class="s1">UpdateOutputFileStamps</span><span class="s2">;</span>
        <span class="s1">updateOutputFileStatmps</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">BuildInvalidedProject</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">InvalidatedProjectBase </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">InvalidatedProjectKind</span><span class="s2">.</span><span class="s1">Build</span><span class="s2">;</span>
        <span class="s1">getBuilderProgram</span><span class="s2">(): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getProgram</span><span class="s2">(): </span><span class="s1">Program </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSourceFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">SourceFile </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSourceFiles</span><span class="s2">(): </span><span class="s1">readonly SourceFile</span><span class="s2">[];</span>
        <span class="s1">getOptionsDiagnostics</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">getGlobalDiagnostics</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">getConfigFileParsingDiagnostics</span><span class="s2">(): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">getSyntacticDiagnostics</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">getAllDependencies</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">readonly string</span><span class="s2">[];</span>
        <span class="s1">getSemanticDiagnostics</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">): </span><span class="s1">readonly Diagnostic</span><span class="s2">[];</span>
        <span class="s1">getSemanticDiagnosticsOfNextAffectedFile</span><span class="s2">(</span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">ignoreSourceFile</span><span class="s2">?: (</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">) =&gt; </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">AffectedFileResult</span><span class="s2">&lt;</span><span class="s1">readonly Diagnostic</span><span class="s2">[]&gt;;</span>
        <span class="s1">emit</span><span class="s2">(</span><span class="s1">targetSourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">, </span><span class="s1">cancellationToken</span><span class="s2">?: </span><span class="s1">CancellationToken</span><span class="s2">, </span><span class="s1">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">customTransformers</span><span class="s2">?: </span><span class="s1">CustomTransformers</span><span class="s2">): </span><span class="s1">EmitResult </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">UpdateBundleProject</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">InvalidatedProjectBase </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">InvalidatedProjectKind</span><span class="s2">.</span><span class="s1">UpdateBundle</span><span class="s2">;</span>
        <span class="s1">emit</span><span class="s2">(</span><span class="s1">writeFile</span><span class="s2">?: </span><span class="s1">WriteFileCallback</span><span class="s2">, </span><span class="s1">customTransformers</span><span class="s2">?: </span><span class="s1">CustomTransformers</span><span class="s2">): </span><span class="s1">EmitResult </span><span class="s2">| </span><span class="s1">BuildInvalidedProject</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">type InvalidatedProject</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">BuilderProgram</span><span class="s2">&gt; = </span><span class="s1">UpdateOutputFileStampsProject </span><span class="s2">| </span><span class="s1">BuildInvalidedProject</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; | </span><span class="s1">UpdateBundleProject</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts</span><span class="s2">.</span><span class="s1">server </span><span class="s2">{</span>
    <span class="s1">type ActionSet </span><span class="s2">= </span><span class="s4">&quot;action::set&quot;</span><span class="s2">;</span>
    <span class="s1">type ActionInvalidate </span><span class="s2">= </span><span class="s4">&quot;action::invalidate&quot;</span><span class="s2">;</span>
    <span class="s1">type ActionPackageInstalled </span><span class="s2">= </span><span class="s4">&quot;action::packageInstalled&quot;</span><span class="s2">;</span>
    <span class="s1">type EventTypesRegistry </span><span class="s2">= </span><span class="s4">&quot;event::typesRegistry&quot;</span><span class="s2">;</span>
    <span class="s1">type EventBeginInstallTypes </span><span class="s2">= </span><span class="s4">&quot;event::beginInstallTypes&quot;</span><span class="s2">;</span>
    <span class="s1">type EventEndInstallTypes </span><span class="s2">= </span><span class="s4">&quot;event::endInstallTypes&quot;</span><span class="s2">;</span>
    <span class="s1">type EventInitializationFailed </span><span class="s2">= </span><span class="s4">&quot;event::initializationFailed&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts</span><span class="s2">.</span><span class="s1">server </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">TypingInstallerResponse </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">ActionSet </span><span class="s2">| </span><span class="s1">ActionInvalidate </span><span class="s2">| </span><span class="s1">EventTypesRegistry </span><span class="s2">| </span><span class="s1">ActionPackageInstalled </span><span class="s2">| </span><span class="s1">EventBeginInstallTypes </span><span class="s2">| </span><span class="s1">EventEndInstallTypes </span><span class="s2">| </span><span class="s1">EventInitializationFailed</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">TypingInstallerRequestWithProjectName </span><span class="s2">{</span>
        <span class="s1">readonly projectName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">DiscoverTypings </span><span class="s3">extends </span><span class="s1">TypingInstallerRequestWithProjectName </span><span class="s2">{</span>
        <span class="s1">readonly fileNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">readonly projectRootPath</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">;</span>
        <span class="s1">readonly compilerOptions</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">readonly watchOptions</span><span class="s2">?: </span><span class="s1">WatchOptions</span><span class="s2">;</span>
        <span class="s1">readonly typeAcquisition</span><span class="s2">: </span><span class="s1">TypeAcquisition</span><span class="s2">;</span>
        <span class="s1">readonly unresolvedImports</span><span class="s2">: </span><span class="s1">SortedReadonlyArray</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">&gt;;</span>
        <span class="s1">readonly cachePath</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s4">&quot;discover&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CloseProject </span><span class="s3">extends </span><span class="s1">TypingInstallerRequestWithProjectName </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s4">&quot;closeProject&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">TypesRegistryRequest </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s4">&quot;typesRegistry&quot;</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">InstallPackageRequest </span><span class="s3">extends </span><span class="s1">TypingInstallerRequestWithProjectName </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s4">&quot;installPackage&quot;</span><span class="s2">;</span>
        <span class="s1">readonly fileName</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">;</span>
        <span class="s1">readonly packageName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly projectRootPath</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">PackageInstalledResponse </span><span class="s3">extends </span><span class="s1">ProjectResponse </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">ActionPackageInstalled</span><span class="s2">;</span>
        <span class="s1">readonly success</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly message</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">InitializationFailedResponse </span><span class="s3">extends </span><span class="s1">TypingInstallerResponse </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">EventInitializationFailed</span><span class="s2">;</span>
        <span class="s1">readonly message</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly stack</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ProjectResponse </span><span class="s3">extends </span><span class="s1">TypingInstallerResponse </span><span class="s2">{</span>
        <span class="s1">readonly projectName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">InvalidateCachedTypings </span><span class="s3">extends </span><span class="s1">ProjectResponse </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">ActionInvalidate</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">InstallTypes </span><span class="s3">extends </span><span class="s1">ProjectResponse </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">EventBeginInstallTypes </span><span class="s2">| </span><span class="s1">EventEndInstallTypes</span><span class="s2">;</span>
        <span class="s1">readonly eventId</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">readonly typingsInstallerVersion</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly packagesToInstall</span><span class="s2">: </span><span class="s1">readonly string</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">BeginInstallTypes </span><span class="s3">extends </span><span class="s1">InstallTypes </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">EventBeginInstallTypes</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">EndInstallTypes </span><span class="s3">extends </span><span class="s1">InstallTypes </span><span class="s2">{</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">EventEndInstallTypes</span><span class="s2">;</span>
        <span class="s1">readonly installSuccess</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SetTypings </span><span class="s3">extends </span><span class="s1">ProjectResponse </span><span class="s2">{</span>
        <span class="s1">readonly typeAcquisition</span><span class="s2">: </span><span class="s1">TypeAcquisition</span><span class="s2">;</span>
        <span class="s1">readonly compilerOptions</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">readonly typings</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">readonly unresolvedImports</span><span class="s2">: </span><span class="s1">SortedReadonlyArray</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">&gt;;</span>
        <span class="s1">readonly kind</span><span class="s2">: </span><span class="s1">ActionSet</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s1">getSourceFile</span><span class="s2">(): </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">getChildCount</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getChildAt</span><span class="s2">(</span><span class="s1">index</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">Node</span><span class="s2">;</span>
        <span class="s1">getChildren</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">Node</span><span class="s2">[];</span>
        <span class="s1">getStart</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">includeJsDocComment</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getFullStart</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getEnd</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getWidth</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFileLike</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getFullWidth</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getLeadingTriviaWidth</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getFullText</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getText</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getFirstToken</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getLastToken</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">forEachChild</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;(</span><span class="s1">cbNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">cbNodeArray</span><span class="s2">?: (</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Node</span><span class="s2">&gt;) =&gt; </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">T </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">Identifier </span><span class="s2">{</span>
        <span class="s1">readonly text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">PrivateIdentifier </span><span class="s2">{</span>
        <span class="s1">readonly text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">Symbol </span><span class="s2">{</span>
        <span class="s1">readonly name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getFlags</span><span class="s2">(): </span><span class="s1">SymbolFlags</span><span class="s2">;</span>
        <span class="s1">getEscapedName</span><span class="s2">(): </span><span class="s1">__String</span><span class="s2">;</span>
        <span class="s1">getName</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getDeclarations</span><span class="s2">(): </span><span class="s1">Declaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getDocumentationComment</span><span class="s2">(</span><span class="s1">typeChecker</span><span class="s2">: </span><span class="s1">TypeChecker </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">getJsDocTags</span><span class="s2">(</span><span class="s1">checker</span><span class="s2">?: </span><span class="s1">TypeChecker</span><span class="s2">): </span><span class="s1">JSDocTagInfo</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">Type </span><span class="s2">{</span>
        <span class="s1">getFlags</span><span class="s2">(): </span><span class="s1">TypeFlags</span><span class="s2">;</span>
        <span class="s1">getSymbol</span><span class="s2">(): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getProperties</span><span class="s2">(): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">getProperty</span><span class="s2">(</span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getApparentProperties</span><span class="s2">(): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">getCallSignatures</span><span class="s2">(): </span><span class="s1">readonly Signature</span><span class="s2">[];</span>
        <span class="s1">getConstructSignatures</span><span class="s2">(): </span><span class="s1">readonly Signature</span><span class="s2">[];</span>
        <span class="s1">getStringIndexType</span><span class="s2">(): </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getNumberIndexType</span><span class="s2">(): </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getBaseTypes</span><span class="s2">(): </span><span class="s1">BaseType</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getNonNullableType</span><span class="s2">(): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getConstraint</span><span class="s2">(): </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getDefault</span><span class="s2">(): </span><span class="s1">Type </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">isUnion</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">UnionType</span><span class="s2">;</span>
        <span class="s1">isIntersection</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">IntersectionType</span><span class="s2">;</span>
        <span class="s1">isUnionOrIntersection</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">UnionOrIntersectionType</span><span class="s2">;</span>
        <span class="s1">isLiteral</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">LiteralType</span><span class="s2">;</span>
        <span class="s1">isStringLiteral</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">StringLiteralType</span><span class="s2">;</span>
        <span class="s1">isNumberLiteral</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">NumberLiteralType</span><span class="s2">;</span>
        <span class="s1">isTypeParameter</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">TypeParameter</span><span class="s2">;</span>
        <span class="s1">isClassOrInterface</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">InterfaceType</span><span class="s2">;</span>
        <span class="s1">isClass</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">InterfaceType</span><span class="s2">;</span>
        <span class="s1">isIndexType</span><span class="s2">(): </span><span class="s3">this </span><span class="s2">is </span><span class="s1">IndexType</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">TypeReference </span><span class="s2">{</span>
        <span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly Type</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">Signature </span><span class="s2">{</span>
        <span class="s1">getDeclaration</span><span class="s2">(): </span><span class="s1">SignatureDeclaration</span><span class="s2">;</span>
        <span class="s1">getTypeParameters</span><span class="s2">(): </span><span class="s1">TypeParameter</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getParameters</span><span class="s2">(): </span><span class="s1">Symbol</span><span class="s2">[];</span>
        <span class="s1">getTypeParameterAtPosition</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getReturnType</span><span class="s2">(): </span><span class="s1">Type</span><span class="s2">;</span>
        <span class="s1">getDocumentationComment</span><span class="s2">(</span><span class="s1">typeChecker</span><span class="s2">: </span><span class="s1">TypeChecker </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">getJsDocTags</span><span class="s2">(): </span><span class="s1">JSDocTagInfo</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SourceFile </span><span class="s2">{</span>
        <span class="s1">getLineAndCharacterOfPosition</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">LineAndCharacter</span><span class="s2">;</span>
        <span class="s1">getLineEndOfPosition</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getLineStarts</span><span class="s2">(): </span><span class="s1">readonly number</span><span class="s2">[];</span>
        <span class="s1">getPositionOfLineAndCharacter</span><span class="s2">(</span><span class="s1">line</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">character</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">update</span><span class="s2">(</span><span class="s1">newText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">textChangeRange</span><span class="s2">: </span><span class="s1">TextChangeRange</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SourceFileLike </span><span class="s2">{</span>
        <span class="s1">getLineAndCharacterOfPosition</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">LineAndCharacter</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SourceMapSource </span><span class="s2">{</span>
        <span class="s1">getLineAndCharacterOfPosition</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">LineAndCharacter</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Represents an immutable snapshot of a script at a specified time.Once acquired, the</span>
     <span class="s5">* snapshot is observably immutable. i.e. the same calls with the same parameters will return</span>
     <span class="s5">* the same values.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">IScriptSnapshot </span><span class="s2">{</span>
        <span class="s5">/** Gets a portion of the script snapshot specified by [start, end). */</span>
        <span class="s1">getText</span><span class="s2">(</span><span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** Gets the length of this script snapshot. */</span>
        <span class="s1">getLength</span><span class="s2">(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets the TextChangeRange that describe how the text changed between this text and</span>
         <span class="s5">* an older version.  This information is used by the incremental parser to determine</span>
         <span class="s5">* what sections of the script need to be re-parsed.  'undefined' can be returned if the</span>
         <span class="s5">* change range cannot be determined.  However, in that case, incremental parsing will</span>
         <span class="s5">* not happen and the entire document will be re - parsed.</span>
         <span class="s5">*/</span>
        <span class="s1">getChangeRange</span><span class="s2">(</span><span class="s1">oldSnapshot</span><span class="s2">: </span><span class="s1">IScriptSnapshot</span><span class="s2">): </span><span class="s1">TextChangeRange </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Releases all resources held by this script snapshot */</span>
        <span class="s1">dispose</span><span class="s2">?(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">namespace ScriptSnapshot </span><span class="s2">{</span>
        <span class="s3">function </span><span class="s1">fromString</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">IScriptSnapshot</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">PreProcessedFileInfo </span><span class="s2">{</span>
        <span class="s1">referencedFiles</span><span class="s2">: </span><span class="s1">FileReference</span><span class="s2">[];</span>
        <span class="s1">typeReferenceDirectives</span><span class="s2">: </span><span class="s1">FileReference</span><span class="s2">[];</span>
        <span class="s1">libReferenceDirectives</span><span class="s2">: </span><span class="s1">FileReference</span><span class="s2">[];</span>
        <span class="s1">importedFiles</span><span class="s2">: </span><span class="s1">FileReference</span><span class="s2">[];</span>
        <span class="s1">ambientExternalModules</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">isLibFile</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">HostCancellationToken </span><span class="s2">{</span>
        <span class="s1">isCancellationRequested</span><span class="s2">(): </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">InstallPackageOptions </span><span class="s2">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">;</span>
        <span class="s1">packageName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">PerformanceEvent </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;UpdateGraph&quot; </span><span class="s2">| </span><span class="s4">&quot;CreatePackageJsonAutoImportProvider&quot;</span><span class="s2">;</span>
        <span class="s1">durationMs</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">LanguageServiceMode </span><span class="s2">{</span>
        <span class="s1">Semantic </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">PartialSemantic </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Syntactic </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">IncompleteCompletionsCache </span><span class="s2">{</span>
        <span class="s1">get</span><span class="s2">(): </span><span class="s1">CompletionInfo </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">set</span><span class="s2">(</span><span class="s1">response</span><span class="s2">: </span><span class="s1">CompletionInfo</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">clear</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">LanguageServiceHost </span><span class="s3">extends </span><span class="s1">GetEffectiveTypeRootsHost</span><span class="s2">, </span><span class="s1">MinimalResolutionCacheHost </span><span class="s2">{</span>
        <span class="s1">getCompilationSettings</span><span class="s2">(): </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">getNewLine</span><span class="s2">?(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getProjectVersion</span><span class="s2">?(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getScriptFileNames</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">getScriptKind</span><span class="s2">?(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ScriptKind</span><span class="s2">;</span>
        <span class="s1">getScriptVersion</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getScriptSnapshot</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">IScriptSnapshot </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getProjectReferences</span><span class="s2">?(): </span><span class="s1">readonly ProjectReference</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getLocalizedDiagnosticMessages</span><span class="s2">?(): </span><span class="s1">any</span><span class="s2">;</span>
        <span class="s1">getCancellationToken</span><span class="s2">?(): </span><span class="s1">HostCancellationToken</span><span class="s2">;</span>
        <span class="s1">getCurrentDirectory</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">getDefaultLibFileName</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">log</span><span class="s2">?(</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">trace</span><span class="s2">?(</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">error</span><span class="s2">?(</span><span class="s1">s</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">useCaseSensitiveFileNames</span><span class="s2">?(): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readDirectory</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">extensions</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">exclude</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">include</span><span class="s2">?: </span><span class="s1">readonly string</span><span class="s2">[], </span><span class="s1">depth</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s1">realpath</span><span class="s2">?(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readFile</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">encoding</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">fileExists</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">getTypeRootsVersion</span><span class="s2">?(): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">resolveModuleNames</span><span class="s2">?(</span><span class="s1">moduleNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[], </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">reusedNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">: </span><span class="s1">ResolvedProjectReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">containingSourceFile</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">): (</span><span class="s1">ResolvedModule </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[];</span>
        <span class="s1">getResolvedModuleWithFailedLookupLocationsFromCache</span><span class="s2">?(</span><span class="s1">modulename</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">resolutionMode</span><span class="s2">?: </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">CommonJS </span><span class="s2">| </span><span class="s1">ModuleKind</span><span class="s2">.</span><span class="s1">ESNext</span><span class="s2">): </span><span class="s1">ResolvedModuleWithFailedLookupLocations </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">resolveTypeReferenceDirectives</span><span class="s2">?(</span><span class="s1">typeDirectiveNames</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[] | </span><span class="s1">FileReference</span><span class="s2">[], </span><span class="s1">containingFile</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">redirectedReference</span><span class="s2">: </span><span class="s1">ResolvedProjectReference </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">containingFileMode</span><span class="s2">?: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">] | </span><span class="s1">undefined</span><span class="s2">): (</span><span class="s1">ResolvedTypeReferenceDirective </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">)[];</span>
        <span class="s1">getDirectories</span><span class="s2">?(</span><span class="s1">directoryName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets a set of custom transformers to use during emit.</span>
         <span class="s5">*/</span>
        <span class="s1">getCustomTransformers</span><span class="s2">?(): </span><span class="s1">CustomTransformers </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">isKnownTypesPackageName</span><span class="s2">?(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">installPackage</span><span class="s2">?(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">InstallPackageOptions</span><span class="s2">): </span><span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">ApplyCodeActionCommandResult</span><span class="s2">&gt;;</span>
        <span class="s1">writeFile</span><span class="s2">?(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">content</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">getParsedCommandLine</span><span class="s2">?(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ParsedCommandLine </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">type WithMetadata</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; = </span><span class="s1">T </span><span class="s2">&amp; {</span>
        <span class="s1">metadata</span><span class="s2">?: </span><span class="s1">unknown</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s3">enum </span><span class="s1">SemanticClassificationFormat </span><span class="s2">{</span>
        <span class="s1">Original </span><span class="s2">= </span><span class="s4">&quot;original&quot;</span><span class="s2">,</span>
        <span class="s1">TwentyTwenty </span><span class="s2">= </span><span class="s4">&quot;2020&quot;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">LanguageService </span><span class="s2">{</span>
        <span class="s5">/** This is used as a part of restarting the language service. */</span>
        <span class="s1">cleanupSemanticCache</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets errors indicating invalid syntax in a file.</span>
         <span class="s5">*</span>
         <span class="s5">* In English, &quot;this cdeo have, erorrs&quot; is syntactically invalid because it has typos,</span>
         <span class="s5">* grammatical errors, and misplaced punctuation. Likewise, examples of syntax</span>
         <span class="s5">* errors in TypeScript are missing parentheses in an `if` statement, mismatched</span>
         <span class="s5">* curly braces, and using a reserved keyword as a variable name.</span>
         <span class="s5">*</span>
         <span class="s5">* These diagnostics are inexpensive to compute and don't require knowledge of</span>
         <span class="s5">* other files. Note that a non-empty result increases the likelihood of false positives</span>
         <span class="s5">* from `getSemanticDiagnostics`.</span>
         <span class="s5">*</span>
         <span class="s5">* While these represent the majority of syntax-related diagnostics, there are some</span>
         <span class="s5">* that require the type system, which will be present in `getSemanticDiagnostics`.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName A path to the file you want syntactic diagnostics for</span>
         <span class="s5">*/</span>
        <span class="s1">getSyntacticDiagnostics</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">DiagnosticWithLocation</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets warnings or errors indicating type system issues in a given file.</span>
         <span class="s5">* Requesting semantic diagnostics may start up the type system and</span>
         <span class="s5">* run deferred work, so the first call may take longer than subsequent calls.</span>
         <span class="s5">*</span>
         <span class="s5">* Unlike the other get*Diagnostics functions, these diagnostics can potentially not</span>
         <span class="s5">* include a reference to a source file. Specifically, the first time this is called,</span>
         <span class="s5">* it will return global diagnostics with no associated location.</span>
         <span class="s5">*</span>
         <span class="s5">* To contrast the differences between semantic and syntactic diagnostics, consider the</span>
         <span class="s5">* sentence: &quot;The sun is green.&quot; is syntactically correct; those are real English words with</span>
         <span class="s5">* correct sentence structure. However, it is semantically invalid, because it is not true.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName A path to the file you want semantic diagnostics for</span>
         <span class="s5">*/</span>
        <span class="s1">getSemanticDiagnostics</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">Diagnostic</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets suggestion diagnostics for a specific file. These diagnostics tend to</span>
         <span class="s5">* proactively suggest refactors, as opposed to diagnostics that indicate</span>
         <span class="s5">* potentially incorrect runtime behavior.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName A path to the file you want semantic diagnostics for</span>
         <span class="s5">*/</span>
        <span class="s1">getSuggestionDiagnostics</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">DiagnosticWithLocation</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets global diagnostics related to the program configuration and compiler options.</span>
         <span class="s5">*/</span>
        <span class="s1">getCompilerOptionsDiagnostics</span><span class="s2">(): </span><span class="s1">Diagnostic</span><span class="s2">[];</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use getEncodedSyntacticClassifications instead. */</span>
        <span class="s1">getSyntacticClassifications</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">ClassifiedSpan</span><span class="s2">[];</span>
        <span class="s1">getSyntacticClassifications</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">format</span><span class="s2">: </span><span class="s1">SemanticClassificationFormat</span><span class="s2">): </span><span class="s1">ClassifiedSpan</span><span class="s2">[] | </span><span class="s1">ClassifiedSpan2020</span><span class="s2">[];</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use getEncodedSemanticClassifications instead. */</span>
        <span class="s1">getSemanticClassifications</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">ClassifiedSpan</span><span class="s2">[];</span>
        <span class="s1">getSemanticClassifications</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">format</span><span class="s2">: </span><span class="s1">SemanticClassificationFormat</span><span class="s2">): </span><span class="s1">ClassifiedSpan</span><span class="s2">[] | </span><span class="s1">ClassifiedSpan2020</span><span class="s2">[];</span>
        <span class="s5">/** Encoded as triples of [start, length, ClassificationType]. */</span>
        <span class="s1">getEncodedSyntacticClassifications</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">): </span><span class="s1">Classifications</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets semantic highlights information for a particular file. Has two formats, an older</span>
         <span class="s5">* version used by VS and a format used by VS Code.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The path to the file</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">position A text span to return results within</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">format Which format to use, defaults to &quot;original&quot;</span>
         <span class="s5">* </span><span class="s7">@returns </span><span class="s5">a number array encoded as triples of [start, length, ClassificationType, ...].</span>
         <span class="s5">*/</span>
        <span class="s1">getEncodedSemanticClassifications</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">format</span><span class="s2">?: </span><span class="s1">SemanticClassificationFormat</span><span class="s2">): </span><span class="s1">Classifications</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets completion entries at a particular position in a file.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The path to the file</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">position A zero-based index of the character where you want the entries</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">options An object describing how the request was triggered and what kinds</span>
         <span class="s5">* of code actions can be returned with the completions.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">formattingSettings settings needed for calling formatting functions.</span>
         <span class="s5">*/</span>
        <span class="s1">getCompletionsAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">GetCompletionsAtPositionOptions </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">formattingSettings</span><span class="s2">?: </span><span class="s1">FormatCodeSettings</span><span class="s2">): </span><span class="s1">WithMetadata</span><span class="s2">&lt;</span><span class="s1">CompletionInfo</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets the extended details for a completion entry retrieved from `getCompletionsAtPosition`.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The path to the file</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">position A zero based index of the character where you want the entries</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">entryName The `name` from an existing completion which came from `getCompletionsAtPosition`</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">formatOptions How should code samples in the completions be formatted, can be undefined for backwards compatibility</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">source `source` property from the completion entry</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">preferences User settings, can be undefined for backwards compatibility</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">data `data` property from the completion entry</span>
         <span class="s5">*/</span>
        <span class="s1">getCompletionEntryDetails</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">entryName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">formatOptions</span><span class="s2">: </span><span class="s1">FormatCodeOptions </span><span class="s2">| </span><span class="s1">FormatCodeSettings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">source</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">data</span><span class="s2">: </span><span class="s1">CompletionEntryData </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">CompletionEntryDetails </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getCompletionEntrySymbol</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">source</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">Symbol </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Gets semantic information about the identifier at a particular position in a</span>
         <span class="s5">* file. Quick info is what you typically see when you hover in an editor.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The path to the file</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">position A zero-based index of the character where you want the quick info</span>
         <span class="s5">*/</span>
        <span class="s1">getQuickInfoAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">QuickInfo </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getNameOrDottedNameSpan</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">startPos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">endPos</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">TextSpan </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getBreakpointStatementAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">TextSpan </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSignatureHelpItems</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">SignatureHelpItemsOptions </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SignatureHelpItems </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getRenameInfo</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences</span><span class="s2">): </span><span class="s1">RenameInfo</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use the signature with `UserPreferences` instead. */</span>
        <span class="s1">getRenameInfo</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">RenameInfoOptions</span><span class="s2">): </span><span class="s1">RenameInfo</span><span class="s2">;</span>
        <span class="s1">findRenameLocations</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">findInStrings</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">findInComments</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">providePrefixAndSuffixTextForRename</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">readonly RenameLocation</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSmartSelectionRange</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">SelectionRange</span><span class="s2">;</span>
        <span class="s1">getDefinitionAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">readonly DefinitionInfo</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getDefinitionAndBoundSpan</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">DefinitionInfoAndBoundSpan </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getTypeDefinitionAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">readonly DefinitionInfo</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getImplementationAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">readonly ImplementationLocation</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getReferencesAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">ReferenceEntry</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">findReferences</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">ReferencedSymbol</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getDocumentHighlights</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">filesToSearch</span><span class="s2">: </span><span class="s1">string</span><span class="s2">[]): </span><span class="s1">DocumentHighlights</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getFileReferences</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ReferenceEntry</span><span class="s2">[];</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">*/</span>
        <span class="s1">getOccurrencesAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">readonly ReferenceEntry</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getNavigateToItems</span><span class="s2">(</span><span class="s1">searchValue</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">maxResultCount</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">fileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">excludeDtsFiles</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">NavigateToItem</span><span class="s2">[];</span>
        <span class="s1">getNavigationBarItems</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">NavigationBarItem</span><span class="s2">[];</span>
        <span class="s1">getNavigationTree</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">NavigationTree</span><span class="s2">;</span>
        <span class="s1">prepareCallHierarchy</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">CallHierarchyItem </span><span class="s2">| </span><span class="s1">CallHierarchyItem</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">provideCallHierarchyIncomingCalls</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">CallHierarchyIncomingCall</span><span class="s2">[];</span>
        <span class="s1">provideCallHierarchyOutgoingCalls</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">CallHierarchyOutgoingCall</span><span class="s2">[];</span>
        <span class="s1">provideInlayHints</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">InlayHint</span><span class="s2">[];</span>
        <span class="s1">getOutliningSpans</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">OutliningSpan</span><span class="s2">[];</span>
        <span class="s1">getTodoComments</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">descriptors</span><span class="s2">: </span><span class="s1">TodoCommentDescriptor</span><span class="s2">[]): </span><span class="s1">TodoComment</span><span class="s2">[];</span>
        <span class="s1">getBraceMatchingAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">TextSpan</span><span class="s2">[];</span>
        <span class="s1">getIndentationAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">EditorOptions </span><span class="s2">| </span><span class="s1">EditorSettings</span><span class="s2">): </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">getFormattingEditsForRange</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">FormatCodeOptions </span><span class="s2">| </span><span class="s1">FormatCodeSettings</span><span class="s2">): </span><span class="s1">TextChange</span><span class="s2">[];</span>
        <span class="s1">getFormattingEditsForDocument</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">FormatCodeOptions </span><span class="s2">| </span><span class="s1">FormatCodeSettings</span><span class="s2">): </span><span class="s1">TextChange</span><span class="s2">[];</span>
        <span class="s1">getFormattingEditsAfterKeystroke</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">options</span><span class="s2">: </span><span class="s1">FormatCodeOptions </span><span class="s2">| </span><span class="s1">FormatCodeSettings</span><span class="s2">): </span><span class="s1">TextChange</span><span class="s2">[];</span>
        <span class="s1">getDocCommentTemplateAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">options</span><span class="s2">?: </span><span class="s1">DocCommentTemplateOptions</span><span class="s2">): </span><span class="s1">TextInsertion </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">isValidBraceCompletionAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">openingBrace</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* This will return a defined result if the position is after the `&gt;` of the opening tag, or somewhere in the text, of a JSXElement with no closing tag.</span>
         <span class="s5">* Editors should call this after `&gt;` is typed.</span>
         <span class="s5">*/</span>
        <span class="s1">getJsxClosingTagAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">JsxClosingTagInfo </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">getSpanOfEnclosingComment</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">onlyMultiLine</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">TextSpan </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">toLineColumnOffset</span><span class="s2">?(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">): </span><span class="s1">LineAndCharacter</span><span class="s2">;</span>
        <span class="s1">getCodeFixesAtPosition</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">start</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">end</span><span class="s2">: </span><span class="s1">number</span><span class="s2">, </span><span class="s1">errorCodes</span><span class="s2">: </span><span class="s1">readonly number</span><span class="s2">[], </span><span class="s1">formatOptions</span><span class="s2">: </span><span class="s1">FormatCodeSettings</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences</span><span class="s2">): </span><span class="s1">readonly CodeFixAction</span><span class="s2">[];</span>
        <span class="s1">getCombinedCodeFix</span><span class="s2">(</span><span class="s1">scope</span><span class="s2">: </span><span class="s1">CombinedCodeFixScope</span><span class="s2">, </span><span class="s1">fixId</span><span class="s2">: {}, </span><span class="s1">formatOptions</span><span class="s2">: </span><span class="s1">FormatCodeSettings</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences</span><span class="s2">): </span><span class="s1">CombinedCodeActions</span><span class="s2">;</span>
        <span class="s1">applyCodeActionCommand</span><span class="s2">(</span><span class="s1">action</span><span class="s2">: </span><span class="s1">CodeActionCommand</span><span class="s2">, </span><span class="s1">formatSettings</span><span class="s2">?: </span><span class="s1">FormatCodeSettings</span><span class="s2">): </span><span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">ApplyCodeActionCommandResult</span><span class="s2">&gt;;</span>
        <span class="s1">applyCodeActionCommand</span><span class="s2">(</span><span class="s1">action</span><span class="s2">: </span><span class="s1">CodeActionCommand</span><span class="s2">[], </span><span class="s1">formatSettings</span><span class="s2">?: </span><span class="s1">FormatCodeSettings</span><span class="s2">): </span><span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">ApplyCodeActionCommandResult</span><span class="s2">[]&gt;;</span>
        <span class="s1">applyCodeActionCommand</span><span class="s2">(</span><span class="s1">action</span><span class="s2">: </span><span class="s1">CodeActionCommand </span><span class="s2">| </span><span class="s1">CodeActionCommand</span><span class="s2">[], </span><span class="s1">formatSettings</span><span class="s2">?: </span><span class="s1">FormatCodeSettings</span><span class="s2">): </span><span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">ApplyCodeActionCommandResult </span><span class="s2">| </span><span class="s1">ApplyCodeActionCommandResult</span><span class="s2">[]&gt;;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">action</span><span class="s2">: </span><span class="s1">CodeActionCommand</span><span class="s2">): </span><span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">ApplyCodeActionCommandResult</span><span class="s2">&gt;;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">action</span><span class="s2">: </span><span class="s1">CodeActionCommand</span><span class="s2">[]): </span><span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">ApplyCodeActionCommandResult</span><span class="s2">[]&gt;;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">`fileName` will be ignored */</span>
        <span class="s1">applyCodeActionCommand</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">action</span><span class="s2">: </span><span class="s1">CodeActionCommand </span><span class="s2">| </span><span class="s1">CodeActionCommand</span><span class="s2">[]): </span><span class="s1">Promise</span><span class="s2">&lt;</span><span class="s1">ApplyCodeActionCommandResult </span><span class="s2">| </span><span class="s1">ApplyCodeActionCommandResult</span><span class="s2">[]&gt;;</span>
        <span class="s1">getApplicableRefactors</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">positionOrRange</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">TextRange</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">triggerReason</span><span class="s2">?: </span><span class="s1">RefactorTriggerReason</span><span class="s2">, </span><span class="s1">kind</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">ApplicableRefactorInfo</span><span class="s2">[];</span>
        <span class="s1">getEditsForRefactor</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">formatOptions</span><span class="s2">: </span><span class="s1">FormatCodeSettings</span><span class="s2">, </span><span class="s1">positionOrRange</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">TextRange</span><span class="s2">, </span><span class="s1">refactorName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">actionName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">RefactorEditInfo </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">organizeImports</span><span class="s2">(</span><span class="s1">args</span><span class="s2">: </span><span class="s1">OrganizeImportsArgs</span><span class="s2">, </span><span class="s1">formatOptions</span><span class="s2">: </span><span class="s1">FormatCodeSettings</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">readonly FileTextChanges</span><span class="s2">[];</span>
        <span class="s1">getEditsForFileRename</span><span class="s2">(</span><span class="s1">oldFilePath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">newFilePath</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">formatOptions</span><span class="s2">: </span><span class="s1">FormatCodeSettings</span><span class="s2">, </span><span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">readonly FileTextChanges</span><span class="s2">[];</span>
        <span class="s1">getEmitOutput</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">emitOnlyDtsFiles</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">forceDtsEmit</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">EmitOutput</span><span class="s2">;</span>
        <span class="s1">getProgram</span><span class="s2">(): </span><span class="s1">Program </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s1">toggleLineComment</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">textRange</span><span class="s2">: </span><span class="s1">TextRange</span><span class="s2">): </span><span class="s1">TextChange</span><span class="s2">[];</span>
        <span class="s1">toggleMultilineComment</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">textRange</span><span class="s2">: </span><span class="s1">TextRange</span><span class="s2">): </span><span class="s1">TextChange</span><span class="s2">[];</span>
        <span class="s1">commentSelection</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">textRange</span><span class="s2">: </span><span class="s1">TextRange</span><span class="s2">): </span><span class="s1">TextChange</span><span class="s2">[];</span>
        <span class="s1">uncommentSelection</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">textRange</span><span class="s2">: </span><span class="s1">TextRange</span><span class="s2">): </span><span class="s1">TextChange</span><span class="s2">[];</span>
        <span class="s1">dispose</span><span class="s2">(): </span><span class="s3">void</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">JsxClosingTagInfo </span><span class="s2">{</span>
        <span class="s1">readonly newText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CombinedCodeFixScope </span><span class="s2">{</span>
        <span class="s1">type</span><span class="s2">: </span><span class="s4">&quot;file&quot;</span><span class="s2">;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">OrganizeImportsMode </span><span class="s2">{</span>
        <span class="s1">All </span><span class="s2">= </span><span class="s4">&quot;All&quot;</span><span class="s2">,</span>
        <span class="s1">SortAndCombine </span><span class="s2">= </span><span class="s4">&quot;SortAndCombine&quot;</span><span class="s2">,</span>
        <span class="s1">RemoveUnused </span><span class="s2">= </span><span class="s4">&quot;RemoveUnused&quot;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">OrganizeImportsArgs </span><span class="s3">extends </span><span class="s1">CombinedCodeFixScope </span><span class="s2">{</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `mode` instead */</span>
        <span class="s1">skipDestructiveCodeActions</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">mode</span><span class="s2">?: </span><span class="s1">OrganizeImportsMode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">type CompletionsTriggerCharacter </span><span class="s2">= </span><span class="s4">&quot;.&quot; </span><span class="s2">| </span><span class="s4">'&quot;' </span><span class="s2">| </span><span class="s4">&quot;'&quot; </span><span class="s2">| </span><span class="s4">&quot;`&quot; </span><span class="s2">| </span><span class="s4">&quot;/&quot; </span><span class="s2">| </span><span class="s4">&quot;@&quot; </span><span class="s2">| </span><span class="s4">&quot;&lt;&quot; </span><span class="s2">| </span><span class="s4">&quot;#&quot; </span><span class="s2">| </span><span class="s4">&quot; &quot;</span><span class="s2">;</span>
    <span class="s3">enum </span><span class="s1">CompletionTriggerKind </span><span class="s2">{</span>
        <span class="s5">/** Completion was triggered by typing an identifier, manual invocation (e.g Ctrl+Space) or via API. */</span>
        <span class="s1">Invoked </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s5">/** Completion was triggered by a trigger character. */</span>
        <span class="s1">TriggerCharacter </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s5">/** Completion was re-triggered as the current completion list is incomplete. */</span>
        <span class="s1">TriggerForIncompleteCompletions </span><span class="s2">= </span><span class="s6">3</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">GetCompletionsAtPositionOptions </span><span class="s3">extends </span><span class="s1">UserPreferences </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* If the editor is asking for completions because a certain character was typed</span>
         <span class="s5">* (as opposed to when the user explicitly requested them) this should be set.</span>
         <span class="s5">*/</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s1">CompletionsTriggerCharacter</span><span class="s2">;</span>
        <span class="s1">triggerKind</span><span class="s2">?: </span><span class="s1">CompletionTriggerKind</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use includeCompletionsForModuleExports */</span>
        <span class="s1">includeExternalModuleExports</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use includeCompletionsWithInsertText */</span>
        <span class="s1">includeInsertTextCompletions</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">type SignatureHelpTriggerCharacter </span><span class="s2">= </span><span class="s4">&quot;,&quot; </span><span class="s2">| </span><span class="s4">&quot;(&quot; </span><span class="s2">| </span><span class="s4">&quot;&lt;&quot;</span><span class="s2">;</span>
    <span class="s1">type SignatureHelpRetriggerCharacter </span><span class="s2">= </span><span class="s1">SignatureHelpTriggerCharacter </span><span class="s2">| </span><span class="s4">&quot;)&quot;</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">SignatureHelpItemsOptions </span><span class="s2">{</span>
        <span class="s1">triggerReason</span><span class="s2">?: </span><span class="s1">SignatureHelpTriggerReason</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">type SignatureHelpTriggerReason </span><span class="s2">= </span><span class="s1">SignatureHelpInvokedReason </span><span class="s2">| </span><span class="s1">SignatureHelpCharacterTypedReason </span><span class="s2">| </span><span class="s1">SignatureHelpRetriggeredReason</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Signals that the user manually requested signature help.</span>
     <span class="s5">* The language service will unconditionally attempt to provide a result.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">SignatureHelpInvokedReason </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;invoked&quot;</span><span class="s2">;</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Signals that the signature help request came from a user typing a character.</span>
     <span class="s5">* Depending on the character and the syntactic context, the request may or may not be served a result.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">SignatureHelpCharacterTypedReason </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;characterTyped&quot;</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Character that was responsible for triggering signature help.</span>
         <span class="s5">*/</span>
        <span class="s1">triggerCharacter</span><span class="s2">: </span><span class="s1">SignatureHelpTriggerCharacter</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Signals that this signature help request came from typing a character or moving the cursor.</span>
     <span class="s5">* This should only occur if a signature help session was already active and the editor needs to see if it should adjust.</span>
     <span class="s5">* The language service will unconditionally attempt to provide a result.</span>
     <span class="s5">* `triggerCharacter` can be `undefined` for a retrigger caused by a cursor move.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">SignatureHelpRetriggeredReason </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s4">&quot;retrigger&quot;</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Character that was responsible for triggering signature help.</span>
         <span class="s5">*/</span>
        <span class="s1">triggerCharacter</span><span class="s2">?: </span><span class="s1">SignatureHelpRetriggerCharacter</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ApplyCodeActionCommandResult </span><span class="s2">{</span>
        <span class="s1">successMessage</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">Classifications </span><span class="s2">{</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s1">number</span><span class="s2">[];</span>
        <span class="s1">endOfLineState</span><span class="s2">: </span><span class="s1">EndOfLineState</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ClassifiedSpan </span><span class="s2">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">classificationType</span><span class="s2">: </span><span class="s1">ClassificationTypeNames</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ClassifiedSpan2020 </span><span class="s2">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">classificationType</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Navigation bar interface designed for visual studio's dual-column layout.</span>
     <span class="s5">* This does not form a proper tree.</span>
     <span class="s5">* The navbar is returned as a list of top-level items, each of which has a list of child items.</span>
     <span class="s5">* Child items always have an empty array for their `childItems`.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">NavigationBarItem </span><span class="s2">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">[];</span>
        <span class="s1">childItems</span><span class="s2">: </span><span class="s1">NavigationBarItem</span><span class="s2">[];</span>
        <span class="s1">indent</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">bolded</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">grayed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Node in a tree of nested declarations in a file.</span>
     <span class="s5">* The top node is always a script or module node.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">NavigationTree </span><span class="s2">{</span>
        <span class="s5">/** Name of the declaration, or a short description, e.g. &quot;&lt;class&gt;&quot;. */</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s5">/** ScriptElementKindModifier separated by commas, e.g. &quot;public,abstract&quot; */</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Spans of the nodes that generated this declaration.</span>
         <span class="s5">* There will be more than one if this is the result of merging.</span>
         <span class="s5">*/</span>
        <span class="s1">spans</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">[];</span>
        <span class="s1">nameSpan</span><span class="s2">: </span><span class="s1">TextSpan </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** Present if non-empty */</span>
        <span class="s1">childItems</span><span class="s2">?: </span><span class="s1">NavigationTree</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CallHierarchyItem </span><span class="s2">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">kindModifiers</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">selectionSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">containerName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CallHierarchyIncomingCall </span><span class="s2">{</span>
        <span class="s1">from</span><span class="s2">: </span><span class="s1">CallHierarchyItem</span><span class="s2">;</span>
        <span class="s1">fromSpans</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CallHierarchyOutgoingCall </span><span class="s2">{</span>
        <span class="s1">to</span><span class="s2">: </span><span class="s1">CallHierarchyItem</span><span class="s2">;</span>
        <span class="s1">fromSpans</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">InlayHintKind </span><span class="s2">{</span>
        <span class="s1">Type </span><span class="s2">= </span><span class="s4">&quot;Type&quot;</span><span class="s2">,</span>
        <span class="s1">Parameter </span><span class="s2">= </span><span class="s4">&quot;Parameter&quot;</span><span class="s2">,</span>
        <span class="s1">Enum </span><span class="s2">= </span><span class="s4">&quot;Enum&quot;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">InlayHint </span><span class="s2">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">InlayHintKind</span><span class="s2">;</span>
        <span class="s1">whitespaceBefore</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">whitespaceAfter</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">TodoCommentDescriptor </span><span class="s2">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">priority</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">TodoComment </span><span class="s2">{</span>
        <span class="s1">descriptor</span><span class="s2">: </span><span class="s1">TodoCommentDescriptor</span><span class="s2">;</span>
        <span class="s1">message</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">position</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">TextChange </span><span class="s2">{</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">newText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">FileTextChanges </span><span class="s2">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">textChanges</span><span class="s2">: </span><span class="s1">readonly TextChange</span><span class="s2">[];</span>
        <span class="s1">isNewFile</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CodeAction </span><span class="s2">{</span>
        <span class="s5">/** Description of the code action to display in the UI of the editor */</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** Text changes to apply to each file as part of the code action */</span>
        <span class="s1">changes</span><span class="s2">: </span><span class="s1">FileTextChanges</span><span class="s2">[];</span>
        <span class="s5">/**</span>
         <span class="s5">* If the user accepts the code fix, the editor should send the action back in a `applyAction` request.</span>
         <span class="s5">* This allows the language service to have side effects (e.g. installing dependencies) upon a code fix.</span>
         <span class="s5">*/</span>
        <span class="s1">commands</span><span class="s2">?: </span><span class="s1">CodeActionCommand</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CodeFixAction </span><span class="s3">extends </span><span class="s1">CodeAction </span><span class="s2">{</span>
        <span class="s5">/** Short name to identify the fix, for use by telemetry. */</span>
        <span class="s1">fixName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* If present, one may call 'getCombinedCodeFix' with this fixId.</span>
         <span class="s5">* This may be omitted to indicate that the code fix can't be applied in a group.</span>
         <span class="s5">*/</span>
        <span class="s1">fixId</span><span class="s2">?: {};</span>
        <span class="s1">fixAllDescription</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CombinedCodeActions </span><span class="s2">{</span>
        <span class="s1">changes</span><span class="s2">: </span><span class="s1">readonly FileTextChanges</span><span class="s2">[];</span>
        <span class="s1">commands</span><span class="s2">?: </span><span class="s1">readonly CodeActionCommand</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s1">type CodeActionCommand </span><span class="s2">= </span><span class="s1">InstallPackageAction</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">InstallPackageAction </span><span class="s2">{</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* A set of one or more available refactoring actions, grouped under a parent refactoring.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">ApplicableRefactorInfo </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* The programmatic name of the refactoring</span>
         <span class="s5">*/</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* A description of this refactoring category to show to the user.</span>
         <span class="s5">* If the refactoring gets inlined (see below), this text will not be visible.</span>
         <span class="s5">*/</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Inlineable refactorings can have their actions hoisted out to the top level</span>
         <span class="s5">* of a context menu. Non-inlineanable refactorings should always be shown inside</span>
         <span class="s5">* their parent grouping.</span>
         <span class="s5">*</span>
         <span class="s5">* If not specified, this value is assumed to be 'true'</span>
         <span class="s5">*/</span>
        <span class="s1">inlineable</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">actions</span><span class="s2">: </span><span class="s1">RefactorActionInfo</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Represents a single refactoring action - for example, the &quot;Extract Method...&quot; refactor might</span>
     <span class="s5">* offer several actions, each corresponding to a surround class or closure to extract into.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">RefactorActionInfo </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* The programmatic name of the refactoring action</span>
         <span class="s5">*/</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* A description of this refactoring action to show to the user.</span>
         <span class="s5">* If the parent refactoring is inlined away, this will be the only text shown,</span>
         <span class="s5">* so this description should make sense by itself if the parent is inlineable=true</span>
         <span class="s5">*/</span>
        <span class="s1">description</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* A message to show to the user if the refactoring cannot be applied in</span>
         <span class="s5">* the current context.</span>
         <span class="s5">*/</span>
        <span class="s1">notApplicableReason</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* The hierarchical dotted name of the refactor action.</span>
         <span class="s5">*/</span>
        <span class="s1">kind</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* A set of edits to make in response to a refactor action, plus an optional</span>
     <span class="s5">* location where renaming should be invoked from</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">RefactorEditInfo </span><span class="s2">{</span>
        <span class="s1">edits</span><span class="s2">: </span><span class="s1">FileTextChanges</span><span class="s2">[];</span>
        <span class="s1">renameFilename</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">renameLocation</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">commands</span><span class="s2">?: </span><span class="s1">CodeActionCommand</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s1">type RefactorTriggerReason </span><span class="s2">= </span><span class="s4">&quot;implicit&quot; </span><span class="s2">| </span><span class="s4">&quot;invoked&quot;</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">TextInsertion </span><span class="s2">{</span>
        <span class="s1">newText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** The position in newText the caret should point to after the insertion. */</span>
        <span class="s1">caretOffset</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">DocumentSpan </span><span class="s2">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* If the span represents a location that was remapped (e.g. via a .d.ts.map file),</span>
         <span class="s5">* then the original filename and span will be specified here</span>
         <span class="s5">*/</span>
        <span class="s1">originalTextSpan</span><span class="s2">?: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">originalFileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* If DocumentSpan.textSpan is the span for name of the declaration,</span>
         <span class="s5">* then this is the span for relevant declaration</span>
         <span class="s5">*/</span>
        <span class="s1">contextSpan</span><span class="s2">?: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">originalContextSpan</span><span class="s2">?: </span><span class="s1">TextSpan</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">RenameLocation </span><span class="s3">extends </span><span class="s1">DocumentSpan </span><span class="s2">{</span>
        <span class="s1">readonly prefixText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">readonly suffixText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ReferenceEntry </span><span class="s3">extends </span><span class="s1">DocumentSpan </span><span class="s2">{</span>
        <span class="s1">isWriteAccess</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isInString</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ImplementationLocation </span><span class="s3">extends </span><span class="s1">DocumentSpan </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">HighlightSpanKind </span><span class="s2">{</span>
        <span class="s1">none </span><span class="s2">= </span><span class="s4">&quot;none&quot;</span><span class="s2">,</span>
        <span class="s1">definition </span><span class="s2">= </span><span class="s4">&quot;definition&quot;</span><span class="s2">,</span>
        <span class="s1">reference </span><span class="s2">= </span><span class="s4">&quot;reference&quot;</span><span class="s2">,</span>
        <span class="s1">writtenReference </span><span class="s2">= </span><span class="s4">&quot;writtenReference&quot;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">HighlightSpan </span><span class="s2">{</span>
        <span class="s1">fileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">isInString</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">contextSpan</span><span class="s2">?: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">HighlightSpanKind</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">NavigateToItem </span><span class="s2">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">matchKind</span><span class="s2">: </span><span class="s4">&quot;exact&quot; </span><span class="s2">| </span><span class="s4">&quot;prefix&quot; </span><span class="s2">| </span><span class="s4">&quot;substring&quot; </span><span class="s2">| </span><span class="s4">&quot;camelCase&quot;</span><span class="s2">;</span>
        <span class="s1">isCaseSensitive</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">containerName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">containerKind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">IndentStyle </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Block </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Smart </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">SemicolonPreference </span><span class="s2">{</span>
        <span class="s1">Ignore </span><span class="s2">= </span><span class="s4">&quot;ignore&quot;</span><span class="s2">,</span>
        <span class="s1">Insert </span><span class="s2">= </span><span class="s4">&quot;insert&quot;</span><span class="s2">,</span>
        <span class="s1">Remove </span><span class="s2">= </span><span class="s4">&quot;remove&quot;</span>
    <span class="s2">}</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">- consider using EditorSettings instead */</span>
    <span class="s3">interface </span><span class="s1">EditorOptions </span><span class="s2">{</span>
        <span class="s1">BaseIndentSize</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">IndentSize</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">TabSize</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">NewLineCharacter</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">ConvertTabsToSpaces</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">IndentStyle</span><span class="s2">: </span><span class="s1">IndentStyle</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">EditorSettings </span><span class="s2">{</span>
        <span class="s1">baseIndentSize</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">indentSize</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">tabSize</span><span class="s2">?: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">newLineCharacter</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">convertTabsToSpaces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">indentStyle</span><span class="s2">?: </span><span class="s1">IndentStyle</span><span class="s2">;</span>
        <span class="s1">trimTrailingWhitespace</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">- consider using FormatCodeSettings instead */</span>
    <span class="s3">interface </span><span class="s1">FormatCodeOptions </span><span class="s3">extends </span><span class="s1">EditorOptions </span><span class="s2">{</span>
        <span class="s1">InsertSpaceAfterCommaDelimiter</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterSemicolonInForStatements</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceBeforeAndAfterBinaryOperators</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterConstructor</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterKeywordsInControlFlowStatements</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterFunctionKeywordForAnonymousFunctions</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingNonemptyBraces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceAfterTypeAssertion</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">InsertSpaceBeforeFunctionParenthesis</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">PlaceOpenBraceOnNewLineForFunctions</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">PlaceOpenBraceOnNewLineForControlBlocks</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">insertSpaceBeforeTypeAnnotation</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">FormatCodeSettings </span><span class="s3">extends </span><span class="s1">EditorSettings </span><span class="s2">{</span>
        <span class="s1">readonly insertSpaceAfterCommaDelimiter</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterSemicolonInForStatements</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceBeforeAndAfterBinaryOperators</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterConstructor</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterKeywordsInControlFlowStatements</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterFunctionKeywordForAnonymousFunctions</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingEmptyBraces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterOpeningAndBeforeClosingJsxExpressionBraces</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceAfterTypeAssertion</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceBeforeFunctionParenthesis</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly placeOpenBraceOnNewLineForFunctions</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly placeOpenBraceOnNewLineForControlBlocks</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly insertSpaceBeforeTypeAnnotation</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly indentMultiLineObjectLiteralBeginningOnBlankLine</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">readonly semicolons</span><span class="s2">?: </span><span class="s1">SemicolonPreference</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">function </span><span class="s1">getDefaultFormatCodeSettings</span><span class="s2">(</span><span class="s1">newLineCharacter</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">FormatCodeSettings</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">DefinitionInfo </span><span class="s3">extends </span><span class="s1">DocumentSpan </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">containerKind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">containerName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">unverified</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">DefinitionInfoAndBoundSpan </span><span class="s2">{</span>
        <span class="s1">definitions</span><span class="s2">?: </span><span class="s1">readonly DefinitionInfo</span><span class="s2">[];</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ReferencedSymbolDefinitionInfo </span><span class="s3">extends </span><span class="s1">DefinitionInfo </span><span class="s2">{</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ReferencedSymbol </span><span class="s2">{</span>
        <span class="s1">definition</span><span class="s2">: </span><span class="s1">ReferencedSymbolDefinitionInfo</span><span class="s2">;</span>
        <span class="s1">references</span><span class="s2">: </span><span class="s1">ReferencedSymbolEntry</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ReferencedSymbolEntry </span><span class="s3">extends </span><span class="s1">ReferenceEntry </span><span class="s2">{</span>
        <span class="s1">isDefinition</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">SymbolDisplayPartKind </span><span class="s2">{</span>
        <span class="s1">aliasName </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">className </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">enumName </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">fieldName </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">interfaceName </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">keyword </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">lineBreak </span><span class="s2">= </span><span class="s6">6</span><span class="s2">,</span>
        <span class="s1">numericLiteral </span><span class="s2">= </span><span class="s6">7</span><span class="s2">,</span>
        <span class="s1">stringLiteral </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">localName </span><span class="s2">= </span><span class="s6">9</span><span class="s2">,</span>
        <span class="s1">methodName </span><span class="s2">= </span><span class="s6">10</span><span class="s2">,</span>
        <span class="s1">moduleName </span><span class="s2">= </span><span class="s6">11</span><span class="s2">,</span>
        <span class="s1">operator </span><span class="s2">= </span><span class="s6">12</span><span class="s2">,</span>
        <span class="s1">parameterName </span><span class="s2">= </span><span class="s6">13</span><span class="s2">,</span>
        <span class="s1">propertyName </span><span class="s2">= </span><span class="s6">14</span><span class="s2">,</span>
        <span class="s1">punctuation </span><span class="s2">= </span><span class="s6">15</span><span class="s2">,</span>
        <span class="s1">space </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">text </span><span class="s2">= </span><span class="s6">17</span><span class="s2">,</span>
        <span class="s1">typeParameterName </span><span class="s2">= </span><span class="s6">18</span><span class="s2">,</span>
        <span class="s1">enumMemberName </span><span class="s2">= </span><span class="s6">19</span><span class="s2">,</span>
        <span class="s1">functionName </span><span class="s2">= </span><span class="s6">20</span><span class="s2">,</span>
        <span class="s1">regularExpressionLiteral </span><span class="s2">= </span><span class="s6">21</span><span class="s2">,</span>
        <span class="s1">link </span><span class="s2">= </span><span class="s6">22</span><span class="s2">,</span>
        <span class="s1">linkName </span><span class="s2">= </span><span class="s6">23</span><span class="s2">,</span>
        <span class="s1">linkText </span><span class="s2">= </span><span class="s6">24</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SymbolDisplayPart </span><span class="s2">{</span>
        <span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">JSDocLinkDisplayPart </span><span class="s3">extends </span><span class="s1">SymbolDisplayPart </span><span class="s2">{</span>
        <span class="s1">target</span><span class="s2">: </span><span class="s1">DocumentSpan</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">JSDocTagInfo </span><span class="s2">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">text</span><span class="s2">?: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">QuickInfo </span><span class="s2">{</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">displayParts</span><span class="s2">?: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">documentation</span><span class="s2">?: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">tags</span><span class="s2">?: </span><span class="s1">JSDocTagInfo</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s1">type RenameInfo </span><span class="s2">= </span><span class="s1">RenameInfoSuccess </span><span class="s2">| </span><span class="s1">RenameInfoFailure</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">RenameInfoSuccess </span><span class="s2">{</span>
        <span class="s1">canRename</span><span class="s2">: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* File or directory to rename.</span>
         <span class="s5">* If set, `getEditsForFileRename` should be called instead of `findRenameLocations`.</span>
         <span class="s5">*/</span>
        <span class="s1">fileToRename</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">displayName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">fullDisplayName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">triggerSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">RenameInfoFailure </span><span class="s2">{</span>
        <span class="s1">canRename</span><span class="s2">: </span><span class="s3">false</span><span class="s2">;</span>
        <span class="s1">localizedErrorMessage</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Use `UserPreferences` instead.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">RenameInfoOptions </span><span class="s2">{</span>
        <span class="s1">readonly allowRenameOfImportPath</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">DocCommentTemplateOptions </span><span class="s2">{</span>
        <span class="s1">readonly generateReturnInDocTemplate</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SignatureHelpParameter </span><span class="s2">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">documentation</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">isOptional</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isRest</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">SelectionRange </span><span class="s2">{</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">parent</span><span class="s2">?: </span><span class="s1">SelectionRange</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Represents a single signature to show in signature help.</span>
     <span class="s5">* The id is used for subsequent calls into the language service to ask questions about the</span>
     <span class="s5">* signature help item in the context of any documents that have been updated.  i.e. after</span>
     <span class="s5">* an edit has happened, while signature help is still active, the host can ask important</span>
     <span class="s5">* questions like 'what parameter is the user currently contained within?'.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">SignatureHelpItem </span><span class="s2">{</span>
        <span class="s1">isVariadic</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">prefixDisplayParts</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">suffixDisplayParts</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">separatorDisplayParts</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">parameters</span><span class="s2">: </span><span class="s1">SignatureHelpParameter</span><span class="s2">[];</span>
        <span class="s1">documentation</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">tags</span><span class="s2">: </span><span class="s1">JSDocTagInfo</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* Represents a set of signature help items, and the preferred item that should be selected.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">SignatureHelpItems </span><span class="s2">{</span>
        <span class="s1">items</span><span class="s2">: </span><span class="s1">SignatureHelpItem</span><span class="s2">[];</span>
        <span class="s1">applicableSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">selectedItemIndex</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">argumentIndex</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">argumentCount</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">CompletionInfoFlags </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">MayIncludeAutoImports </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">IsImportStatementCompletion </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">IsContinuation </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">ResolvedModuleSpecifiers </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">ResolvedModuleSpecifiersBeyondLimit </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">MayIncludeMethodSnippets </span><span class="s2">= </span><span class="s6">32</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CompletionInfo </span><span class="s2">{</span>
        <span class="s5">/** For performance telemetry. */</span>
        <span class="s1">flags</span><span class="s2">?: </span><span class="s1">CompletionInfoFlags</span><span class="s2">;</span>
        <span class="s5">/** Not true for all global completions. This will be true if the enclosing scope matches a few syntax kinds. See `isSnippetScope`. */</span>
        <span class="s1">isGlobalCompletion</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">isMemberCompletion</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* In the absence of `CompletionEntry[&quot;replacementSpan&quot;]`, the editor may choose whether to use</span>
         <span class="s5">* this span or its default one. If `CompletionEntry[&quot;replacementSpan&quot;]` is defined, that span</span>
         <span class="s5">* must be used to commit that completion entry.</span>
         <span class="s5">*/</span>
        <span class="s1">optionalReplacementSpan</span><span class="s2">?: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* true when the current location also allows for a new identifier</span>
         <span class="s5">*/</span>
        <span class="s1">isNewIdentifierLocation</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Indicates to client to continue requesting completions on subsequent keystrokes.</span>
         <span class="s5">*/</span>
        <span class="s1">isIncomplete</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s1">entries</span><span class="s2">: </span><span class="s1">CompletionEntry</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CompletionEntryDataAutoImport </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* The name of the property or export in the module's symbol table. Differs from the completion name</span>
         <span class="s5">* in the case of InternalSymbolName.ExportEquals and InternalSymbolName.Default.</span>
         <span class="s5">*/</span>
        <span class="s1">exportName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">moduleSpecifier</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** The file name declaring the export's module symbol, if it was an external module */</span>
        <span class="s1">fileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** The module name (with quotes stripped) of the export's module symbol, if it was an ambient module */</span>
        <span class="s1">ambientModuleName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/** True if the export was found in the package.json AutoImportProvider */</span>
        <span class="s1">isPackageJsonImport</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CompletionEntryDataUnresolved </span><span class="s3">extends </span><span class="s1">CompletionEntryDataAutoImport </span><span class="s2">{</span>
        <span class="s5">/** The key in the `ExportMapCache` where the completion entry's `SymbolExportInfo[]` is found */</span>
        <span class="s1">exportMapKey</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CompletionEntryDataResolved </span><span class="s3">extends </span><span class="s1">CompletionEntryDataAutoImport </span><span class="s2">{</span>
        <span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">type CompletionEntryData </span><span class="s2">= </span><span class="s1">CompletionEntryDataUnresolved </span><span class="s2">| </span><span class="s1">CompletionEntryDataResolved</span><span class="s2">;</span>
    <span class="s3">interface </span><span class="s1">CompletionEntry </span><span class="s2">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">kindModifiers</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">sortText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">insertText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">isSnippet</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* An optional span that indicates the text to be replaced by this completion item.</span>
         <span class="s5">* If present, this span should be used instead of the default one.</span>
         <span class="s5">* It will be set if the required span differs from the one generated by the default replacement behavior.</span>
         <span class="s5">*/</span>
        <span class="s1">replacementSpan</span><span class="s2">?: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">hasAction</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">sourceDisplay</span><span class="s2">?: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">labelDetails</span><span class="s2">?: </span><span class="s1">CompletionEntryLabelDetails</span><span class="s2">;</span>
        <span class="s1">isRecommended</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s1">isFromUncheckedFile</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s1">isPackageJsonImport</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s1">isImportStatementCompletion</span><span class="s2">?: </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* A property to be sent back to TS Server in the CompletionDetailsRequest, along with `name`,</span>
         <span class="s5">* that allows TS Server to look up the symbol represented by the completion item, disambiguating</span>
         <span class="s5">* items with the same name. Currently only defined for auto-import completions, but the type is</span>
         <span class="s5">* `unknown` in the protocol, so it can be changed as needed to support other kinds of completions.</span>
         <span class="s5">* The presence of this property should generally not be used to assume that this completion entry</span>
         <span class="s5">* is an auto-import.</span>
         <span class="s5">*/</span>
        <span class="s1">data</span><span class="s2">?: </span><span class="s1">CompletionEntryData</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CompletionEntryLabelDetails </span><span class="s2">{</span>
        <span class="s1">detail</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">description</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">CompletionEntryDetails </span><span class="s2">{</span>
        <span class="s1">name</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">ScriptElementKind</span><span class="s2">;</span>
        <span class="s1">kindModifiers</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">displayParts</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">documentation</span><span class="s2">?: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">tags</span><span class="s2">?: </span><span class="s1">JSDocTagInfo</span><span class="s2">[];</span>
        <span class="s1">codeActions</span><span class="s2">?: </span><span class="s1">CodeAction</span><span class="s2">[];</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `sourceDisplay` instead. */</span>
        <span class="s1">source</span><span class="s2">?: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
        <span class="s1">sourceDisplay</span><span class="s2">?: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">OutliningSpan </span><span class="s2">{</span>
        <span class="s5">/** The span of the document to actually collapse. */</span>
        <span class="s1">textSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s5">/** The span of the document to display when the user hovers over the collapsed span. */</span>
        <span class="s1">hintSpan</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s5">/** The text to display in the editor for the collapsed region. */</span>
        <span class="s1">bannerText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Whether or not this region should be automatically collapsed when</span>
         <span class="s5">* the 'Collapse to Definitions' command is invoked.</span>
         <span class="s5">*/</span>
        <span class="s1">autoCollapse</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Classification of the contents of the span</span>
         <span class="s5">*/</span>
        <span class="s1">kind</span><span class="s2">: </span><span class="s1">OutliningSpanKind</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">OutliningSpanKind </span><span class="s2">{</span>
        <span class="s5">/** Single or multi-line comments */</span>
        <span class="s1">Comment </span><span class="s2">= </span><span class="s4">&quot;comment&quot;</span><span class="s2">,</span>
        <span class="s5">/** Sections marked by '// #region' and '// #endregion' comments */</span>
        <span class="s1">Region </span><span class="s2">= </span><span class="s4">&quot;region&quot;</span><span class="s2">,</span>
        <span class="s5">/** Declarations and expressions */</span>
        <span class="s1">Code </span><span class="s2">= </span><span class="s4">&quot;code&quot;</span><span class="s2">,</span>
        <span class="s5">/** Contiguous blocks of import declarations */</span>
        <span class="s1">Imports </span><span class="s2">= </span><span class="s4">&quot;imports&quot;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">OutputFileType </span><span class="s2">{</span>
        <span class="s1">JavaScript </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">SourceMap </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Declaration </span><span class="s2">= </span><span class="s6">2</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">EndOfLineState </span><span class="s2">{</span>
        <span class="s1">None </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">InMultiLineCommentTrivia </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">InSingleQuoteStringLiteral </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">InDoubleQuoteStringLiteral </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">InTemplateHeadOrNoSubstitutionTemplate </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">InTemplateMiddleOrTail </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">InTemplateSubstitutionPosition </span><span class="s2">= </span><span class="s6">6</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">TokenClass </span><span class="s2">{</span>
        <span class="s1">Punctuation </span><span class="s2">= </span><span class="s6">0</span><span class="s2">,</span>
        <span class="s1">Keyword </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">Operator </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">Comment </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">Whitespace </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">Identifier </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">NumberLiteral </span><span class="s2">= </span><span class="s6">6</span><span class="s2">,</span>
        <span class="s1">BigIntLiteral </span><span class="s2">= </span><span class="s6">7</span><span class="s2">,</span>
        <span class="s1">StringLiteral </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">RegExpLiteral </span><span class="s2">= </span><span class="s6">9</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ClassificationResult </span><span class="s2">{</span>
        <span class="s1">finalLexState</span><span class="s2">: </span><span class="s1">EndOfLineState</span><span class="s2">;</span>
        <span class="s1">entries</span><span class="s2">: </span><span class="s1">ClassificationInfo</span><span class="s2">[];</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ClassificationInfo </span><span class="s2">{</span>
        <span class="s1">length</span><span class="s2">: </span><span class="s1">number</span><span class="s2">;</span>
        <span class="s1">classification</span><span class="s2">: </span><span class="s1">TokenClass</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">Classifier </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Gives lexical classifications of tokens on a line without any syntactic context.</span>
         <span class="s5">* For instance, a token consisting of the text 'string' can be either an identifier</span>
         <span class="s5">* named 'string' or the keyword 'string', however, because this classifier is not aware,</span>
         <span class="s5">* it relies on certain heuristics to give acceptable results. For classifications where</span>
         <span class="s5">* speed trumps accuracy, this function is preferable; however, for true accuracy, the</span>
         <span class="s5">* syntactic classifier is ideal. In fact, in certain editing scenarios, combining the</span>
         <span class="s5">* lexical, syntactic, and semantic classifiers may issue the best user experience.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">text                      The text of a line to classify.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">lexState                  The state of the lexical classifier at the end of the previous line.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">syntacticClassifierAbsent Whether the client is *not* using a syntactic classifier.</span>
         <span class="s5">*                                  If there is no syntactic classifier (syntacticClassifierAbsent=true),</span>
         <span class="s5">*                                  certain heuristics may be used in its place; however, if there is a</span>
         <span class="s5">*                                  syntactic classifier (syntacticClassifierAbsent=false), certain</span>
         <span class="s5">*                                  classifications which may be incorrectly categorized will be given</span>
         <span class="s5">*                                  back as Identifiers in order to allow the syntactic classifier to</span>
         <span class="s5">*                                  subsume the classification.</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Use getLexicalClassifications instead.</span>
         <span class="s5">*/</span>
        <span class="s1">getClassificationsForLine</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">lexState</span><span class="s2">: </span><span class="s1">EndOfLineState</span><span class="s2">, </span><span class="s1">syntacticClassifierAbsent</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ClassificationResult</span><span class="s2">;</span>
        <span class="s1">getEncodedLexicalClassifications</span><span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">endOfLineState</span><span class="s2">: </span><span class="s1">EndOfLineState</span><span class="s2">, </span><span class="s1">syntacticClassifierAbsent</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">Classifications</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">ScriptElementKind </span><span class="s2">{</span>
        <span class="s1">unknown </span><span class="s2">= </span><span class="s4">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">warning </span><span class="s2">= </span><span class="s4">&quot;warning&quot;</span><span class="s2">,</span>
        <span class="s5">/** predefined type (void) or keyword (class) */</span>
        <span class="s1">keyword </span><span class="s2">= </span><span class="s4">&quot;keyword&quot;</span><span class="s2">,</span>
        <span class="s5">/** top level script node */</span>
        <span class="s1">scriptElement </span><span class="s2">= </span><span class="s4">&quot;script&quot;</span><span class="s2">,</span>
        <span class="s5">/** module foo {} */</span>
        <span class="s1">moduleElement </span><span class="s2">= </span><span class="s4">&quot;module&quot;</span><span class="s2">,</span>
        <span class="s5">/** class X {} */</span>
        <span class="s1">classElement </span><span class="s2">= </span><span class="s4">&quot;class&quot;</span><span class="s2">,</span>
        <span class="s5">/** var x = class X {} */</span>
        <span class="s1">localClassElement </span><span class="s2">= </span><span class="s4">&quot;local class&quot;</span><span class="s2">,</span>
        <span class="s5">/** interface Y {} */</span>
        <span class="s1">interfaceElement </span><span class="s2">= </span><span class="s4">&quot;interface&quot;</span><span class="s2">,</span>
        <span class="s5">/** type T = ... */</span>
        <span class="s1">typeElement </span><span class="s2">= </span><span class="s4">&quot;type&quot;</span><span class="s2">,</span>
        <span class="s5">/** enum E */</span>
        <span class="s1">enumElement </span><span class="s2">= </span><span class="s4">&quot;enum&quot;</span><span class="s2">,</span>
        <span class="s1">enumMemberElement </span><span class="s2">= </span><span class="s4">&quot;enum member&quot;</span><span class="s2">,</span>
        <span class="s5">/**</span>
         <span class="s5">* Inside module and script only</span>
         <span class="s5">* const v = ..</span>
         <span class="s5">*/</span>
        <span class="s1">variableElement </span><span class="s2">= </span><span class="s4">&quot;var&quot;</span><span class="s2">,</span>
        <span class="s5">/** Inside function */</span>
        <span class="s1">localVariableElement </span><span class="s2">= </span><span class="s4">&quot;local var&quot;</span><span class="s2">,</span>
        <span class="s5">/**</span>
         <span class="s5">* Inside module and script only</span>
         <span class="s5">* function f() { }</span>
         <span class="s5">*/</span>
        <span class="s1">functionElement </span><span class="s2">= </span><span class="s4">&quot;function&quot;</span><span class="s2">,</span>
        <span class="s5">/** Inside function */</span>
        <span class="s1">localFunctionElement </span><span class="s2">= </span><span class="s4">&quot;local function&quot;</span><span class="s2">,</span>
        <span class="s5">/** class X { [public|private]* foo() {} } */</span>
        <span class="s1">memberFunctionElement </span><span class="s2">= </span><span class="s4">&quot;method&quot;</span><span class="s2">,</span>
        <span class="s5">/** class X { [public|private]* [get|set] foo:number; } */</span>
        <span class="s1">memberGetAccessorElement </span><span class="s2">= </span><span class="s4">&quot;getter&quot;</span><span class="s2">,</span>
        <span class="s1">memberSetAccessorElement </span><span class="s2">= </span><span class="s4">&quot;setter&quot;</span><span class="s2">,</span>
        <span class="s5">/**</span>
         <span class="s5">* class X { [public|private]* foo:number; }</span>
         <span class="s5">* interface Y { foo:number; }</span>
         <span class="s5">*/</span>
        <span class="s1">memberVariableElement </span><span class="s2">= </span><span class="s4">&quot;property&quot;</span><span class="s2">,</span>
        <span class="s5">/** class X { [public|private]* accessor foo: number; } */</span>
        <span class="s1">memberAccessorVariableElement </span><span class="s2">= </span><span class="s4">&quot;accessor&quot;</span><span class="s2">,</span>
        <span class="s5">/**</span>
         <span class="s5">* class X { constructor() { } }</span>
         <span class="s5">* class X { static { } }</span>
         <span class="s5">*/</span>
        <span class="s1">constructorImplementationElement </span><span class="s2">= </span><span class="s4">&quot;constructor&quot;</span><span class="s2">,</span>
        <span class="s5">/** interface Y { ():number; } */</span>
        <span class="s1">callSignatureElement </span><span class="s2">= </span><span class="s4">&quot;call&quot;</span><span class="s2">,</span>
        <span class="s5">/** interface Y { []:number; } */</span>
        <span class="s1">indexSignatureElement </span><span class="s2">= </span><span class="s4">&quot;index&quot;</span><span class="s2">,</span>
        <span class="s5">/** interface Y { new():Y; } */</span>
        <span class="s1">constructSignatureElement </span><span class="s2">= </span><span class="s4">&quot;construct&quot;</span><span class="s2">,</span>
        <span class="s5">/** function foo(*Y*: string) */</span>
        <span class="s1">parameterElement </span><span class="s2">= </span><span class="s4">&quot;parameter&quot;</span><span class="s2">,</span>
        <span class="s1">typeParameterElement </span><span class="s2">= </span><span class="s4">&quot;type parameter&quot;</span><span class="s2">,</span>
        <span class="s1">primitiveType </span><span class="s2">= </span><span class="s4">&quot;primitive type&quot;</span><span class="s2">,</span>
        <span class="s1">label </span><span class="s2">= </span><span class="s4">&quot;label&quot;</span><span class="s2">,</span>
        <span class="s1">alias </span><span class="s2">= </span><span class="s4">&quot;alias&quot;</span><span class="s2">,</span>
        <span class="s1">constElement </span><span class="s2">= </span><span class="s4">&quot;const&quot;</span><span class="s2">,</span>
        <span class="s1">letElement </span><span class="s2">= </span><span class="s4">&quot;let&quot;</span><span class="s2">,</span>
        <span class="s1">directory </span><span class="s2">= </span><span class="s4">&quot;directory&quot;</span><span class="s2">,</span>
        <span class="s1">externalModuleName </span><span class="s2">= </span><span class="s4">&quot;external module name&quot;</span><span class="s2">,</span>
        <span class="s5">/**</span>
         <span class="s5">* &lt;JsxTagName attribute1 attribute2={0} /&gt;</span>
         <span class="s5">* </span><span class="s7">@deprecated</span>
         <span class="s5">*/</span>
        <span class="s1">jsxAttribute </span><span class="s2">= </span><span class="s4">&quot;JSX attribute&quot;</span><span class="s2">,</span>
        <span class="s5">/** String literal */</span>
        <span class="s1">string </span><span class="s2">= </span><span class="s4">&quot;string&quot;</span><span class="s2">,</span>
        <span class="s5">/** Jsdoc @link: in `{@link C link text}`, the before and after text &quot;{</span><span class="s7">@link </span><span class="s5">&quot; and &quot;}&quot; */</span>
        <span class="s1">link </span><span class="s2">= </span><span class="s4">&quot;link&quot;</span><span class="s2">,</span>
        <span class="s5">/** Jsdoc @link: in `{@link C link text}`, the entity name &quot;C&quot; */</span>
        <span class="s1">linkName </span><span class="s2">= </span><span class="s4">&quot;link name&quot;</span><span class="s2">,</span>
        <span class="s5">/** Jsdoc @link: in `{@link C link text}`, the link text &quot;link text&quot; */</span>
        <span class="s1">linkText </span><span class="s2">= </span><span class="s4">&quot;link text&quot;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">ScriptElementKindModifier </span><span class="s2">{</span>
        <span class="s1">none </span><span class="s2">= </span><span class="s4">&quot;&quot;</span><span class="s2">,</span>
        <span class="s1">publicMemberModifier </span><span class="s2">= </span><span class="s4">&quot;public&quot;</span><span class="s2">,</span>
        <span class="s1">privateMemberModifier </span><span class="s2">= </span><span class="s4">&quot;private&quot;</span><span class="s2">,</span>
        <span class="s1">protectedMemberModifier </span><span class="s2">= </span><span class="s4">&quot;protected&quot;</span><span class="s2">,</span>
        <span class="s1">exportedModifier </span><span class="s2">= </span><span class="s4">&quot;export&quot;</span><span class="s2">,</span>
        <span class="s1">ambientModifier </span><span class="s2">= </span><span class="s4">&quot;declare&quot;</span><span class="s2">,</span>
        <span class="s1">staticModifier </span><span class="s2">= </span><span class="s4">&quot;static&quot;</span><span class="s2">,</span>
        <span class="s1">abstractModifier </span><span class="s2">= </span><span class="s4">&quot;abstract&quot;</span><span class="s2">,</span>
        <span class="s1">optionalModifier </span><span class="s2">= </span><span class="s4">&quot;optional&quot;</span><span class="s2">,</span>
        <span class="s1">deprecatedModifier </span><span class="s2">= </span><span class="s4">&quot;deprecated&quot;</span><span class="s2">,</span>
        <span class="s1">dtsModifier </span><span class="s2">= </span><span class="s4">&quot;.d.ts&quot;</span><span class="s2">,</span>
        <span class="s1">tsModifier </span><span class="s2">= </span><span class="s4">&quot;.ts&quot;</span><span class="s2">,</span>
        <span class="s1">tsxModifier </span><span class="s2">= </span><span class="s4">&quot;.tsx&quot;</span><span class="s2">,</span>
        <span class="s1">jsModifier </span><span class="s2">= </span><span class="s4">&quot;.js&quot;</span><span class="s2">,</span>
        <span class="s1">jsxModifier </span><span class="s2">= </span><span class="s4">&quot;.jsx&quot;</span><span class="s2">,</span>
        <span class="s1">jsonModifier </span><span class="s2">= </span><span class="s4">&quot;.json&quot;</span><span class="s2">,</span>
        <span class="s1">dmtsModifier </span><span class="s2">= </span><span class="s4">&quot;.d.mts&quot;</span><span class="s2">,</span>
        <span class="s1">mtsModifier </span><span class="s2">= </span><span class="s4">&quot;.mts&quot;</span><span class="s2">,</span>
        <span class="s1">mjsModifier </span><span class="s2">= </span><span class="s4">&quot;.mjs&quot;</span><span class="s2">,</span>
        <span class="s1">dctsModifier </span><span class="s2">= </span><span class="s4">&quot;.d.cts&quot;</span><span class="s2">,</span>
        <span class="s1">ctsModifier </span><span class="s2">= </span><span class="s4">&quot;.cts&quot;</span><span class="s2">,</span>
        <span class="s1">cjsModifier </span><span class="s2">= </span><span class="s4">&quot;.cjs&quot;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">ClassificationTypeNames </span><span class="s2">{</span>
        <span class="s1">comment </span><span class="s2">= </span><span class="s4">&quot;comment&quot;</span><span class="s2">,</span>
        <span class="s1">identifier </span><span class="s2">= </span><span class="s4">&quot;identifier&quot;</span><span class="s2">,</span>
        <span class="s1">keyword </span><span class="s2">= </span><span class="s4">&quot;keyword&quot;</span><span class="s2">,</span>
        <span class="s1">numericLiteral </span><span class="s2">= </span><span class="s4">&quot;number&quot;</span><span class="s2">,</span>
        <span class="s1">bigintLiteral </span><span class="s2">= </span><span class="s4">&quot;bigint&quot;</span><span class="s2">,</span>
        <span class="s1">operator </span><span class="s2">= </span><span class="s4">&quot;operator&quot;</span><span class="s2">,</span>
        <span class="s1">stringLiteral </span><span class="s2">= </span><span class="s4">&quot;string&quot;</span><span class="s2">,</span>
        <span class="s1">whiteSpace </span><span class="s2">= </span><span class="s4">&quot;whitespace&quot;</span><span class="s2">,</span>
        <span class="s1">text </span><span class="s2">= </span><span class="s4">&quot;text&quot;</span><span class="s2">,</span>
        <span class="s1">punctuation </span><span class="s2">= </span><span class="s4">&quot;punctuation&quot;</span><span class="s2">,</span>
        <span class="s1">className </span><span class="s2">= </span><span class="s4">&quot;class name&quot;</span><span class="s2">,</span>
        <span class="s1">enumName </span><span class="s2">= </span><span class="s4">&quot;enum name&quot;</span><span class="s2">,</span>
        <span class="s1">interfaceName </span><span class="s2">= </span><span class="s4">&quot;interface name&quot;</span><span class="s2">,</span>
        <span class="s1">moduleName </span><span class="s2">= </span><span class="s4">&quot;module name&quot;</span><span class="s2">,</span>
        <span class="s1">typeParameterName </span><span class="s2">= </span><span class="s4">&quot;type parameter name&quot;</span><span class="s2">,</span>
        <span class="s1">typeAliasName </span><span class="s2">= </span><span class="s4">&quot;type alias name&quot;</span><span class="s2">,</span>
        <span class="s1">parameterName </span><span class="s2">= </span><span class="s4">&quot;parameter name&quot;</span><span class="s2">,</span>
        <span class="s1">docCommentTagName </span><span class="s2">= </span><span class="s4">&quot;doc comment tag name&quot;</span><span class="s2">,</span>
        <span class="s1">jsxOpenTagName </span><span class="s2">= </span><span class="s4">&quot;jsx open tag name&quot;</span><span class="s2">,</span>
        <span class="s1">jsxCloseTagName </span><span class="s2">= </span><span class="s4">&quot;jsx close tag name&quot;</span><span class="s2">,</span>
        <span class="s1">jsxSelfClosingTagName </span><span class="s2">= </span><span class="s4">&quot;jsx self closing tag name&quot;</span><span class="s2">,</span>
        <span class="s1">jsxAttribute </span><span class="s2">= </span><span class="s4">&quot;jsx attribute&quot;</span><span class="s2">,</span>
        <span class="s1">jsxText </span><span class="s2">= </span><span class="s4">&quot;jsx text&quot;</span><span class="s2">,</span>
        <span class="s1">jsxAttributeStringLiteralValue </span><span class="s2">= </span><span class="s4">&quot;jsx attribute string literal value&quot;</span>
    <span class="s2">}</span>
    <span class="s3">enum </span><span class="s1">ClassificationType </span><span class="s2">{</span>
        <span class="s1">comment </span><span class="s2">= </span><span class="s6">1</span><span class="s2">,</span>
        <span class="s1">identifier </span><span class="s2">= </span><span class="s6">2</span><span class="s2">,</span>
        <span class="s1">keyword </span><span class="s2">= </span><span class="s6">3</span><span class="s2">,</span>
        <span class="s1">numericLiteral </span><span class="s2">= </span><span class="s6">4</span><span class="s2">,</span>
        <span class="s1">operator </span><span class="s2">= </span><span class="s6">5</span><span class="s2">,</span>
        <span class="s1">stringLiteral </span><span class="s2">= </span><span class="s6">6</span><span class="s2">,</span>
        <span class="s1">regularExpressionLiteral </span><span class="s2">= </span><span class="s6">7</span><span class="s2">,</span>
        <span class="s1">whiteSpace </span><span class="s2">= </span><span class="s6">8</span><span class="s2">,</span>
        <span class="s1">text </span><span class="s2">= </span><span class="s6">9</span><span class="s2">,</span>
        <span class="s1">punctuation </span><span class="s2">= </span><span class="s6">10</span><span class="s2">,</span>
        <span class="s1">className </span><span class="s2">= </span><span class="s6">11</span><span class="s2">,</span>
        <span class="s1">enumName </span><span class="s2">= </span><span class="s6">12</span><span class="s2">,</span>
        <span class="s1">interfaceName </span><span class="s2">= </span><span class="s6">13</span><span class="s2">,</span>
        <span class="s1">moduleName </span><span class="s2">= </span><span class="s6">14</span><span class="s2">,</span>
        <span class="s1">typeParameterName </span><span class="s2">= </span><span class="s6">15</span><span class="s2">,</span>
        <span class="s1">typeAliasName </span><span class="s2">= </span><span class="s6">16</span><span class="s2">,</span>
        <span class="s1">parameterName </span><span class="s2">= </span><span class="s6">17</span><span class="s2">,</span>
        <span class="s1">docCommentTagName </span><span class="s2">= </span><span class="s6">18</span><span class="s2">,</span>
        <span class="s1">jsxOpenTagName </span><span class="s2">= </span><span class="s6">19</span><span class="s2">,</span>
        <span class="s1">jsxCloseTagName </span><span class="s2">= </span><span class="s6">20</span><span class="s2">,</span>
        <span class="s1">jsxSelfClosingTagName </span><span class="s2">= </span><span class="s6">21</span><span class="s2">,</span>
        <span class="s1">jsxAttribute </span><span class="s2">= </span><span class="s6">22</span><span class="s2">,</span>
        <span class="s1">jsxText </span><span class="s2">= </span><span class="s6">23</span><span class="s2">,</span>
        <span class="s1">jsxAttributeStringLiteralValue </span><span class="s2">= </span><span class="s6">24</span><span class="s2">,</span>
        <span class="s1">bigintLiteral </span><span class="s2">= </span><span class="s6">25</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">InlayHintsContext </span><span class="s2">{</span>
        <span class="s1">file</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">program</span><span class="s2">: </span><span class="s1">Program</span><span class="s2">;</span>
        <span class="s1">cancellationToken</span><span class="s2">: </span><span class="s1">CancellationToken</span><span class="s2">;</span>
        <span class="s1">host</span><span class="s2">: </span><span class="s1">LanguageServiceHost</span><span class="s2">;</span>
        <span class="s1">span</span><span class="s2">: </span><span class="s1">TextSpan</span><span class="s2">;</span>
        <span class="s1">preferences</span><span class="s2">: </span><span class="s1">UserPreferences</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/** The classifier is used for syntactic highlighting in editors via the TSServer */</span>
    <span class="s3">function </span><span class="s1">createClassifier</span><span class="s2">(): </span><span class="s1">Classifier</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">DocumentHighlights </span><span class="s2">{</span>
        <span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">highlightSpans</span><span class="s2">: </span><span class="s1">HighlightSpan</span><span class="s2">[];</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/**</span>
     <span class="s5">* The document registry represents a store of SourceFile objects that can be shared between</span>
     <span class="s5">* multiple LanguageService instances. A LanguageService instance holds on the SourceFile (AST)</span>
     <span class="s5">* of files in the context.</span>
     <span class="s5">* SourceFile objects account for most of the memory usage by the language service. Sharing</span>
     <span class="s5">* the same DocumentRegistry instance between different instances of LanguageService allow</span>
     <span class="s5">* for more efficient memory utilization since all projects will share at least the library</span>
     <span class="s5">* file (lib.d.ts).</span>
     <span class="s5">*</span>
     <span class="s5">* A more advanced use of the document registry is to serialize sourceFile objects to disk</span>
     <span class="s5">* and re-hydrate them when needed.</span>
     <span class="s5">*</span>
     <span class="s5">* To create a default DocumentRegistry, use createDocumentRegistry to create one, and pass it</span>
     <span class="s5">* to all subsequent createLanguageService calls.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">DocumentRegistry </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* Request a stored SourceFile with a given fileName and compilationSettings.</span>
         <span class="s5">* The first call to acquire will call createLanguageServiceSourceFile to generate</span>
         <span class="s5">* the SourceFile if was not found in the registry.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The name of the file requested</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">compilationSettingsOrHost Some compilation settings like target affects the</span>
         <span class="s5">* shape of a the resulting SourceFile. This allows the DocumentRegistry to store</span>
         <span class="s5">* multiple copies of the same file for different compilation settings. A minimal</span>
         <span class="s5">* resolution cache is needed to fully define a source file's shape when</span>
         <span class="s5">* the compilation settings include `module: node16`+, so providing a cache host</span>
         <span class="s5">* object should be preferred. A common host is a language service `ConfiguredProject`.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">scriptSnapshot Text of the file. Only used if the file was not found</span>
         <span class="s5">* in the registry and a new one was created.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">version Current version of the file. Only used if the file was not found</span>
         <span class="s5">* in the registry and a new one was created.</span>
         <span class="s5">*/</span>
        <span class="s1">acquireDocument</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">compilationSettingsOrHost</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">MinimalResolutionCacheHost</span><span class="s2">, </span><span class="s1">scriptSnapshot</span><span class="s2">: </span><span class="s1">IScriptSnapshot</span><span class="s2">, </span><span class="s1">version</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">, </span><span class="s1">sourceFileOptions</span><span class="s2">?: </span><span class="s1">CreateSourceFileOptions </span><span class="s2">| </span><span class="s1">ScriptTarget</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">acquireDocumentWithKey</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">compilationSettingsOrHost</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">MinimalResolutionCacheHost</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">DocumentRegistryBucketKey</span><span class="s2">, </span><span class="s1">scriptSnapshot</span><span class="s2">: </span><span class="s1">IScriptSnapshot</span><span class="s2">, </span><span class="s1">version</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">, </span><span class="s1">sourceFileOptions</span><span class="s2">?: </span><span class="s1">CreateSourceFileOptions </span><span class="s2">| </span><span class="s1">ScriptTarget</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Request an updated version of an already existing SourceFile with a given fileName</span>
         <span class="s5">* and compilationSettings. The update will in-turn call updateLanguageServiceSourceFile</span>
         <span class="s5">* to get an updated SourceFile.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The name of the file requested</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">compilationSettingsOrHost Some compilation settings like target affects the</span>
         <span class="s5">* shape of a the resulting SourceFile. This allows the DocumentRegistry to store</span>
         <span class="s5">* multiple copies of the same file for different compilation settings. A minimal</span>
         <span class="s5">* resolution cache is needed to fully define a source file's shape when</span>
         <span class="s5">* the compilation settings include `module: node16`+, so providing a cache host</span>
         <span class="s5">* object should be preferred. A common host is a language service `ConfiguredProject`.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">scriptSnapshot Text of the file.</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">version Current version of the file.</span>
         <span class="s5">*/</span>
        <span class="s1">updateDocument</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">compilationSettingsOrHost</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">MinimalResolutionCacheHost</span><span class="s2">, </span><span class="s1">scriptSnapshot</span><span class="s2">: </span><span class="s1">IScriptSnapshot</span><span class="s2">, </span><span class="s1">version</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">, </span><span class="s1">sourceFileOptions</span><span class="s2">?: </span><span class="s1">CreateSourceFileOptions </span><span class="s2">| </span><span class="s1">ScriptTarget</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">updateDocumentWithKey</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">compilationSettingsOrHost</span><span class="s2">: </span><span class="s1">CompilerOptions </span><span class="s2">| </span><span class="s1">MinimalResolutionCacheHost</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">DocumentRegistryBucketKey</span><span class="s2">, </span><span class="s1">scriptSnapshot</span><span class="s2">: </span><span class="s1">IScriptSnapshot</span><span class="s2">, </span><span class="s1">version</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">, </span><span class="s1">sourceFileOptions</span><span class="s2">?: </span><span class="s1">CreateSourceFileOptions </span><span class="s2">| </span><span class="s1">ScriptTarget</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
        <span class="s1">getKeyForCompilationSettings</span><span class="s2">(</span><span class="s1">settings</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">DocumentRegistryBucketKey</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Informs the DocumentRegistry that a file is not needed any longer.</span>
         <span class="s5">*</span>
         <span class="s5">* Note: It is not allowed to call release on a SourceFile that was not acquired from</span>
         <span class="s5">* this registry originally.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The name of the file to be released</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">compilationSettings The compilation settings used to acquire the file</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">scriptKind The script kind of the file to be released</span>
         <span class="s5">*/</span>
        <span class="s5">/**</span><span class="s7">@deprecated </span><span class="s5">pass scriptKind and impliedNodeFormat for correctness */</span>
        <span class="s1">releaseDocument</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">compilationSettings</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* Informs the DocumentRegistry that a file is not needed any longer.</span>
         <span class="s5">*</span>
         <span class="s5">* Note: It is not allowed to call release on a SourceFile that was not acquired from</span>
         <span class="s5">* this registry originally.</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">fileName The name of the file to be released</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">compilationSettings The compilation settings used to acquire the file</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">scriptKind The script kind of the file to be released</span>
         <span class="s5">* </span><span class="s7">@param </span><span class="s5">impliedNodeFormat The implied source file format of the file to be released</span>
         <span class="s5">*/</span>
        <span class="s1">releaseDocument</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">compilationSettings</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">: </span><span class="s1">ScriptKind</span><span class="s2">, </span><span class="s1">impliedNodeFormat</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">]): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">pass scriptKind for and impliedNodeFormat correctness */</span>
        <span class="s1">releaseDocumentWithKey</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">DocumentRegistryBucketKey</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">releaseDocumentWithKey</span><span class="s2">(</span><span class="s1">path</span><span class="s2">: </span><span class="s1">Path</span><span class="s2">, </span><span class="s1">key</span><span class="s2">: </span><span class="s1">DocumentRegistryBucketKey</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">: </span><span class="s1">ScriptKind</span><span class="s2">, </span><span class="s1">impliedNodeFormat</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">[</span><span class="s4">&quot;impliedNodeFormat&quot;</span><span class="s2">]): </span><span class="s3">void</span><span class="s2">;</span>
        <span class="s1">reportStats</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s1">type DocumentRegistryBucketKey </span><span class="s2">= </span><span class="s1">string </span><span class="s2">&amp; {</span>
        <span class="s1">__bucketKey</span><span class="s2">: </span><span class="s1">any</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s3">function </span><span class="s1">createDocumentRegistry</span><span class="s2">(</span><span class="s1">useCaseSensitiveFileNames</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">currentDirectory</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">DocumentRegistry</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">function </span><span class="s1">preProcessFile</span><span class="s2">(</span><span class="s1">sourceText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">readImportFiles</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">detectJavaScriptImports</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">PreProcessedFileInfo</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">TranspileOptions </span><span class="s2">{</span>
        <span class="s1">compilerOptions</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
        <span class="s1">fileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">reportDiagnostics</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">;</span>
        <span class="s1">moduleName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">renamedDependencies</span><span class="s2">?: </span><span class="s1">MapLike</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">&gt;;</span>
        <span class="s1">transformers</span><span class="s2">?: </span><span class="s1">CustomTransformers</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">TranspileOutput </span><span class="s2">{</span>
        <span class="s1">outputText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">;</span>
        <span class="s1">diagnostics</span><span class="s2">?: </span><span class="s1">Diagnostic</span><span class="s2">[];</span>
        <span class="s1">sourceMapText</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">function </span><span class="s1">transpileModule</span><span class="s2">(</span><span class="s1">input</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">transpileOptions</span><span class="s2">: </span><span class="s1">TranspileOptions</span><span class="s2">): </span><span class="s1">TranspileOutput</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">transpile</span><span class="s2">(</span><span class="s1">input</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">compilerOptions</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">, </span><span class="s1">fileName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">diagnostics</span><span class="s2">?: </span><span class="s1">Diagnostic</span><span class="s2">[], </span><span class="s1">moduleName</span><span class="s2">?: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/** The version of the language service API */</span>
    <span class="s3">const </span><span class="s1">servicesVersion </span><span class="s2">= </span><span class="s4">&quot;0.8&quot;</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">toEditorSettings</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">EditorOptions </span><span class="s2">| </span><span class="s1">EditorSettings</span><span class="s2">): </span><span class="s1">EditorSettings</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">displayPartsToString</span><span class="s2">(</span><span class="s1">displayParts</span><span class="s2">: </span><span class="s1">SymbolDisplayPart</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getDefaultCompilerOptions</span><span class="s2">(): </span><span class="s1">CompilerOptions</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">getSupportedCodeFixes</span><span class="s2">(): </span><span class="s1">string</span><span class="s2">[];</span>
    <span class="s3">function </span><span class="s1">createLanguageServiceSourceFile</span><span class="s2">(</span><span class="s1">fileName</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">scriptSnapshot</span><span class="s2">: </span><span class="s1">IScriptSnapshot</span><span class="s2">, </span><span class="s1">scriptTargetOrOptions</span><span class="s2">: </span><span class="s1">ScriptTarget </span><span class="s2">| </span><span class="s1">CreateSourceFileOptions</span><span class="s2">, </span><span class="s1">version</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">setNodeParents</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">scriptKind</span><span class="s2">?: </span><span class="s1">ScriptKind</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">updateLanguageServiceSourceFile</span><span class="s2">(</span><span class="s1">sourceFile</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">scriptSnapshot</span><span class="s2">: </span><span class="s1">IScriptSnapshot</span><span class="s2">, </span><span class="s1">version</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">textChangeRange</span><span class="s2">: </span><span class="s1">TextChangeRange </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">aggressiveChecks</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">SourceFile</span><span class="s2">;</span>
    <span class="s3">function </span><span class="s1">createLanguageService</span><span class="s2">(</span><span class="s1">host</span><span class="s2">: </span><span class="s1">LanguageServiceHost</span><span class="s2">, </span><span class="s1">documentRegistry</span><span class="s2">?: </span><span class="s1">DocumentRegistry</span><span class="s2">, </span><span class="s1">syntaxOnlyOrLanguageServiceMode</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">LanguageServiceMode</span><span class="s2">): </span><span class="s1">LanguageService</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Get the path of the default library files (lib.d.ts) as distributed with the typescript</span>
     <span class="s5">* node package.</span>
     <span class="s5">* The functionality is not supported if the ts module is consumed outside of a node module.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">getDefaultLibFilePath</span><span class="s2">(</span><span class="s1">options</span><span class="s2">: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">string</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/**</span>
     <span class="s5">* Transform one or more nodes using the supplied transformers.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">source A single `Node` or an array of `Node` objects.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">transformers An array of `TransformerFactory` callbacks used to process the transformation.</span>
     <span class="s5">* </span><span class="s7">@param </span><span class="s5">compilerOptions Optional compiler options.</span>
     <span class="s5">*/</span>
    <span class="s3">function </span><span class="s1">transform</span><span class="s2">&lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">source</span><span class="s2">: </span><span class="s1">T </span><span class="s2">| </span><span class="s1">T</span><span class="s2">[], </span><span class="s1">transformers</span><span class="s2">: </span><span class="s1">TransformerFactory</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;[], </span><span class="s1">compilerOptions</span><span class="s2">?: </span><span class="s1">CompilerOptions</span><span class="s2">): </span><span class="s1">TransformationResult</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNodeArray` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNodeArray</span><span class="s2">: &lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">elements</span><span class="s2">?: </span><span class="s1">readonly T</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">hasTrailingComma</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNumericLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNumericLiteral</span><span class="s2">: (</span><span class="s1">value</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number</span><span class="s2">, </span><span class="s1">numericLiteralFlags</span><span class="s2">?: </span><span class="s1">TokenFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">NumericLiteral</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createBigIntLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createBigIntLiteral</span><span class="s2">: (</span><span class="s1">value</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PseudoBigInt</span><span class="s2">) =&gt; </span><span class="s1">BigIntLiteral</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createStringLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createStringLiteral</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">isSingleQuote</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">StringLiteral</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">isSingleQuote</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">hasExtendedUnicodeEscape</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">StringLiteral</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createStringLiteralFromNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createStringLiteralFromNode</span><span class="s2">: (</span><span class="s1">sourceNode</span><span class="s2">: </span><span class="s1">PrivateIdentifier </span><span class="s2">| </span><span class="s1">PropertyNameLiteral</span><span class="s2">, </span><span class="s1">isSingleQuote</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">StringLiteral</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createRegularExpressionLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createRegularExpressionLiteral</span><span class="s2">: (</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">RegularExpressionLiteral</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createLoopVariable` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createLoopVariable</span><span class="s2">: (</span><span class="s1">reservedInNestedScopes</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createUniqueName` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createUniqueName</span><span class="s2">: (</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">GeneratedIdentifierFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPrivateIdentifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPrivateIdentifier</span><span class="s2">: (</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">PrivateIdentifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createSuper` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createSuper</span><span class="s2">: () =&gt; </span><span class="s1">SuperExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createThis` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createThis</span><span class="s2">: () =&gt; </span><span class="s1">ThisExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNull` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNull</span><span class="s2">: () =&gt; </span><span class="s1">NullLiteral</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTrue` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTrue</span><span class="s2">: () =&gt; </span><span class="s1">TrueLiteral</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createFalse` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createFalse</span><span class="s2">: () =&gt; </span><span class="s1">FalseLiteral</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createModifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createModifier</span><span class="s2">: &lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">ModifierSyntaxKind</span><span class="s2">&gt;(</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">T</span><span class="s2">) =&gt; </span><span class="s1">ModifierToken</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt;;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createModifiersFromModifierFlags` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createModifiersFromModifierFlags</span><span class="s2">: (</span><span class="s1">flags</span><span class="s2">: </span><span class="s1">ModifierFlags</span><span class="s2">) =&gt; </span><span class="s1">Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createQualifiedName` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createQualifiedName</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">QualifiedName</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateQualifiedName` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateQualifiedName</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">QualifiedName</span><span class="s2">, </span><span class="s1">left</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">QualifiedName</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createComputedPropertyName` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createComputedPropertyName</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ComputedPropertyName</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateComputedPropertyName` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateComputedPropertyName</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ComputedPropertyName</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ComputedPropertyName</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypeParameterDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypeParameterDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">?: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">defaultType</span><span class="s2">?: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">?: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">defaultType</span><span class="s2">?: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypeParameterDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypeParameterDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">defaultType</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">defaultType</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createParameterDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createParameter</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateParameterDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateParameter</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createDecorator` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createDecorator</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">Decorator</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateDecorator` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateDecorator</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Decorator</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">Decorator</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPropertyDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createProperty</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionOrExclamationToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionOrExclamationToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updatePropertyDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateProperty</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionOrExclamationToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionOrExclamationToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createMethodDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createMethod</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateMethodDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateMethod</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MethodDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MethodDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createConstructorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createConstructor</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateConstructorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateConstructor</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructorDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructorDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createGetAccessorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createGetAccessor</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateGetAccessorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateGetAccessor</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">GetAccessorDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">GetAccessorDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createSetAccessorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createSetAccessor</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateSetAccessorDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateSetAccessor</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SetAccessorDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SetAccessorDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createCallSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createCallSignature</span><span class="s2">: (</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">CallSignatureDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateCallSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateCallSignature</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CallSignatureDeclaration</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">CallSignatureDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createConstructSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createConstructSignature</span><span class="s2">: (</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ConstructSignatureDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateConstructSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateConstructSignature</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructSignatureDeclaration</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ConstructSignatureDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateIndexSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateIndexSignature</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createKeywordTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createKeywordTypeNode</span><span class="s2">: &lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">KeywordTypeSyntaxKind</span><span class="s2">&gt;(</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">) =&gt; </span><span class="s1">KeywordTypeNode</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypePredicateNodeWithModifier</span><span class="s2">: (</span><span class="s1">assertsModifier</span><span class="s2">: </span><span class="s1">AssertsKeyword </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameterName</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">ThisTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TypePredicateNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypePredicateNodeWithModifier</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypePredicateNode</span><span class="s2">, </span><span class="s1">assertsModifier</span><span class="s2">: </span><span class="s1">AssertsKeyword </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameterName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">ThisTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TypePredicateNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypeReferenceNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypeReferenceNode</span><span class="s2">: (</span><span class="s1">typeName</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TypeReferenceNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypeReferenceNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypeReferenceNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeReferenceNode</span><span class="s2">, </span><span class="s1">typeName</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TypeReferenceNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createFunctionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createFunctionTypeNode</span><span class="s2">: (</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">FunctionTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateFunctionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateFunctionTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionTypeNode</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">FunctionTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createConstructorTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createConstructorTypeNode</span><span class="s2">: (</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateConstructorTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateConstructorTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructorTypeNode</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypeQueryNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypeQueryNode</span><span class="s2">: (</span><span class="s1">exprName</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TypeQueryNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypeQueryNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypeQueryNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeQueryNode</span><span class="s2">, </span><span class="s1">exprName</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TypeQueryNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypeLiteralNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypeLiteralNode</span><span class="s2">: (</span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TypeLiteralNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypeLiteralNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypeLiteralNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeLiteralNode</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt;) =&gt; </span><span class="s1">TypeLiteralNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createArrayTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createArrayTypeNode</span><span class="s2">: (</span><span class="s1">elementType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">ArrayTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateArrayTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateArrayTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrayTypeNode</span><span class="s2">, </span><span class="s1">elementType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">ArrayTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTupleTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTupleTypeNode</span><span class="s2">: (</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">NamedTupleMember</span><span class="s2">)[]) =&gt; </span><span class="s1">TupleTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTupleTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTupleTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TupleTypeNode</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">NamedTupleMember</span><span class="s2">)[]) =&gt; </span><span class="s1">TupleTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createOptionalTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createOptionalTypeNode</span><span class="s2">: (</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">OptionalTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateOptionalTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateOptionalTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">OptionalTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">OptionalTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createRestTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createRestTypeNode</span><span class="s2">: (</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">RestTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateRestTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateRestTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">RestTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">RestTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createUnionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createUnionTypeNode</span><span class="s2">: (</span><span class="s1">types</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[]) =&gt; </span><span class="s1">UnionTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateUnionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateUnionTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">UnionTypeNode</span><span class="s2">, </span><span class="s1">types</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;) =&gt; </span><span class="s1">UnionTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createIntersectionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createIntersectionTypeNode</span><span class="s2">: (</span><span class="s1">types</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[]) =&gt; </span><span class="s1">IntersectionTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateIntersectionTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateIntersectionTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IntersectionTypeNode</span><span class="s2">, </span><span class="s1">types</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeNode</span><span class="s2">&gt;) =&gt; </span><span class="s1">IntersectionTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createConditionalTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createConditionalTypeNode</span><span class="s2">: (</span><span class="s1">checkType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">extendsType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">trueType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">falseType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">ConditionalTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateConditionalTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateConditionalTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConditionalTypeNode</span><span class="s2">, </span><span class="s1">checkType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">extendsType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">trueType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">falseType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">ConditionalTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createInferTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createInferTypeNode</span><span class="s2">: (</span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">) =&gt; </span><span class="s1">InferTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateInferTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateInferTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">InferTypeNode</span><span class="s2">, </span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">) =&gt; </span><span class="s1">InferTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createImportTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createImportTypeNode</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">?: </span><span class="s1">ImportTypeAssertionContainer </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">?: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">?: </span><span class="s1">ImportTypeAssertionContainer </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">?: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">?: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateImportTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateImportTypeNode</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportTypeNode</span><span class="s2">, </span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">: </span><span class="s1">ImportTypeAssertionContainer </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportTypeNode</span><span class="s2">, </span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createParenthesizedType` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createParenthesizedType</span><span class="s2">: (</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">ParenthesizedTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateParenthesizedType` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateParenthesizedType</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParenthesizedTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">ParenthesizedTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createThisTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createThisTypeNode</span><span class="s2">: () =&gt; </span><span class="s1">ThisTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypeOperatorNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypeOperatorNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeOperatorNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">TypeOperatorNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createIndexedAccessTypeNode</span><span class="s2">: (</span><span class="s1">objectType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">indexType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">IndexedAccessTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateIndexedAccessTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateIndexedAccessTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IndexedAccessTypeNode</span><span class="s2">, </span><span class="s1">objectType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">indexType</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">IndexedAccessTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createMappedTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createMappedTypeNode</span><span class="s2">: (</span><span class="s1">readonlyToken</span><span class="s2">: </span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">, </span><span class="s1">nameType</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">MappedTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateMappedTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateMappedTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MappedTypeNode</span><span class="s2">, </span><span class="s1">readonlyToken</span><span class="s2">: </span><span class="s1">ReadonlyKeyword </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameter</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">, </span><span class="s1">nameType</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">PlusToken </span><span class="s2">| </span><span class="s1">MinusToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeElement</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">MappedTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createLiteralTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createLiteralTypeNode</span><span class="s2">: (</span><span class="s1">literal</span><span class="s2">: </span><span class="s1">LiteralExpression </span><span class="s2">| </span><span class="s1">BooleanLiteral </span><span class="s2">| </span><span class="s1">PrefixUnaryExpression </span><span class="s2">| </span><span class="s1">NullLiteral</span><span class="s2">) =&gt; </span><span class="s1">LiteralTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateLiteralTypeNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateLiteralTypeNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">LiteralTypeNode</span><span class="s2">, </span><span class="s1">literal</span><span class="s2">: </span><span class="s1">LiteralExpression </span><span class="s2">| </span><span class="s1">BooleanLiteral </span><span class="s2">| </span><span class="s1">PrefixUnaryExpression </span><span class="s2">| </span><span class="s1">NullLiteral</span><span class="s2">) =&gt; </span><span class="s1">LiteralTypeNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createObjectBindingPattern` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createObjectBindingPattern</span><span class="s2">: (</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly BindingElement</span><span class="s2">[]) =&gt; </span><span class="s1">ObjectBindingPattern</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateObjectBindingPattern` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateObjectBindingPattern</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ObjectBindingPattern</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly BindingElement</span><span class="s2">[]) =&gt; </span><span class="s1">ObjectBindingPattern</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createArrayBindingPattern` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createArrayBindingPattern</span><span class="s2">: (</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ArrayBindingElement</span><span class="s2">[]) =&gt; </span><span class="s1">ArrayBindingPattern</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateArrayBindingPattern` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateArrayBindingPattern</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrayBindingPattern</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ArrayBindingElement</span><span class="s2">[]) =&gt; </span><span class="s1">ArrayBindingPattern</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createBindingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createBindingElement</span><span class="s2">: (</span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">BindingElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateBindingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateBindingElement</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">BindingElement</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">PropertyName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">BindingElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createArrayLiteralExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createArrayLiteral</span><span class="s2">: (</span><span class="s1">elements</span><span class="s2">?: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateArrayLiteralExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateArrayLiteral</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrayLiteralExpression</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]) =&gt; </span><span class="s1">ArrayLiteralExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createObjectLiteralExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createObjectLiteral</span><span class="s2">: (</span><span class="s1">properties</span><span class="s2">?: </span><span class="s1">readonly ObjectLiteralElementLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateObjectLiteralExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateObjectLiteral</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ObjectLiteralExpression</span><span class="s2">, </span><span class="s1">properties</span><span class="s2">: </span><span class="s1">readonly ObjectLiteralElementLike</span><span class="s2">[]) =&gt; </span><span class="s1">ObjectLiteralExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPropertyAccessExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPropertyAccess</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">MemberName</span><span class="s2">) =&gt; </span><span class="s1">PropertyAccessExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updatePropertyAccessExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updatePropertyAccess</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyAccessExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">MemberName</span><span class="s2">) =&gt; </span><span class="s1">PropertyAccessExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPropertyAccessChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPropertyAccessChain</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">MemberName</span><span class="s2">) =&gt; </span><span class="s1">PropertyAccessChain</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updatePropertyAccessChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updatePropertyAccessChain</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyAccessChain</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">MemberName</span><span class="s2">) =&gt; </span><span class="s1">PropertyAccessChain</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createElementAccessExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createElementAccess</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ElementAccessExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateElementAccessExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateElementAccess</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ElementAccessExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">argumentExpression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ElementAccessExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createElementAccessChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createElementAccessChain</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">index</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ElementAccessChain</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateElementAccessChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateElementAccessChain</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ElementAccessChain</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentExpression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ElementAccessChain</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createCallExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createCall</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">CallExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateCallExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateCall</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CallExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]) =&gt; </span><span class="s1">CallExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createCallChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createCallChain</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">CallChain</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateCallChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateCallChain</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CallChain</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionDotToken</span><span class="s2">: </span><span class="s1">QuestionDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]) =&gt; </span><span class="s1">CallChain</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNewExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNew</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">NewExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateNewExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateNew</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NewExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">argumentsArray</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">NewExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypeAssertion` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypeAssertion</span><span class="s2">: (</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">TypeAssertion</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypeAssertion` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypeAssertion</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeAssertion</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">TypeAssertion</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createParenthesizedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createParen</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ParenthesizedExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateParenthesizedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateParen</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParenthesizedExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ParenthesizedExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createFunctionExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createFunctionExpression</span><span class="s2">: (</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">) =&gt; </span><span class="s1">FunctionExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateFunctionExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateFunctionExpression</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionExpression</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">) =&gt; </span><span class="s1">FunctionExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createDeleteExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createDelete</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">DeleteExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateDeleteExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateDelete</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">DeleteExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">DeleteExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypeOfExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypeOf</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">TypeOfExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypeOfExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypeOf</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeOfExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">TypeOfExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createVoidExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createVoid</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">VoidExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateVoidExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateVoid</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VoidExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">VoidExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createAwaitExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createAwait</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">AwaitExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateAwaitExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateAwait</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">AwaitExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">AwaitExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPrefixExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPrefix</span><span class="s2">: (</span><span class="s1">operator</span><span class="s2">: </span><span class="s1">PrefixUnaryOperator</span><span class="s2">, </span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updatePrefixExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updatePrefix</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PrefixUnaryExpression</span><span class="s2">, </span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPostfixUnaryExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPostfix</span><span class="s2">: (</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">: </span><span class="s1">PostfixUnaryOperator</span><span class="s2">) =&gt; </span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updatePostfixUnaryExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updatePostfix</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PostfixUnaryExpression</span><span class="s2">, </span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createBinaryExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createBinary</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">: </span><span class="s1">BinaryOperator </span><span class="s2">| </span><span class="s1">BinaryOperatorToken</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateConditionalExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateConditional</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConditionalExpression</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken</span><span class="s2">, </span><span class="s1">whenTrue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">colonToken</span><span class="s2">: </span><span class="s1">ColonToken</span><span class="s2">, </span><span class="s1">whenFalse</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ConditionalExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTemplateExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTemplateExpression</span><span class="s2">: (</span><span class="s1">head</span><span class="s2">: </span><span class="s1">TemplateHead</span><span class="s2">, </span><span class="s1">templateSpans</span><span class="s2">: </span><span class="s1">readonly TemplateSpan</span><span class="s2">[]) =&gt; </span><span class="s1">TemplateExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTemplateExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTemplateExpression</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TemplateExpression</span><span class="s2">, </span><span class="s1">head</span><span class="s2">: </span><span class="s1">TemplateHead</span><span class="s2">, </span><span class="s1">templateSpans</span><span class="s2">: </span><span class="s1">readonly TemplateSpan</span><span class="s2">[]) =&gt; </span><span class="s1">TemplateExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTemplateHead` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTemplateHead</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TemplateHead</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TemplateHead</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTemplateMiddle` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTemplateMiddle</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TemplateMiddle</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TemplateMiddle</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTemplateTail` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTemplateTail</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TemplateTail</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">templateFlags</span><span class="s2">?: </span><span class="s1">TokenFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TemplateTail</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNoSubstitutionTemplateLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNoSubstitutionTemplateLiteral</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">rawText</span><span class="s2">: </span><span class="s1">string</span><span class="s2">): </span><span class="s1">NoSubstitutionTemplateLiteral</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateYieldExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateYield</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">YieldExpression</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">YieldExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createSpreadExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createSpread</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">SpreadElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateSpreadExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateSpread</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SpreadElement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">SpreadElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createOmittedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createOmittedExpression</span><span class="s2">: () =&gt; </span><span class="s1">OmittedExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createAsExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createAsExpression</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">AsExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateAsExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateAsExpression</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">AsExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">AsExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNonNullExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNonNullExpression</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">NonNullExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateNonNullExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateNonNullExpression</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NonNullExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">NonNullExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNonNullChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNonNullChain</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">NonNullChain</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateNonNullChain` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateNonNullChain</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NonNullChain</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">NonNullChain</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createMetaProperty` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createMetaProperty</span><span class="s2">: (</span><span class="s1">keywordToken</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImportKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">NewKeyword</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">MetaProperty</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateMetaProperty` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateMetaProperty</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MetaProperty</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">MetaProperty</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTemplateSpan` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTemplateSpan</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">literal</span><span class="s2">: </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">) =&gt; </span><span class="s1">TemplateSpan</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTemplateSpan` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTemplateSpan</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TemplateSpan</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">literal</span><span class="s2">: </span><span class="s1">TemplateMiddle </span><span class="s2">| </span><span class="s1">TemplateTail</span><span class="s2">) =&gt; </span><span class="s1">TemplateSpan</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createSemicolonClassElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createSemicolonClassElement</span><span class="s2">: () =&gt; </span><span class="s1">SemicolonClassElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createBlock</span><span class="s2">: (</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">multiLine</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">Block</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateBlock</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]) =&gt; </span><span class="s1">Block</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createVariableStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createVariableStatement</span><span class="s2">: (</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">declarationList</span><span class="s2">: </span><span class="s1">VariableDeclarationList </span><span class="s2">| </span><span class="s1">readonly VariableDeclaration</span><span class="s2">[]) =&gt; </span><span class="s1">VariableStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateVariableStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateVariableStatement</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VariableStatement</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">declarationList</span><span class="s2">: </span><span class="s1">VariableDeclarationList</span><span class="s2">) =&gt; </span><span class="s1">VariableStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createEmptyStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createEmptyStatement</span><span class="s2">: () =&gt; </span><span class="s1">EmptyStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createExpressionStatement</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExpressionStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateExpressionStatement</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExpressionStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExpressionStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExpressionStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createStatement</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExpressionStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateExpressionStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateStatement</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExpressionStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExpressionStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createIfStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createIf</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">thenStatement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">elseStatement</span><span class="s2">?: </span><span class="s1">Statement </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">IfStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateIfStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateIf</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IfStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">thenStatement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">elseStatement</span><span class="s2">: </span><span class="s1">Statement </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">IfStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createDoStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createDo</span><span class="s2">: (</span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">DoStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateDoStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateDo</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">DoStatement</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">DoStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createWhileStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createWhile</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">WhileStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateWhileStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateWhile</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">WhileStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">WhileStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createForStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createFor</span><span class="s2">: (</span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">incrementor</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">ForStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateForStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateFor</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ForStatement</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">incrementor</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">ForStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createForInStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createForIn</span><span class="s2">: (</span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">ForInStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateForInStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateForIn</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ForInStatement</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">ForInStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createForOfStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createForOf</span><span class="s2">: (</span><span class="s1">awaitModifier</span><span class="s2">: </span><span class="s1">AwaitKeyword </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">ForOfStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateForOfStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateForOf</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ForOfStatement</span><span class="s2">, </span><span class="s1">awaitModifier</span><span class="s2">: </span><span class="s1">AwaitKeyword </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">ForInitializer</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">ForOfStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createContinueStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createContinue</span><span class="s2">: (</span><span class="s1">label</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ContinueStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateContinueStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateContinue</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ContinueStatement</span><span class="s2">, </span><span class="s1">label</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ContinueStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createBreakStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createBreak</span><span class="s2">: (</span><span class="s1">label</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">BreakStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateBreakStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateBreak</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">BreakStatement</span><span class="s2">, </span><span class="s1">label</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">BreakStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createReturnStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createReturn</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ReturnStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateReturnStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateReturn</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ReturnStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ReturnStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createWithStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createWith</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">WithStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateWithStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateWith</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">WithStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">WithStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createSwitchStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createSwitch</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">caseBlock</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">) =&gt; </span><span class="s1">SwitchStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateSwitchStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateSwitch</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SwitchStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">caseBlock</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">) =&gt; </span><span class="s1">SwitchStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createLabelStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createLabel</span><span class="s2">: (</span><span class="s1">label</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">LabeledStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateLabelStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateLabel</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">LabeledStatement</span><span class="s2">, </span><span class="s1">label</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">statement</span><span class="s2">: </span><span class="s1">Statement</span><span class="s2">) =&gt; </span><span class="s1">LabeledStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createThrowStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createThrow</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ThrowStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateThrowStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateThrow</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ThrowStatement</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ThrowStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTryStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTry</span><span class="s2">: (</span><span class="s1">tryBlock</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">, </span><span class="s1">catchClause</span><span class="s2">: </span><span class="s1">CatchClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">finallyBlock</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TryStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTryStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTry</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TryStatement</span><span class="s2">, </span><span class="s1">tryBlock</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">, </span><span class="s1">catchClause</span><span class="s2">: </span><span class="s1">CatchClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">finallyBlock</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">TryStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createDebuggerStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createDebuggerStatement</span><span class="s2">: () =&gt; </span><span class="s1">DebuggerStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createVariableDeclarationList` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createVariableDeclarationList</span><span class="s2">: (</span><span class="s1">declarations</span><span class="s2">: </span><span class="s1">readonly VariableDeclaration</span><span class="s2">[], </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">NodeFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">VariableDeclarationList</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateVariableDeclarationList` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateVariableDeclarationList</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VariableDeclarationList</span><span class="s2">, </span><span class="s1">declarations</span><span class="s2">: </span><span class="s1">readonly VariableDeclaration</span><span class="s2">[]) =&gt; </span><span class="s1">VariableDeclarationList</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createFunctionDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createFunctionDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateFunctionDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateFunctionDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createClassDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createClassDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateClassDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateClassDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly ModifierLike</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createInterfaceDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createInterfaceDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[]): </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[]): </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateInterfaceDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateInterfaceDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">InterfaceDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[]): </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">InterfaceDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[]): </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypeAliasDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypeAliasDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypeAliasDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypeAliasDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeAliasDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeAliasDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createEnumDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createEnumDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly EnumMember</span><span class="s2">[]): </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly EnumMember</span><span class="s2">[]): </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateEnumDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateEnumDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">EnumDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly EnumMember</span><span class="s2">[]): </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">EnumDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly EnumMember</span><span class="s2">[]): </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createModuleDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createModuleDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">NodeFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">NodeFlags </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateModuleDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateModuleDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ModuleDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ModuleDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createModuleBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createModuleBlock</span><span class="s2">: (</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]) =&gt; </span><span class="s1">ModuleBlock</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateModuleBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateModuleBlock</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ModuleBlock</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]) =&gt; </span><span class="s1">ModuleBlock</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createCaseBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createCaseBlock</span><span class="s2">: (</span><span class="s1">clauses</span><span class="s2">: </span><span class="s1">readonly CaseOrDefaultClause</span><span class="s2">[]) =&gt; </span><span class="s1">CaseBlock</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateCaseBlock` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateCaseBlock</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CaseBlock</span><span class="s2">, </span><span class="s1">clauses</span><span class="s2">: </span><span class="s1">readonly CaseOrDefaultClause</span><span class="s2">[]) =&gt; </span><span class="s1">CaseBlock</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNamespaceExportDeclaration</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">NamespaceExportDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateNamespaceExportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateNamespaceExportDeclaration</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamespaceExportDeclaration</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">NamespaceExportDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createImportEqualsDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createImportEqualsDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">): </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">): </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateImportEqualsDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateImportEqualsDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">): </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">): </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createImportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createImportDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">importClause</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">?: </span><span class="s1">AssertClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">importClause</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">?: </span><span class="s1">AssertClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateImportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateImportDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportDeclaration</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">importClause</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">: </span><span class="s1">AssertClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">importClause</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">: </span><span class="s1">AssertClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNamespaceImport` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNamespaceImport</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">NamespaceImport</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateNamespaceImport` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateNamespaceImport</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamespaceImport</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">NamespaceImport</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNamedImports` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNamedImports</span><span class="s2">: (</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ImportSpecifier</span><span class="s2">[]) =&gt; </span><span class="s1">NamedImports</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateNamedImports` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateNamedImports</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamedImports</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ImportSpecifier</span><span class="s2">[]) =&gt; </span><span class="s1">NamedImports</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createImportSpecifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createImportSpecifier</span><span class="s2">: (</span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">ImportSpecifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateImportSpecifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateImportSpecifier</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportSpecifier</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">ImportSpecifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExportAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createExportAssignment</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isExportEquals</span><span class="s2">: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isExportEquals</span><span class="s2">: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateExportAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateExportAssignment</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportAssignment</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportAssignment</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNamedExports` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNamedExports</span><span class="s2">: (</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ExportSpecifier</span><span class="s2">[]) =&gt; </span><span class="s1">NamedExports</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateNamedExports` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateNamedExports</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamedExports</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly ExportSpecifier</span><span class="s2">[]) =&gt; </span><span class="s1">NamedExports</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExportSpecifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createExportSpecifier</span><span class="s2">: (</span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">ExportSpecifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateExportSpecifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateExportSpecifier</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportSpecifier</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">propertyName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">ExportSpecifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExternalModuleReference` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createExternalModuleReference</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExternalModuleReference</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateExternalModuleReference` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateExternalModuleReference</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExternalModuleReference</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExternalModuleReference</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocTypeExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocTypeExpression</span><span class="s2">: (</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">JSDocTypeExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocTypeTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocTypeTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocTypeTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocReturnTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocReturnTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocReturnTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocThisTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocThisTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocThisTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocComment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocComment</span><span class="s2">: (</span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">tags</span><span class="s2">?: </span><span class="s1">readonly JSDocTag</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDoc</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocParameterTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">isBracketed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isNameFirst</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocParameterTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocClassTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocClassTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocClassTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocAugmentsTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocAugmentsTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">className</span><span class="s2">: </span><span class="s1">ExpressionWithTypeArguments </span><span class="s2">&amp; {</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PropertyAccessEntityNameExpression</span><span class="s2">;</span>
    <span class="s2">}, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocAugmentsTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocEnumTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocEnumTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocTypeExpression</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocEnumTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocTemplateTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocTemplateTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[], </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocTemplateTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocTypedefTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocTypedefTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeLiteral </span><span class="s2">| </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">fullName</span><span class="s2">?: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocTypedefTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocCallbackTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocCallbackTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">: </span><span class="s1">JSDocSignature</span><span class="s2">, </span><span class="s1">fullName</span><span class="s2">?: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">JSDocNamespaceDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocCallbackTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocSignature</span><span class="s2">: (</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly JSDocTemplateTag</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly JSDocParameterTag</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">JSDocReturnTag </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocSignature</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocPropertyTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocPropertyTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">isBracketed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isNameFirst</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocPropertyTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocTypeLiteral` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocTypeLiteral</span><span class="s2">: (</span><span class="s1">jsDocPropertyTags</span><span class="s2">?: </span><span class="s1">readonly JSDocPropertyLikeTag</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isArrayType</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocTypeLiteral</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocImplementsTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocImplementsTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">className</span><span class="s2">: </span><span class="s1">ExpressionWithTypeArguments </span><span class="s2">&amp; {</span>
        <span class="s1">readonly expression</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">PropertyAccessEntityNameExpression</span><span class="s2">;</span>
    <span class="s2">}, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocImplementsTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocAuthorTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocAuthorTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocAuthorTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocPublicTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocPublicTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocPublicTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocPrivateTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocPrivateTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocPrivateTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocProtectedTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocProtectedTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocProtectedTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocReadonlyTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocReadonlyTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocReadonlyTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocUnknownTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocTag</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">JSDocComment</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocUnknownTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxElement</span><span class="s2">: (</span><span class="s1">openingElement</span><span class="s2">: </span><span class="s1">JsxOpeningElement</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">readonly JsxChild</span><span class="s2">[], </span><span class="s1">closingElement</span><span class="s2">: </span><span class="s1">JsxClosingElement</span><span class="s2">) =&gt; </span><span class="s1">JsxElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxElement</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxElement</span><span class="s2">, </span><span class="s1">openingElement</span><span class="s2">: </span><span class="s1">JsxOpeningElement</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">readonly JsxChild</span><span class="s2">[], </span><span class="s1">closingElement</span><span class="s2">: </span><span class="s1">JsxClosingElement</span><span class="s2">) =&gt; </span><span class="s1">JsxElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxSelfClosingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxSelfClosingElement</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">) =&gt; </span><span class="s1">JsxSelfClosingElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxSelfClosingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxSelfClosingElement</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxSelfClosingElement</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">) =&gt; </span><span class="s1">JsxSelfClosingElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxOpeningElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxOpeningElement</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">) =&gt; </span><span class="s1">JsxOpeningElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxOpeningElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxOpeningElement</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxOpeningElement</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">attributes</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">) =&gt; </span><span class="s1">JsxOpeningElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxClosingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxClosingElement</span><span class="s2">: (</span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">) =&gt; </span><span class="s1">JsxClosingElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxClosingElement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxClosingElement</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxClosingElement</span><span class="s2">, </span><span class="s1">tagName</span><span class="s2">: </span><span class="s1">JsxTagNameExpression</span><span class="s2">) =&gt; </span><span class="s1">JsxClosingElement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxFragment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxFragment</span><span class="s2">: (</span><span class="s1">openingFragment</span><span class="s2">: </span><span class="s1">JsxOpeningFragment</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">readonly JsxChild</span><span class="s2">[], </span><span class="s1">closingFragment</span><span class="s2">: </span><span class="s1">JsxClosingFragment</span><span class="s2">) =&gt; </span><span class="s1">JsxFragment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxText` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxText</span><span class="s2">: (</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containsOnlyTriviaWhiteSpaces</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JsxText</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxText` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxText</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxText</span><span class="s2">, </span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">, </span><span class="s1">containsOnlyTriviaWhiteSpaces</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JsxText</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxOpeningFragment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxOpeningFragment</span><span class="s2">: () =&gt; </span><span class="s1">JsxOpeningFragment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxJsxClosingFragment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxJsxClosingFragment</span><span class="s2">: () =&gt; </span><span class="s1">JsxClosingFragment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxFragment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxFragment</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxFragment</span><span class="s2">, </span><span class="s1">openingFragment</span><span class="s2">: </span><span class="s1">JsxOpeningFragment</span><span class="s2">, </span><span class="s1">children</span><span class="s2">: </span><span class="s1">readonly JsxChild</span><span class="s2">[], </span><span class="s1">closingFragment</span><span class="s2">: </span><span class="s1">JsxClosingFragment</span><span class="s2">) =&gt; </span><span class="s1">JsxFragment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxAttribute` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxAttribute</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">JsxAttributeValue </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JsxAttribute</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxAttribute` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxAttribute</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxAttribute</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">JsxAttributeValue </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JsxAttribute</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxAttributes` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxAttributes</span><span class="s2">: (</span><span class="s1">properties</span><span class="s2">: </span><span class="s1">readonly JsxAttributeLike</span><span class="s2">[]) =&gt; </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxAttributes` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxAttributes</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxAttributes</span><span class="s2">, </span><span class="s1">properties</span><span class="s2">: </span><span class="s1">readonly JsxAttributeLike</span><span class="s2">[]) =&gt; </span><span class="s1">JsxAttributes</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxSpreadAttribute` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxSpreadAttribute</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">JsxSpreadAttribute</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxSpreadAttribute` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxSpreadAttribute</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxSpreadAttribute</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">JsxSpreadAttribute</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJsxExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJsxExpression</span><span class="s2">: (</span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JsxExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateJsxExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateJsxExpression</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">JsxExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JsxExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createCaseClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createCaseClause</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]) =&gt; </span><span class="s1">CaseClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateCaseClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateCaseClause</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CaseClause</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]) =&gt; </span><span class="s1">CaseClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createDefaultClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createDefaultClause</span><span class="s2">: (</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]) =&gt; </span><span class="s1">DefaultClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateDefaultClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateDefaultClause</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">DefaultClause</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]) =&gt; </span><span class="s1">DefaultClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createHeritageClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createHeritageClause</span><span class="s2">: (</span><span class="s1">token</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ExtendsKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ImplementsKeyword</span><span class="s2">, </span><span class="s1">types</span><span class="s2">: </span><span class="s1">readonly ExpressionWithTypeArguments</span><span class="s2">[]) =&gt; </span><span class="s1">HeritageClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateHeritageClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateHeritageClause</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">HeritageClause</span><span class="s2">, </span><span class="s1">types</span><span class="s2">: </span><span class="s1">readonly ExpressionWithTypeArguments</span><span class="s2">[]) =&gt; </span><span class="s1">HeritageClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createCatchClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createCatchClause</span><span class="s2">: (</span><span class="s1">variableDeclaration</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">BindingName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">block</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">) =&gt; </span><span class="s1">CatchClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateCatchClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateCatchClause</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CatchClause</span><span class="s2">, </span><span class="s1">variableDeclaration</span><span class="s2">: </span><span class="s1">VariableDeclaration </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">block</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">) =&gt; </span><span class="s1">CatchClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPropertyAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPropertyAssignment</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">PropertyAssignment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updatePropertyAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updatePropertyAssignment</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyAssignment</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">PropertyAssignment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createShorthandPropertyAssignment</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">objectAssignmentInitializer</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ShorthandPropertyAssignment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateShorthandPropertyAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateShorthandPropertyAssignment</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ShorthandPropertyAssignment</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">objectAssignmentInitializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">ShorthandPropertyAssignment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createSpreadAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createSpreadAssignment</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">SpreadAssignment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateSpreadAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateSpreadAssignment</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SpreadAssignment</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">SpreadAssignment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createEnumMember` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createEnumMember</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">EnumMember</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateEnumMember` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateEnumMember</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">EnumMember</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">EnumMember</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateSourceFile` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateSourceFileNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SourceFile</span><span class="s2">, </span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">isDeclarationFile</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">referencedFiles</span><span class="s2">?: </span><span class="s1">readonly FileReference</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeReferences</span><span class="s2">?: </span><span class="s1">readonly FileReference</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">hasNoDefaultLib</span><span class="s2">?: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">libReferences</span><span class="s2">?: </span><span class="s1">readonly FileReference</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">SourceFile</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNotEmittedStatement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNotEmittedStatement</span><span class="s2">: (</span><span class="s1">original</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">NotEmittedStatement</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPartiallyEmittedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPartiallyEmittedExpression</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">original</span><span class="s2">?: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">PartiallyEmittedExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updatePartiallyEmittedExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updatePartiallyEmittedExpression</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PartiallyEmittedExpression</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">PartiallyEmittedExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createCommaListExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createCommaList</span><span class="s2">: (</span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]) =&gt; </span><span class="s1">CommaListExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateCommaListExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateCommaList</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">CommaListExpression</span><span class="s2">, </span><span class="s1">elements</span><span class="s2">: </span><span class="s1">readonly Expression</span><span class="s2">[]) =&gt; </span><span class="s1">CommaListExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createBundle` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createBundle</span><span class="s2">: (</span><span class="s1">sourceFiles</span><span class="s2">: </span><span class="s1">readonly SourceFile</span><span class="s2">[], </span><span class="s1">prepends</span><span class="s2">?: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">UnparsedSource </span><span class="s2">| </span><span class="s1">InputFiles</span><span class="s2">)[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">Bundle</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateBundle` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateBundle</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Bundle</span><span class="s2">, </span><span class="s1">sourceFiles</span><span class="s2">: </span><span class="s1">readonly SourceFile</span><span class="s2">[], </span><span class="s1">prepends</span><span class="s2">?: </span><span class="s1">readonly </span><span class="s2">(</span><span class="s1">UnparsedSource </span><span class="s2">| </span><span class="s1">InputFiles</span><span class="s2">)[] | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">Bundle</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createImmediatelyInvokedFunctionExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createImmediatelyInvokedFunctionExpression</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">param</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">paramValue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">CallExpression</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createImmediatelyInvokedArrowFunction` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createImmediatelyInvokedArrowFunction</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[]): </span><span class="s1">CallExpression</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">statements</span><span class="s2">: </span><span class="s1">readonly Statement</span><span class="s2">[], </span><span class="s1">param</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">paramValue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">CallExpression</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createVoidZero` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createVoidZero</span><span class="s2">: () =&gt; </span><span class="s1">VoidExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExportDefault` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createExportDefault</span><span class="s2">: (</span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExternalModuleExport` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createExternalModuleExport</span><span class="s2">: (</span><span class="s1">exportName</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createNamespaceExport` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createNamespaceExport</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">NamespaceExport</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateNamespaceExport` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateNamespaceExport</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">NamespaceExport</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s1">NamespaceExport</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createToken` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createToken</span><span class="s2">: &lt;</span><span class="s1">TKind </span><span class="s3">extends </span><span class="s1">SyntaxKind</span><span class="s2">&gt;(</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">TKind</span><span class="s2">) =&gt; </span><span class="s1">Token</span><span class="s2">&lt;</span><span class="s1">TKind</span><span class="s2">&gt;;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createIdentifier` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createIdentifier</span><span class="s2">: (</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTempVariable` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTempVariable</span><span class="s2">: (</span><span class="s1">recordTempVariable</span><span class="s2">: ((</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">) =&gt; </span><span class="s3">void</span><span class="s2">) | </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.getGeneratedNameForNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">getGeneratedNameForNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic)` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createOptimisticUniqueName</span><span class="s2">: (</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createUniqueName(text, GeneratedIdentifierFlags.Optimistic | GeneratedIdentifierFlags.FileLevel)` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createFileLevelUniqueName</span><span class="s2">: (</span><span class="s1">text</span><span class="s2">: </span><span class="s1">string</span><span class="s2">) =&gt; </span><span class="s1">Identifier</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createIndexSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createIndexSignature</span><span class="s2">: (</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypePredicateNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypePredicateNode</span><span class="s2">: (</span><span class="s1">parameterName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">ThisTypeNode </span><span class="s2">| </span><span class="s1">string</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">TypePredicateNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTypePredicateNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTypePredicateNode</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypePredicateNode</span><span class="s2">, </span><span class="s1">parameterName</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">ThisTypeNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">) =&gt; </span><span class="s1">TypePredicateNode</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createStringLiteral`, `factory.createStringLiteralFromNode`, `factory.createNumericLiteral`, `factory.createBigIntLiteral`, `factory.createTrue`, `factory.createFalse`, or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createLiteral</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">StringLiteral </span><span class="s2">| </span><span class="s1">NoSubstitutionTemplateLiteral </span><span class="s2">| </span><span class="s1">NumericLiteral </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">): </span><span class="s1">StringLiteral</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">number </span><span class="s2">| </span><span class="s1">PseudoBigInt</span><span class="s2">): </span><span class="s1">NumericLiteral</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">BooleanLiteral</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">value</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">number </span><span class="s2">| </span><span class="s1">PseudoBigInt </span><span class="s2">| </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">PrimaryExpression</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createMethodSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createMethodSignature</span><span class="s2">: (</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">MethodSignature</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateMethodSignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateMethodSignature</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MethodSignature</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">MethodSignature</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTypeOperatorNode` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTypeOperatorNode</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeOperatorNode</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">operator</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">KeyOfKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">UniqueKeyword </span><span class="s2">| </span><span class="s1">SyntaxKind</span><span class="s2">.</span><span class="s1">ReadonlyKeyword</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeOperatorNode</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createTaggedTemplate` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createTaggedTemplate</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">tag</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">template</span><span class="s2">: </span><span class="s1">TemplateLiteral</span><span class="s2">): </span><span class="s1">TaggedTemplateExpression</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">tag</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">template</span><span class="s2">: </span><span class="s1">TemplateLiteral</span><span class="s2">): </span><span class="s1">TaggedTemplateExpression</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateTaggedTemplate` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateTaggedTemplate</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TaggedTemplateExpression</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">template</span><span class="s2">: </span><span class="s1">TemplateLiteral</span><span class="s2">): </span><span class="s1">TaggedTemplateExpression</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TaggedTemplateExpression</span><span class="s2">, </span><span class="s1">tag</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">template</span><span class="s2">: </span><span class="s1">TemplateLiteral</span><span class="s2">): </span><span class="s1">TaggedTemplateExpression</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateBinary` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateBinary</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">BinaryExpression</span><span class="s2">, </span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">operator</span><span class="s2">?: </span><span class="s1">BinaryOperator </span><span class="s2">| </span><span class="s1">BinaryOperatorToken</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createConditional` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createConditional</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">whenTrue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">whenFalse</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ConditionalExpression</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">condition</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken</span><span class="s2">, </span><span class="s1">whenTrue</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">colonToken</span><span class="s2">: </span><span class="s1">ColonToken</span><span class="s2">, </span><span class="s1">whenFalse</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ConditionalExpression</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createYield` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createYield</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">expression</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">YieldExpression</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">YieldExpression</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createClassExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createClassExpression</span><span class="s2">: (</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]) =&gt; </span><span class="s1">ClassExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateClassExpression` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateClassExpression</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassExpression</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]) =&gt; </span><span class="s1">ClassExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPropertySignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPropertySignature</span><span class="s2">: (</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName </span><span class="s2">| </span><span class="s1">string</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">PropertySignature</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updatePropertySignature` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updatePropertySignature</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertySignature</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">PropertySignature</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createExpressionWithTypeArguments</span><span class="s2">: (</span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateExpressionWithTypeArguments` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateExpressionWithTypeArguments</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">ExpressionWithTypeArguments</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createArrowFunction` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createArrowFunction</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">equalsGreaterThanToken</span><span class="s2">: </span><span class="s1">EqualsGreaterThanToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ConciseBody</span><span class="s2">): </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ConciseBody</span><span class="s2">): </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateArrowFunction` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateArrowFunction</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrowFunction</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">equalsGreaterThanToken</span><span class="s2">: </span><span class="s1">EqualsGreaterThanToken</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ConciseBody</span><span class="s2">): </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ArrowFunction</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ConciseBody</span><span class="s2">): </span><span class="s1">ArrowFunction</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createVariableDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createVariableDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">exclamationToken</span><span class="s2">: </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateVariableDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateVariableDeclaration</span><span class="s2">: {</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VariableDeclaration</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
        <span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">VariableDeclaration</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">exclamationToken</span><span class="s2">: </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">VariableDeclaration</span><span class="s2">;</span>
    <span class="s2">};</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createImportClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createImportClause</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">namedBindings</span><span class="s2">: </span><span class="s1">NamedImportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">) =&gt; </span><span class="s1">ImportClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateImportClause` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateImportClause</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportClause</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">namedBindings</span><span class="s2">: </span><span class="s1">NamedImportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">) =&gt; </span><span class="s1">ImportClause</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createExportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createExportDeclaration</span><span class="s2">: (</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">exportClause</span><span class="s2">: </span><span class="s1">NamedExportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">) =&gt; </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.updateExportDeclaration` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">updateExportDeclaration</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">exportClause</span><span class="s2">: </span><span class="s1">NamedExportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">) =&gt; </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createJSDocParameterTag` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createJSDocParamTag</span><span class="s2">: (</span><span class="s1">name</span><span class="s2">: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">isBracketed</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">typeExpression</span><span class="s2">?: </span><span class="s1">JSDocTypeExpression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">comment</span><span class="s2">?: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">) =&gt; </span><span class="s1">JSDocParameterTag</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createComma` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createComma</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createLessThan` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createLessThan</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">Expression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createAssignment` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createAssignment</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createStrictEquality` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createStrictEquality</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createStrictInequality` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createStrictInequality</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createAdd` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createAdd</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createSubtract` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createSubtract</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createLogicalAnd` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createLogicalAnd</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createLogicalOr` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createLogicalOr</span><span class="s2">: (</span><span class="s1">left</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">right</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">BinaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createPostfixIncrement` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createPostfixIncrement</span><span class="s2">: (</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">PostfixUnaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `factory.createLogicalNot` or the factory supplied by your transformation context instead. */</span>
    <span class="s3">const </span><span class="s1">createLogicalNot</span><span class="s2">: (</span><span class="s1">operand</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">) =&gt; </span><span class="s1">PrefixUnaryExpression</span><span class="s2">;</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use an appropriate `factory` method instead. */</span>
    <span class="s3">const </span><span class="s1">createNode</span><span class="s2">: (</span><span class="s1">kind</span><span class="s2">: </span><span class="s1">SyntaxKind</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">, </span><span class="s1">end</span><span class="s2">?: </span><span class="s1">any</span><span class="s2">) =&gt; </span><span class="s1">Node</span><span class="s2">;</span>
    <span class="s5">/**</span>
     <span class="s5">* Creates a shallow, memberwise clone of a node ~for mutation~ with its `pos`, `end`, and `parent` set.</span>
     <span class="s5">*</span>
     <span class="s5">* NOTE: It is unsafe to change any properties of a `Node` that relate to its AST children, as those changes won't be</span>
     <span class="s5">* captured with respect to transformations.</span>
     <span class="s5">*</span>
     <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Use an appropriate `factory.update...` method instead, use `setCommentRange` or `setSourceMapRange`, and avoid setting `parent`.</span>
     <span class="s5">*/</span>
    <span class="s3">const </span><span class="s1">getMutableClone</span><span class="s2">: &lt;</span><span class="s1">T </span><span class="s3">extends </span><span class="s1">Node</span><span class="s2">&gt;(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">T</span><span class="s2">) =&gt; </span><span class="s1">T</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use `isTypeAssertionExpression` instead. */</span>
    <span class="s3">const </span><span class="s1">isTypeAssertion</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">node </span><span class="s2">is </span><span class="s1">TypeAssertion</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/**</span>
     <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Use `ts.ReadonlyESMap&lt;K, V&gt;` instead.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">ReadonlyMap</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ReadonlyESMap</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">, </span><span class="s1">T</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
    <span class="s5">/**</span>
     <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Use `ts.ESMap&lt;K, V&gt;` instead.</span>
     <span class="s5">*/</span>
    <span class="s3">interface </span><span class="s1">Map</span><span class="s2">&lt;</span><span class="s1">T</span><span class="s2">&gt; </span><span class="s3">extends </span><span class="s1">ESMap</span><span class="s2">&lt;</span><span class="s1">string</span><span class="s2">, </span><span class="s1">T</span><span class="s2">&gt; {</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s5">/**</span>
     <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Use `isMemberName` instead.</span>
     <span class="s5">*/</span>
    <span class="s3">const </span><span class="s1">isIdentifierOrPrivateIdentifier</span><span class="s2">: (</span><span class="s1">node</span><span class="s2">: </span><span class="s1">Node</span><span class="s2">) =&gt; </span><span class="s1">node </span><span class="s2">is </span><span class="s1">MemberName</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">NodeFactory </span><span class="s2">{</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use the overload that accepts 'modifiers' */</span>
        <span class="s1">createConstructorTypeNode</span><span class="s2">(</span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use the overload that accepts 'modifiers' */</span>
        <span class="s1">updateConstructorTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructorTypeNode</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">TypeParameterDeclaration</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ParameterDeclaration</span><span class="s2">&gt;, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">ConstructorTypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">NodeFactory </span><span class="s2">{</span>
        <span class="s1">createImportTypeNode</span><span class="s2">(</span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">assertions</span><span class="s2">?: </span><span class="s1">ImportTypeAssertionContainer</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">?: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[], </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use the overload that accepts 'assertions' */</span>
        <span class="s1">createImportTypeNode</span><span class="s2">(</span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">?: </span><span class="s1">EntityName</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">?: </span><span class="s1">readonly TypeNode</span><span class="s2">[], </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use the overload that accepts 'assertions' */</span>
        <span class="s1">updateImportTypeNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportTypeNode</span><span class="s2">, </span><span class="s1">argument</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">qualifier</span><span class="s2">: </span><span class="s1">EntityName </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeArguments</span><span class="s2">: </span><span class="s1">readonly TypeNode</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOf</span><span class="s2">?: </span><span class="s1">boolean</span><span class="s2">): </span><span class="s1">ImportTypeNode</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">NodeFactory </span><span class="s2">{</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use the overload that accepts 'modifiers' */</span>
        <span class="s1">createTypeParameterDeclaration</span><span class="s2">(</span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">defaultType</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">Use the overload that accepts 'modifiers' */</span>
        <span class="s1">updateTypeParameterDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeParameterDeclaration</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">constraint</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">defaultType</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">TypeParameterDeclaration</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s1">declare namespace ts </span><span class="s2">{</span>
    <span class="s3">interface </span><span class="s1">Node </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">`decorators` has been removed from `Node` and merged with `modifiers` on the `Node` subtypes that support them.</span>
         <span class="s5">* Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.</span>
         <span class="s5">* Use `ts.getDecorators()` to get the decorators of a `Node`.</span>
         <span class="s5">*</span>
         <span class="s5">* For example:</span>
         <span class="s5">* ```ts</span>
         <span class="s5">* const decorators = ts.canHaveDecorators(node) ? ts.getDecorators(node) : undefined;</span>
         <span class="s5">* ```</span>
         <span class="s5">*/</span>
        <span class="s1">readonly decorators</span><span class="s2">?: </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">`modifiers` has been removed from `Node` and moved to the `Node` subtypes that support them.</span>
         <span class="s5">* Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.</span>
         <span class="s5">* Use `ts.getModifiers()` to get the modifiers of a `Node`.</span>
         <span class="s5">*</span>
         <span class="s5">* For example:</span>
         <span class="s5">* ```ts</span>
         <span class="s5">* const modifiers = ts.canHaveModifiers(node) ? ts.getModifiers(node) : undefined;</span>
         <span class="s5">* ```</span>
         <span class="s5">*/</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">ModifierLike</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">PropertySignature </span><span class="s2">{</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">A property signature cannot have an initializer */</span>
        <span class="s1">readonly initializer</span><span class="s2">?: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">PropertyAssignment </span><span class="s2">{</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">A property assignment cannot have a question token */</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">A property assignment cannot have an exclamation token */</span>
        <span class="s1">readonly exclamationToken</span><span class="s2">?: </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">ShorthandPropertyAssignment </span><span class="s2">{</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">A shorthand property assignment cannot have modifiers */</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">A shorthand property assignment cannot have a question token */</span>
        <span class="s1">readonly questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">A shorthand property assignment cannot have an exclamation token */</span>
        <span class="s1">readonly exclamationToken</span><span class="s2">?: </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">FunctionTypeNode </span><span class="s2">{</span>
        <span class="s5">/** </span><span class="s7">@deprecated </span><span class="s5">A function type cannot have modifiers */</span>
        <span class="s1">readonly modifiers</span><span class="s2">?: </span><span class="s1">NodeArray</span><span class="s2">&lt;</span><span class="s1">Modifier</span><span class="s2">&gt; | </span><span class="s1">undefined</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">interface </span><span class="s1">NodeFactory </span><span class="s2">{</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createParameterDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">?: </span><span class="s1">QuestionToken</span><span class="s2">, </span><span class="s1">type</span><span class="s2">?: </span><span class="s1">TypeNode</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateParameterDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ParameterDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">dotDotDotToken</span><span class="s2">: </span><span class="s1">DotDotDotToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">BindingName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ParameterDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createPropertyDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionOrExclamationToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updatePropertyDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">PropertyDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionOrExclamationToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">ExclamationToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">initializer</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">PropertyDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createMethodDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateMethodDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">MethodDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">questionToken</span><span class="s2">: </span><span class="s1">QuestionToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">MethodDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createConstructorDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">This node does not support Decorators. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateConstructorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ConstructorDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ConstructorDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createGetAccessorDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateGetAccessorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">GetAccessorDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">GetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createSetAccessorDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateSetAccessorDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">SetAccessorDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">PropertyName</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">SetAccessorDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createIndexSignature</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.</span>
         <span class="s5">*/</span>
        <span class="s1">updateIndexSignature</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">IndexSignatureDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators and modifiers are no longer supported for this function. Callers should use an overload that does not accept the `decorators` and `modifiers` parameters.</span>
         <span class="s5">*/</span>
        <span class="s1">createClassStaticBlockDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">): </span><span class="s1">ClassStaticBlockDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateClassStaticBlockDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassStaticBlockDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block</span><span class="s2">): </span><span class="s1">ClassStaticBlockDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createClassExpression</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassExpression</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateClassExpression</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassExpression</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassExpression</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createFunctionDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateFunctionDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">FunctionDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">asteriskToken</span><span class="s2">: </span><span class="s1">AsteriskToken </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">parameters</span><span class="s2">: </span><span class="s1">readonly ParameterDeclaration</span><span class="s2">[], </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">Block </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">FunctionDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createClassDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators have been combined with modifiers. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateClassDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ClassDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly ClassElement</span><span class="s2">[]): </span><span class="s1">ClassDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createInterfaceDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[]): </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateInterfaceDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">InterfaceDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">heritageClauses</span><span class="s2">: </span><span class="s1">readonly HeritageClause</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly TypeElement</span><span class="s2">[]): </span><span class="s1">InterfaceDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createTypeAliasDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateTypeAliasDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">TypeAliasDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">typeParameters</span><span class="s2">: </span><span class="s1">readonly TypeParameterDeclaration</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">type</span><span class="s2">: </span><span class="s1">TypeNode</span><span class="s2">): </span><span class="s1">TypeAliasDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createEnumDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly EnumMember</span><span class="s2">[]): </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateEnumDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">EnumDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">members</span><span class="s2">: </span><span class="s1">readonly EnumMember</span><span class="s2">[]): </span><span class="s1">EnumDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createModuleDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">flags</span><span class="s2">?: </span><span class="s1">NodeFlags</span><span class="s2">): </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateModuleDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ModuleDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">ModuleName</span><span class="s2">, </span><span class="s1">body</span><span class="s2">: </span><span class="s1">ModuleBody </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ModuleDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createImportEqualsDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">string </span><span class="s2">| </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">): </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateImportEqualsDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">name</span><span class="s2">: </span><span class="s1">Identifier</span><span class="s2">, </span><span class="s1">moduleReference</span><span class="s2">: </span><span class="s1">ModuleReference</span><span class="s2">): </span><span class="s1">ImportEqualsDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createImportDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">importClause</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">?: </span><span class="s1">AssertClause</span><span class="s2">): </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateImportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ImportDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">importClause</span><span class="s2">: </span><span class="s1">ImportClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">: </span><span class="s1">AssertClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ImportDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createExportAssignment</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isExportEquals</span><span class="s2">: </span><span class="s1">boolean </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateExportAssignment</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportAssignment</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">expression</span><span class="s2">: </span><span class="s1">Expression</span><span class="s2">): </span><span class="s1">ExportAssignment</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">createExportDeclaration</span><span class="s2">(</span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">exportClause</span><span class="s2">: </span><span class="s1">NamedExportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">?: </span><span class="s1">Expression</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">?: </span><span class="s1">AssertClause</span><span class="s2">): </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
        <span class="s5">/**</span>
         <span class="s5">* </span><span class="s7">@deprecated </span><span class="s5">Decorators are no longer supported for this function. Callers should use an overload that does not accept a `decorators` parameter.</span>
         <span class="s5">*/</span>
        <span class="s1">updateExportDeclaration</span><span class="s2">(</span><span class="s1">node</span><span class="s2">: </span><span class="s1">ExportDeclaration</span><span class="s2">, </span><span class="s1">decorators</span><span class="s2">: </span><span class="s1">readonly Decorator</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">modifiers</span><span class="s2">: </span><span class="s1">readonly Modifier</span><span class="s2">[] | </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">isTypeOnly</span><span class="s2">: </span><span class="s1">boolean</span><span class="s2">, </span><span class="s1">exportClause</span><span class="s2">: </span><span class="s1">NamedExportBindings </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">moduleSpecifier</span><span class="s2">: </span><span class="s1">Expression </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">, </span><span class="s1">assertClause</span><span class="s2">: </span><span class="s1">AssertClause </span><span class="s2">| </span><span class="s1">undefined</span><span class="s2">): </span><span class="s1">ExportDeclaration</span><span class="s2">;</span>
    <span class="s2">}</span>
<span class="s2">}</span>

<span class="s3">export </span><span class="s2">= </span><span class="s1">ts</span><span class="s2">;</span></pre>
</body>
</html>