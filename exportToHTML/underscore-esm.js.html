<html>
<head>
<title>underscore-esm.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #6aab73;}
.s5 { color: #2aacb8;}
.s6 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
underscore-esm.js</font>
</center></td></tr></table>
<pre><span class="s0">//     Underscore.js 1.12.1</span>
<span class="s0">//     https://underscorejs.org</span>
<span class="s0">//     (c) 2009-2020 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors</span>
<span class="s0">//     Underscore may be freely distributed under the MIT license.</span>

<span class="s0">// Current version.</span>
<span class="s2">var </span><span class="s1">VERSION </span><span class="s3">= </span><span class="s4">'1.12.1'</span><span class="s3">;</span>

<span class="s0">// Establish the root object, `window` (`self`) in the browser, `global`</span>
<span class="s0">// on the server, or `this` in some virtual machines. We use `self`</span>
<span class="s0">// instead of `window` for `WebWorker` support.</span>
<span class="s2">var </span><span class="s1">root </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">self </span><span class="s3">== </span><span class="s4">'object' </span><span class="s3">&amp;&amp; </span><span class="s1">self</span><span class="s3">.</span><span class="s1">self </span><span class="s3">=== </span><span class="s1">self </span><span class="s3">&amp;&amp; </span><span class="s1">self </span><span class="s3">||</span>
          <span class="s2">typeof </span><span class="s1">global </span><span class="s3">== </span><span class="s4">'object' </span><span class="s3">&amp;&amp; </span><span class="s1">global</span><span class="s3">.</span><span class="s1">global </span><span class="s3">=== </span><span class="s1">global </span><span class="s3">&amp;&amp; </span><span class="s1">global </span><span class="s3">||</span>
          <span class="s1">Function</span><span class="s3">(</span><span class="s4">'return this'</span><span class="s3">)() ||</span>
          <span class="s3">{};</span>

<span class="s0">// Save bytes in the minified (but not gzipped) version:</span>
<span class="s2">var </span><span class="s1">ArrayProto </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">, </span><span class="s1">ObjProto </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">;</span>
<span class="s2">var </span><span class="s1">SymbolProto </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">Symbol </span><span class="s3">!== </span><span class="s4">'undefined' </span><span class="s3">? </span><span class="s1">Symbol</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">: </span><span class="s2">null</span><span class="s3">;</span>

<span class="s0">// Create quick reference variables for speed access to core prototypes.</span>
<span class="s2">var </span><span class="s1">push </span><span class="s3">= </span><span class="s1">ArrayProto</span><span class="s3">.</span><span class="s1">push</span><span class="s3">,</span>
    <span class="s1">slice </span><span class="s3">= </span><span class="s1">ArrayProto</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">,</span>
    <span class="s1">toString </span><span class="s3">= </span><span class="s1">ObjProto</span><span class="s3">.</span><span class="s1">toString</span><span class="s3">,</span>
    <span class="s1">hasOwnProperty </span><span class="s3">= </span><span class="s1">ObjProto</span><span class="s3">.</span><span class="s1">hasOwnProperty</span><span class="s3">;</span>

<span class="s0">// Modern feature detection.</span>
<span class="s2">var </span><span class="s1">supportsArrayBuffer </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">ArrayBuffer </span><span class="s3">!== </span><span class="s4">'undefined'</span><span class="s3">,</span>
    <span class="s1">supportsDataView </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">DataView </span><span class="s3">!== </span><span class="s4">'undefined'</span><span class="s3">;</span>

<span class="s0">// All **ECMAScript 5+** native function implementations that we hope to use</span>
<span class="s0">// are declared here.</span>
<span class="s2">var </span><span class="s1">nativeIsArray </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">.</span><span class="s1">isArray</span><span class="s3">,</span>
    <span class="s1">nativeKeys </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">keys</span><span class="s3">,</span>
    <span class="s1">nativeCreate </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">.</span><span class="s1">create</span><span class="s3">,</span>
    <span class="s1">nativeIsView </span><span class="s3">= </span><span class="s1">supportsArrayBuffer </span><span class="s3">&amp;&amp; </span><span class="s1">ArrayBuffer</span><span class="s3">.</span><span class="s1">isView</span><span class="s3">;</span>

<span class="s0">// Create references to these builtin functions because we override them.</span>
<span class="s2">var </span><span class="s1">_isNaN </span><span class="s3">= </span><span class="s1">isNaN</span><span class="s3">,</span>
    <span class="s1">_isFinite </span><span class="s3">= </span><span class="s1">isFinite</span><span class="s3">;</span>

<span class="s0">// Keys in IE &lt; 9 that won't be iterated by `for key in ...` and thus missed.</span>
<span class="s2">var </span><span class="s1">hasEnumBug </span><span class="s3">= !{</span><span class="s1">toString</span><span class="s3">: </span><span class="s2">null</span><span class="s3">}.</span><span class="s1">propertyIsEnumerable</span><span class="s3">(</span><span class="s4">'toString'</span><span class="s3">);</span>
<span class="s2">var </span><span class="s1">nonEnumerableProps </span><span class="s3">= [</span><span class="s4">'valueOf'</span><span class="s3">, </span><span class="s4">'isPrototypeOf'</span><span class="s3">, </span><span class="s4">'toString'</span><span class="s3">,</span>
  <span class="s4">'propertyIsEnumerable'</span><span class="s3">, </span><span class="s4">'hasOwnProperty'</span><span class="s3">, </span><span class="s4">'toLocaleString'</span><span class="s3">];</span>

<span class="s0">// The largest integer that can be represented exactly.</span>
<span class="s2">var </span><span class="s1">MAX_ARRAY_INDEX </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">pow</span><span class="s3">(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">53</span><span class="s3">) - </span><span class="s5">1</span><span class="s3">;</span>

<span class="s0">// Some functions take a variable number of arguments, or a few expected</span>
<span class="s0">// arguments at the beginning and then a variable number of values to operate</span>
<span class="s0">// on. This helper accumulates all remaining arguments past the function’s</span>
<span class="s0">// argument length (or an explicit `startIndex`), into an array that becomes</span>
<span class="s0">// the last argument. Similar to ES6’s &quot;rest parameter&quot;.</span>
<span class="s2">function </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">startIndex</span><span class="s3">) {</span>
  <span class="s1">startIndex </span><span class="s3">= </span><span class="s1">startIndex </span><span class="s3">== </span><span class="s2">null </span><span class="s3">? </span><span class="s1">func</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s5">1 </span><span class="s3">: +</span><span class="s1">startIndex</span><span class="s3">;</span>
  <span class="s2">return function</span><span class="s3">() {</span>
    <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s1">startIndex</span><span class="s3">, </span><span class="s5">0</span><span class="s3">),</span>
        <span class="s1">rest </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">length</span><span class="s3">),</span>
        <span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
      <span class="s1">rest</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">index </span><span class="s3">+ </span><span class="s1">startIndex</span><span class="s3">];</span>
    <span class="s3">}</span>
    <span class="s2">switch </span><span class="s3">(</span><span class="s1">startIndex</span><span class="s3">) {</span>
      <span class="s2">case </span><span class="s5">0</span><span class="s3">: </span><span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">rest</span><span class="s3">);</span>
      <span class="s2">case </span><span class="s5">1</span><span class="s3">: </span><span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">rest</span><span class="s3">);</span>
      <span class="s2">case </span><span class="s5">2</span><span class="s3">: </span><span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">arguments</span><span class="s3">[</span><span class="s5">1</span><span class="s3">], </span><span class="s1">rest</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">var </span><span class="s1">args </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">startIndex </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">);</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">startIndex</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
      <span class="s1">args</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">index</span><span class="s3">];</span>
    <span class="s3">}</span>
    <span class="s1">args</span><span class="s3">[</span><span class="s1">startIndex</span><span class="s3">] = </span><span class="s1">rest</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Is a given variable an object?</span>
<span class="s2">function </span><span class="s1">isObject</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">type </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">obj</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'function' </span><span class="s3">|| </span><span class="s1">type </span><span class="s3">=== </span><span class="s4">'object' </span><span class="s3">&amp;&amp; !!</span><span class="s1">obj</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Is a given value equal to null?</span>
<span class="s2">function </span><span class="s1">isNull</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">obj </span><span class="s3">=== </span><span class="s2">null</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Is a given variable undefined?</span>
<span class="s2">function </span><span class="s1">isUndefined</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">obj </span><span class="s3">=== </span><span class="s2">void </span><span class="s5">0</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Is a given value a boolean?</span>
<span class="s2">function </span><span class="s1">isBoolean</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">obj </span><span class="s3">=== </span><span class="s2">true </span><span class="s3">|| </span><span class="s1">obj </span><span class="s3">=== </span><span class="s2">false </span><span class="s3">|| </span><span class="s1">toString</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) === </span><span class="s4">'[object Boolean]'</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Is a given value a DOM element?</span>
<span class="s2">function </span><span class="s1">isElement</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s3">!!(</span><span class="s1">obj </span><span class="s3">&amp;&amp; </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">nodeType </span><span class="s3">=== </span><span class="s5">1</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Internal function for creating a `toString`-based type tester.</span>
<span class="s2">function </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">tag </span><span class="s3">= </span><span class="s4">'[object ' </span><span class="s3">+ </span><span class="s1">name </span><span class="s3">+ </span><span class="s4">']'</span><span class="s3">;</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">toString</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) === </span><span class="s1">tag</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s2">var </span><span class="s1">isString </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'String'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isNumber </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Number'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isDate </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Date'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isRegExp </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'RegExp'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isError </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Error'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isSymbol </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Symbol'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isArrayBuffer </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'ArrayBuffer'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isFunction </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Function'</span><span class="s3">);</span>

<span class="s0">// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old</span>
<span class="s0">// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).</span>
<span class="s2">var </span><span class="s1">nodelist </span><span class="s3">= </span><span class="s1">root</span><span class="s3">.</span><span class="s1">document </span><span class="s3">&amp;&amp; </span><span class="s1">root</span><span class="s3">.</span><span class="s1">document</span><span class="s3">.</span><span class="s1">childNodes</span><span class="s3">;</span>
<span class="s2">if </span><span class="s3">(</span><span class="s2">typeof </span><span class="s6">/./ </span><span class="s3">!= </span><span class="s4">'function' </span><span class="s3">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">Int8Array </span><span class="s3">!= </span><span class="s4">'object' </span><span class="s3">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">nodelist </span><span class="s3">!= </span><span class="s4">'function'</span><span class="s3">) {</span>
  <span class="s1">isFunction </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">return typeof </span><span class="s1">obj </span><span class="s3">== </span><span class="s4">'function' </span><span class="s3">|| </span><span class="s2">false</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s2">var </span><span class="s1">isFunction$1 </span><span class="s3">= </span><span class="s1">isFunction</span><span class="s3">;</span>

<span class="s2">var </span><span class="s1">hasObjectTag </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Object'</span><span class="s3">);</span>

<span class="s0">// In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.</span>
<span class="s0">// In IE 11, the most common among them, this problem also applies to</span>
<span class="s0">// `Map`, `WeakMap` and `Set`.</span>
<span class="s2">var </span><span class="s1">hasStringTagBug </span><span class="s3">= (</span>
      <span class="s1">supportsDataView </span><span class="s3">&amp;&amp; </span><span class="s1">hasObjectTag</span><span class="s3">(</span><span class="s2">new </span><span class="s1">DataView</span><span class="s3">(</span><span class="s2">new </span><span class="s1">ArrayBuffer</span><span class="s3">(</span><span class="s5">8</span><span class="s3">)))</span>
    <span class="s3">),</span>
    <span class="s1">isIE11 </span><span class="s3">= (</span><span class="s2">typeof </span><span class="s1">Map </span><span class="s3">!== </span><span class="s4">'undefined' </span><span class="s3">&amp;&amp; </span><span class="s1">hasObjectTag</span><span class="s3">(</span><span class="s2">new </span><span class="s1">Map</span><span class="s3">));</span>

<span class="s2">var </span><span class="s1">isDataView </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'DataView'</span><span class="s3">);</span>

<span class="s0">// In IE 10 - Edge 13, we need a different heuristic</span>
<span class="s0">// to determine whether an object is a `DataView`.</span>
<span class="s2">function </span><span class="s1">ie10IsDataView</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">obj </span><span class="s3">!= </span><span class="s2">null </span><span class="s3">&amp;&amp; </span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">getInt8</span><span class="s3">) &amp;&amp; </span><span class="s1">isArrayBuffer</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">buffer</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s2">var </span><span class="s1">isDataView$1 </span><span class="s3">= (</span><span class="s1">hasStringTagBug </span><span class="s3">? </span><span class="s1">ie10IsDataView </span><span class="s3">: </span><span class="s1">isDataView</span><span class="s3">);</span>

<span class="s0">// Is a given value an array?</span>
<span class="s0">// Delegates to ECMA5's native `Array.isArray`.</span>
<span class="s2">var </span><span class="s1">isArray </span><span class="s3">= </span><span class="s1">nativeIsArray </span><span class="s3">|| </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Array'</span><span class="s3">);</span>

<span class="s0">// Internal function to check whether `key` is an own property name of `obj`.</span>
<span class="s2">function </span><span class="s1">has</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">obj </span><span class="s3">!= </span><span class="s2">null </span><span class="s3">&amp;&amp; </span><span class="s1">hasOwnProperty</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s2">var </span><span class="s1">isArguments </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Arguments'</span><span class="s3">);</span>

<span class="s0">// Define a fallback version of the method in browsers (ahem, IE &lt; 9), where</span>
<span class="s0">// there isn't any inspectable &quot;Arguments&quot; type.</span>
<span class="s3">(</span><span class="s2">function</span><span class="s3">() {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">isArguments</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">)) {</span>
    <span class="s1">isArguments </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
      <span class="s2">return </span><span class="s1">has</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s4">'callee'</span><span class="s3">);</span>
    <span class="s3">};</span>
  <span class="s3">}</span>
<span class="s3">}());</span>

<span class="s2">var </span><span class="s1">isArguments$1 </span><span class="s3">= </span><span class="s1">isArguments</span><span class="s3">;</span>

<span class="s0">// Is a given object a finite number?</span>
<span class="s2">function </span><span class="s1">isFinite$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s3">!</span><span class="s1">isSymbol</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; </span><span class="s1">_isFinite</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; !</span><span class="s1">isNaN</span><span class="s3">(</span><span class="s1">parseFloat</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s0">// Is the given value `NaN`?</span>
<span class="s2">function </span><span class="s1">isNaN$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">isNumber</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; </span><span class="s1">_isNaN</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Predicate-generating function. Often useful outside of Underscore.</span>
<span class="s2">function </span><span class="s1">constant</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">() {</span>
    <span class="s2">return </span><span class="s1">value</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Common internal logic for `isArrayLike` and `isBufferLike`.</span>
<span class="s2">function </span><span class="s1">createSizePropertyCheck</span><span class="s3">(</span><span class="s1">getSizeProperty</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">collection</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">sizeProperty </span><span class="s3">= </span><span class="s1">getSizeProperty</span><span class="s3">(</span><span class="s1">collection</span><span class="s3">);</span>
    <span class="s2">return typeof </span><span class="s1">sizeProperty </span><span class="s3">== </span><span class="s4">'number' </span><span class="s3">&amp;&amp; </span><span class="s1">sizeProperty </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">sizeProperty </span><span class="s3">&lt;= </span><span class="s1">MAX_ARRAY_INDEX</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">// Internal helper to generate a function to obtain property `key` from `obj`.</span>
<span class="s2">function </span><span class="s1">shallowProperty</span><span class="s3">(</span><span class="s1">key</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null </span><span class="s3">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s3">: </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Internal helper to obtain the `byteLength` property of an object.</span>
<span class="s2">var </span><span class="s1">getByteLength </span><span class="s3">= </span><span class="s1">shallowProperty</span><span class="s3">(</span><span class="s4">'byteLength'</span><span class="s3">);</span>

<span class="s0">// Internal helper to determine whether we should spend extensive checks against</span>
<span class="s0">// `ArrayBuffer` et al.</span>
<span class="s2">var </span><span class="s1">isBufferLike </span><span class="s3">= </span><span class="s1">createSizePropertyCheck</span><span class="s3">(</span><span class="s1">getByteLength</span><span class="s3">);</span>

<span class="s0">// Is a given value a typed array?</span>
<span class="s2">var </span><span class="s1">typedArrayPattern </span><span class="s3">= </span><span class="s6">/\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/</span><span class="s3">;</span>
<span class="s2">function </span><span class="s1">isTypedArray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s0">// `ArrayBuffer.isView` is the most future-proof, so use it when available.</span>
  <span class="s0">// Otherwise, fall back on the above regular expression.</span>
  <span class="s2">return </span><span class="s1">nativeIsView </span><span class="s3">? (</span><span class="s1">nativeIsView</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; !</span><span class="s1">isDataView$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) :</span>
                <span class="s1">isBufferLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; </span><span class="s1">typedArrayPattern</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">toString</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s2">var </span><span class="s1">isTypedArray$1 </span><span class="s3">= </span><span class="s1">supportsArrayBuffer </span><span class="s3">? </span><span class="s1">isTypedArray </span><span class="s3">: </span><span class="s1">constant</span><span class="s3">(</span><span class="s2">false</span><span class="s3">);</span>

<span class="s0">// Internal helper to obtain the `length` property of an object.</span>
<span class="s2">var </span><span class="s1">getLength </span><span class="s3">= </span><span class="s1">shallowProperty</span><span class="s3">(</span><span class="s4">'length'</span><span class="s3">);</span>

<span class="s0">// Internal helper to create a simple lookup structure.</span>
<span class="s0">// `collectNonEnumProps` used to depend on `_.contains`, but this led to</span>
<span class="s0">// circular imports. `emulatedSet` is a one-off solution that only works for</span>
<span class="s0">// arrays of strings.</span>
<span class="s2">function </span><span class="s1">emulatedSet</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">hash </span><span class="s3">= {};</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">l </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">, </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">l</span><span class="s3">; ++</span><span class="s1">i</span><span class="s3">) </span><span class="s1">hash</span><span class="s3">[</span><span class="s1">keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]] = </span><span class="s2">true</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s3">{</span>
    <span class="s1">contains</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">key</span><span class="s3">) { </span><span class="s2">return </span><span class="s1">hash</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]; },</span>
    <span class="s1">push</span><span class="s3">: </span><span class="s2">function</span><span class="s3">(</span><span class="s1">key</span><span class="s3">) {</span>
      <span class="s1">hash</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s2">true</span><span class="s3">;</span>
      <span class="s2">return </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Internal helper. Checks `keys` for the presence of keys in IE &lt; 9 that won't</span>
<span class="s0">// be iterated by `for key in ...` and thus missed. Extends `keys` in place if</span>
<span class="s0">// needed.</span>
<span class="s2">function </span><span class="s1">collectNonEnumProps</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">) {</span>
  <span class="s1">keys </span><span class="s3">= </span><span class="s1">emulatedSet</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">nonEnumIdx </span><span class="s3">= </span><span class="s1">nonEnumerableProps</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">constructor </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">proto </span><span class="s3">= </span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">constructor</span><span class="s3">) &amp;&amp; </span><span class="s1">constructor</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">|| </span><span class="s1">ObjProto</span><span class="s3">;</span>

  <span class="s0">// Constructor is a special case.</span>
  <span class="s2">var </span><span class="s1">prop </span><span class="s3">= </span><span class="s4">'constructor'</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">has</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">prop</span><span class="s3">) &amp;&amp; !</span><span class="s1">keys</span><span class="s3">.</span><span class="s1">contains</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">)) </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">);</span>

  <span class="s2">while </span><span class="s3">(</span><span class="s1">nonEnumIdx</span><span class="s3">--) {</span>
    <span class="s1">prop </span><span class="s3">= </span><span class="s1">nonEnumerableProps</span><span class="s3">[</span><span class="s1">nonEnumIdx</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">prop </span><span class="s2">in </span><span class="s1">obj </span><span class="s3">&amp;&amp; </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">prop</span><span class="s3">] !== </span><span class="s1">proto</span><span class="s3">[</span><span class="s1">prop</span><span class="s3">] &amp;&amp; !</span><span class="s1">keys</span><span class="s3">.</span><span class="s1">contains</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">)) {</span>
      <span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">// Retrieve the names of an object's own properties.</span>
<span class="s0">// Delegates to **ECMAScript 5**'s native `Object.keys`.</span>
<span class="s2">function </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">isObject</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return </span><span class="s3">[];</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">nativeKeys</span><span class="s3">) </span><span class="s2">return </span><span class="s1">nativeKeys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">keys </span><span class="s3">= [];</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">) </span><span class="s2">if </span><span class="s3">(</span><span class="s1">has</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)) </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
  <span class="s0">// Ahem, IE &lt; 9.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">hasEnumBug</span><span class="s3">) </span><span class="s1">collectNonEnumProps</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">keys</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Is a given array, string, or object empty?</span>
<span class="s0">// An &quot;empty&quot; object has no enumerable own-properties.</span>
<span class="s2">function </span><span class="s1">isEmpty</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return true</span><span class="s3">;</span>
  <span class="s0">// Skip the more expensive `toString`-based type checks if `obj` has no</span>
  <span class="s0">// `.length`.</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s2">typeof </span><span class="s1">length </span><span class="s3">== </span><span class="s4">'number' </span><span class="s3">&amp;&amp; (</span>
    <span class="s1">isArray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) || </span><span class="s1">isString</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) || </span><span class="s1">isArguments$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)</span>
  <span class="s3">)) </span><span class="s2">return </span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) === </span><span class="s5">0</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Returns whether an object has a given set of `key:value` pairs.</span>
<span class="s2">function </span><span class="s1">isMatch</span><span class="s3">(</span><span class="s1">object</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">), </span><span class="s1">length </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">object </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return </span><span class="s3">!</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">(</span><span class="s1">object</span><span class="s3">);</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">key </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] !== </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] || !(</span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// If Underscore is called as a function, it returns a wrapped object that can</span>
<span class="s0">// be used OO-style. This wrapper holds altered versions of all functions added</span>
<span class="s0">// through `_.mixin`. Wrapped objects may be chained.</span>
<span class="s2">function </span><span class="s1">_</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s2">instanceof </span><span class="s1">_</span><span class="s3">) </span><span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(!(</span><span class="s2">this instanceof </span><span class="s1">_</span><span class="s3">)) </span><span class="s2">return new </span><span class="s1">_</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">this</span><span class="s3">.</span><span class="s1">_wrapped </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s1">_</span><span class="s3">.</span><span class="s1">VERSION </span><span class="s3">= </span><span class="s1">VERSION</span><span class="s3">;</span>

<span class="s0">// Extracts the result from a wrapped and chained object.</span>
<span class="s1">_</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">value </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
  <span class="s2">return this</span><span class="s3">.</span><span class="s1">_wrapped</span><span class="s3">;</span>
<span class="s3">};</span>

<span class="s0">// Provide unwrapping proxies for some methods used in engine operations</span>
<span class="s0">// such as arithmetic and JSON stringification.</span>
<span class="s1">_</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">valueOf </span><span class="s3">= </span><span class="s1">_</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">toJSON </span><span class="s3">= </span><span class="s1">_</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">value</span><span class="s3">;</span>

<span class="s1">_</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">.</span><span class="s1">toString </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
  <span class="s2">return </span><span class="s1">String</span><span class="s3">(</span><span class="s2">this</span><span class="s3">.</span><span class="s1">_wrapped</span><span class="s3">);</span>
<span class="s3">};</span>

<span class="s0">// Internal function to wrap or shallow-copy an ArrayBuffer,</span>
<span class="s0">// typed array or DataView to a new view, reusing the buffer.</span>
<span class="s2">function </span><span class="s1">toBufferView</span><span class="s3">(</span><span class="s1">bufferSource</span><span class="s3">) {</span>
  <span class="s2">return new </span><span class="s1">Uint8Array</span><span class="s3">(</span>
    <span class="s1">bufferSource</span><span class="s3">.</span><span class="s1">buffer </span><span class="s3">|| </span><span class="s1">bufferSource</span><span class="s3">,</span>
    <span class="s1">bufferSource</span><span class="s3">.</span><span class="s1">byteOffset </span><span class="s3">|| </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">getByteLength</span><span class="s3">(</span><span class="s1">bufferSource</span><span class="s3">)</span>
  <span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// We use this string twice, so give it a name for minification.</span>
<span class="s2">var </span><span class="s1">tagDataView </span><span class="s3">= </span><span class="s4">'[object DataView]'</span><span class="s3">;</span>

<span class="s0">// Internal recursive comparison function for `_.isEqual`.</span>
<span class="s2">function </span><span class="s1">eq</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">aStack</span><span class="s3">, </span><span class="s1">bStack</span><span class="s3">) {</span>
  <span class="s0">// Identical objects are equal. `0 === -0`, but they aren't identical.</span>
  <span class="s0">// See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">=== </span><span class="s1">b</span><span class="s3">) </span><span class="s2">return </span><span class="s1">a </span><span class="s3">!== </span><span class="s5">0 </span><span class="s3">|| </span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">a </span><span class="s3">=== </span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">b</span><span class="s3">;</span>
  <span class="s0">// `null` or `undefined` only equal to itself (strict comparison).</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">b </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
  <span class="s0">// `NaN`s are equivalent, but non-reflexive.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">!== </span><span class="s1">a</span><span class="s3">) </span><span class="s2">return </span><span class="s1">b </span><span class="s3">!== </span><span class="s1">b</span><span class="s3">;</span>
  <span class="s0">// Exhaust primitive checks</span>
  <span class="s2">var </span><span class="s1">type </span><span class="s3">= </span><span class="s2">typeof </span><span class="s1">a</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">type </span><span class="s3">!== </span><span class="s4">'function' </span><span class="s3">&amp;&amp; </span><span class="s1">type </span><span class="s3">!== </span><span class="s4">'object' </span><span class="s3">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">b </span><span class="s3">!= </span><span class="s4">'object'</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">deepEq</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">aStack</span><span class="s3">, </span><span class="s1">bStack</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Internal recursive comparison function for `_.isEqual`.</span>
<span class="s2">function </span><span class="s1">deepEq</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">aStack</span><span class="s3">, </span><span class="s1">bStack</span><span class="s3">) {</span>
  <span class="s0">// Unwrap any wrapped objects.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">a </span><span class="s2">instanceof </span><span class="s1">_</span><span class="s3">) </span><span class="s1">a </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">_wrapped</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">b </span><span class="s2">instanceof </span><span class="s1">_</span><span class="s3">) </span><span class="s1">b </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">_wrapped</span><span class="s3">;</span>
  <span class="s0">// Compare `[[Class]]` names.</span>
  <span class="s2">var </span><span class="s1">className </span><span class="s3">= </span><span class="s1">toString</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">a</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">className </span><span class="s3">!== </span><span class="s1">toString</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
  <span class="s0">// Work around a bug in IE 10 - Edge 13.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">hasStringTagBug </span><span class="s3">&amp;&amp; </span><span class="s1">className </span><span class="s3">== </span><span class="s4">'[object Object]' </span><span class="s3">&amp;&amp; </span><span class="s1">isDataView$1</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)) {</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">isDataView$1</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s1">className </span><span class="s3">= </span><span class="s1">tagDataView</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">switch </span><span class="s3">(</span><span class="s1">className</span><span class="s3">) {</span>
    <span class="s0">// These types are compared by value.</span>
    <span class="s2">case </span><span class="s4">'[object RegExp]'</span><span class="s3">:</span>
      <span class="s0">// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')</span>
    <span class="s2">case </span><span class="s4">'[object String]'</span><span class="s3">:</span>
      <span class="s0">// Primitives and their corresponding object wrappers are equivalent; thus, `&quot;5&quot;` is</span>
      <span class="s0">// equivalent to `new String(&quot;5&quot;)`.</span>
      <span class="s2">return </span><span class="s4">'' </span><span class="s3">+ </span><span class="s1">a </span><span class="s3">=== </span><span class="s4">'' </span><span class="s3">+ </span><span class="s1">b</span><span class="s3">;</span>
    <span class="s2">case </span><span class="s4">'[object Number]'</span><span class="s3">:</span>
      <span class="s0">// `NaN`s are equivalent, but non-reflexive.</span>
      <span class="s0">// Object(NaN) is equivalent to NaN.</span>
      <span class="s2">if </span><span class="s3">(+</span><span class="s1">a </span><span class="s3">!== +</span><span class="s1">a</span><span class="s3">) </span><span class="s2">return </span><span class="s3">+</span><span class="s1">b </span><span class="s3">!== +</span><span class="s1">b</span><span class="s3">;</span>
      <span class="s0">// An `egal` comparison is performed for other numeric values.</span>
      <span class="s2">return </span><span class="s3">+</span><span class="s1">a </span><span class="s3">=== </span><span class="s5">0 </span><span class="s3">? </span><span class="s5">1 </span><span class="s3">/ +</span><span class="s1">a </span><span class="s3">=== </span><span class="s5">1 </span><span class="s3">/ </span><span class="s1">b </span><span class="s3">: +</span><span class="s1">a </span><span class="s3">=== +</span><span class="s1">b</span><span class="s3">;</span>
    <span class="s2">case </span><span class="s4">'[object Date]'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s4">'[object Boolean]'</span><span class="s3">:</span>
      <span class="s0">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span>
      <span class="s0">// millisecond representations. Note that invalid dates with millisecond representations</span>
      <span class="s0">// of `NaN` are not equivalent.</span>
      <span class="s2">return </span><span class="s3">+</span><span class="s1">a </span><span class="s3">=== +</span><span class="s1">b</span><span class="s3">;</span>
    <span class="s2">case </span><span class="s4">'[object Symbol]'</span><span class="s3">:</span>
      <span class="s2">return </span><span class="s1">SymbolProto</span><span class="s3">.</span><span class="s1">valueOf</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">a</span><span class="s3">) === </span><span class="s1">SymbolProto</span><span class="s3">.</span><span class="s1">valueOf</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">b</span><span class="s3">);</span>
    <span class="s2">case </span><span class="s4">'[object ArrayBuffer]'</span><span class="s3">:</span>
    <span class="s2">case </span><span class="s1">tagDataView</span><span class="s3">:</span>
      <span class="s0">// Coerce to typed array so we can fall through.</span>
      <span class="s2">return </span><span class="s1">deepEq</span><span class="s3">(</span><span class="s1">toBufferView</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">toBufferView</span><span class="s3">(</span><span class="s1">b</span><span class="s3">), </span><span class="s1">aStack</span><span class="s3">, </span><span class="s1">bStack</span><span class="s3">);</span>
  <span class="s3">}</span>

  <span class="s2">var </span><span class="s1">areArrays </span><span class="s3">= </span><span class="s1">className </span><span class="s3">=== </span><span class="s4">'[object Array]'</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">areArrays </span><span class="s3">&amp;&amp; </span><span class="s1">isTypedArray$1</span><span class="s3">(</span><span class="s1">a</span><span class="s3">)) {</span>
      <span class="s2">var </span><span class="s1">byteLength </span><span class="s3">= </span><span class="s1">getByteLength</span><span class="s3">(</span><span class="s1">a</span><span class="s3">);</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">byteLength </span><span class="s3">!== </span><span class="s1">getByteLength</span><span class="s3">(</span><span class="s1">b</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">a</span><span class="s3">.</span><span class="s1">buffer </span><span class="s3">=== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">buffer </span><span class="s3">&amp;&amp; </span><span class="s1">a</span><span class="s3">.</span><span class="s1">byteOffset </span><span class="s3">=== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">byteOffset</span><span class="s3">) </span><span class="s2">return true</span><span class="s3">;</span>
      <span class="s1">areArrays </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">areArrays</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">typeof </span><span class="s1">a </span><span class="s3">!= </span><span class="s4">'object' </span><span class="s3">|| </span><span class="s2">typeof </span><span class="s1">b </span><span class="s3">!= </span><span class="s4">'object'</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>

    <span class="s0">// Objects with different constructors are not equivalent, but `Object`s or `Array`s</span>
    <span class="s0">// from different frames are.</span>
    <span class="s2">var </span><span class="s1">aCtor </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">, </span><span class="s1">bCtor </span><span class="s3">= </span><span class="s1">b</span><span class="s3">.</span><span class="s1">constructor</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">aCtor </span><span class="s3">!== </span><span class="s1">bCtor </span><span class="s3">&amp;&amp; !(</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">aCtor</span><span class="s3">) &amp;&amp; </span><span class="s1">aCtor </span><span class="s2">instanceof </span><span class="s1">aCtor </span><span class="s3">&amp;&amp;</span>
                             <span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">bCtor</span><span class="s3">) &amp;&amp; </span><span class="s1">bCtor </span><span class="s2">instanceof </span><span class="s1">bCtor</span><span class="s3">)</span>
                        <span class="s3">&amp;&amp; (</span><span class="s4">'constructor' </span><span class="s2">in </span><span class="s1">a </span><span class="s3">&amp;&amp; </span><span class="s4">'constructor' </span><span class="s2">in </span><span class="s1">b</span><span class="s3">)) {</span>
      <span class="s2">return false</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s0">// Assume equality for cyclic structures. The algorithm for detecting cyclic</span>
  <span class="s0">// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.</span>

  <span class="s0">// Initializing stack of traversed objects.</span>
  <span class="s0">// It's done here since we only need them for objects and arrays comparison.</span>
  <span class="s1">aStack </span><span class="s3">= </span><span class="s1">aStack </span><span class="s3">|| [];</span>
  <span class="s1">bStack </span><span class="s3">= </span><span class="s1">bStack </span><span class="s3">|| [];</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">aStack</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">while </span><span class="s3">(</span><span class="s1">length</span><span class="s3">--) {</span>
    <span class="s0">// Linear search. Performance is inversely proportional to the number of</span>
    <span class="s0">// unique nested structures.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">aStack</span><span class="s3">[</span><span class="s1">length</span><span class="s3">] === </span><span class="s1">a</span><span class="s3">) </span><span class="s2">return </span><span class="s1">bStack</span><span class="s3">[</span><span class="s1">length</span><span class="s3">] === </span><span class="s1">b</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s0">// Add the first object to the stack of traversed objects.</span>
  <span class="s1">aStack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">a</span><span class="s3">);</span>
  <span class="s1">bStack</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">b</span><span class="s3">);</span>

  <span class="s0">// Recursively compare objects and arrays.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">areArrays</span><span class="s3">) {</span>
    <span class="s0">// Compare array lengths to determine if a deep comparison is necessary.</span>
    <span class="s1">length </span><span class="s3">= </span><span class="s1">a</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">length </span><span class="s3">!== </span><span class="s1">b</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s0">// Deep compare the contents, ignoring non-numeric properties.</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">length</span><span class="s3">--) {</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">eq</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">length</span><span class="s3">], </span><span class="s1">b</span><span class="s3">[</span><span class="s1">length</span><span class="s3">], </span><span class="s1">aStack</span><span class="s3">, </span><span class="s1">bStack</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s0">// Deep compare objects.</span>
    <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">a</span><span class="s3">), </span><span class="s1">key</span><span class="s3">;</span>
    <span class="s1">length </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s0">// Ensure that both objects contain the same number of properties before comparing deep equality.</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">keys</span><span class="s3">(</span><span class="s1">b</span><span class="s3">).</span><span class="s1">length </span><span class="s3">!== </span><span class="s1">length</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">length</span><span class="s3">--) {</span>
      <span class="s0">// Deep compare each member</span>
      <span class="s1">key </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">length</span><span class="s3">];</span>
      <span class="s2">if </span><span class="s3">(!(</span><span class="s1">has</span><span class="s3">(</span><span class="s1">b</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) &amp;&amp; </span><span class="s1">eq</span><span class="s3">(</span><span class="s1">a</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">b</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">aStack</span><span class="s3">, </span><span class="s1">bStack</span><span class="s3">))) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s0">// Remove the first object from the stack of traversed objects.</span>
  <span class="s1">aStack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>
  <span class="s1">bStack</span><span class="s3">.</span><span class="s1">pop</span><span class="s3">();</span>
  <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Perform a deep comparison to check if two objects are equal.</span>
<span class="s2">function </span><span class="s1">isEqual</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">eq</span><span class="s3">(</span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Retrieve all the enumerable property names of an object.</span>
<span class="s2">function </span><span class="s1">allKeys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">isObject</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return </span><span class="s3">[];</span>
  <span class="s2">var </span><span class="s1">keys </span><span class="s3">= [];</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">) </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
  <span class="s0">// Ahem, IE &lt; 9.</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">hasEnumBug</span><span class="s3">) </span><span class="s1">collectNonEnumProps</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">keys</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Since the regular `Object.prototype.toString` type tests don't work for</span>
<span class="s0">// some types in IE 11, we use a fingerprinting heuristic instead, based</span>
<span class="s0">// on the methods. It's not great, but it's the best we got.</span>
<span class="s0">// The fingerprint method lists are defined below.</span>
<span class="s2">function </span><span class="s1">ie11fingerprint</span><span class="s3">(</span><span class="s1">methods</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">methods</span><span class="s3">);</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s0">// `Map`, `WeakMap` and `Set` have no enumerable keys.</span>
    <span class="s2">var </span><span class="s1">keys </span><span class="s3">= </span><span class="s1">allKeys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">methods</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]])) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s0">// If we are testing against `WeakMap`, we need to ensure that</span>
    <span class="s0">// `obj` doesn't have a `forEach` method in order to distinguish</span>
    <span class="s0">// it from a regular `Map`.</span>
    <span class="s2">return </span><span class="s1">methods </span><span class="s3">!== </span><span class="s1">weakMapMethods </span><span class="s3">|| !</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">forEachName</span><span class="s3">]);</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// In the interest of compact minification, we write</span>
<span class="s0">// each string in the fingerprints only once.</span>
<span class="s2">var </span><span class="s1">forEachName </span><span class="s3">= </span><span class="s4">'forEach'</span><span class="s3">,</span>
    <span class="s1">hasName </span><span class="s3">= </span><span class="s4">'has'</span><span class="s3">,</span>
    <span class="s1">commonInit </span><span class="s3">= [</span><span class="s4">'clear'</span><span class="s3">, </span><span class="s4">'delete'</span><span class="s3">],</span>
    <span class="s1">mapTail </span><span class="s3">= [</span><span class="s4">'get'</span><span class="s3">, </span><span class="s1">hasName</span><span class="s3">, </span><span class="s4">'set'</span><span class="s3">];</span>

<span class="s0">// `Map`, `WeakMap` and `Set` each have slightly different</span>
<span class="s0">// combinations of the above sublists.</span>
<span class="s2">var </span><span class="s1">mapMethods </span><span class="s3">= </span><span class="s1">commonInit</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">forEachName</span><span class="s3">, </span><span class="s1">mapTail</span><span class="s3">),</span>
    <span class="s1">weakMapMethods </span><span class="s3">= </span><span class="s1">commonInit</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">mapTail</span><span class="s3">),</span>
    <span class="s1">setMethods </span><span class="s3">= [</span><span class="s4">'add'</span><span class="s3">].</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">commonInit</span><span class="s3">, </span><span class="s1">forEachName</span><span class="s3">, </span><span class="s1">hasName</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isMap </span><span class="s3">= </span><span class="s1">isIE11 </span><span class="s3">? </span><span class="s1">ie11fingerprint</span><span class="s3">(</span><span class="s1">mapMethods</span><span class="s3">) : </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Map'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isWeakMap </span><span class="s3">= </span><span class="s1">isIE11 </span><span class="s3">? </span><span class="s1">ie11fingerprint</span><span class="s3">(</span><span class="s1">weakMapMethods</span><span class="s3">) : </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'WeakMap'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isSet </span><span class="s3">= </span><span class="s1">isIE11 </span><span class="s3">? </span><span class="s1">ie11fingerprint</span><span class="s3">(</span><span class="s1">setMethods</span><span class="s3">) : </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'Set'</span><span class="s3">);</span>

<span class="s2">var </span><span class="s1">isWeakSet </span><span class="s3">= </span><span class="s1">tagTester</span><span class="s3">(</span><span class="s4">'WeakSet'</span><span class="s3">);</span>

<span class="s0">// Retrieve the values of an object's properties.</span>
<span class="s2">function </span><span class="s1">values</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">values </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">length</span><span class="s3">);</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s1">values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]];</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">values</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Convert an object into a list of `[key, value]` pairs.</span>
<span class="s0">// The opposite of `_.object` with one argument.</span>
<span class="s2">function </span><span class="s1">pairs</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">pairs </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">length</span><span class="s3">);</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s1">pairs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = [</span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]]];</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">pairs</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Invert the keys and values of an object. The values must be serializable.</span>
<span class="s2">function </span><span class="s1">invert</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= {};</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s1">result</span><span class="s3">[</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]]] = </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Return a sorted list of the function names available on the object.</span>
<span class="s2">function </span><span class="s1">functions</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">names </span><span class="s3">= [];</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">])) </span><span class="s1">names</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">key</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">names</span><span class="s3">.</span><span class="s1">sort</span><span class="s3">();</span>
<span class="s3">}</span>

<span class="s0">// An internal function for creating assigner functions.</span>
<span class="s2">function </span><span class="s1">createAssigner</span><span class="s3">(</span><span class="s1">keysFunc</span><span class="s3">, </span><span class="s1">defaults</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">defaults</span><span class="s3">) </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">length </span><span class="s3">&lt; </span><span class="s5">2 </span><span class="s3">|| </span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">1</span><span class="s3">; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
      <span class="s2">var </span><span class="s1">source </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">index</span><span class="s3">],</span>
          <span class="s1">keys </span><span class="s3">= </span><span class="s1">keysFunc</span><span class="s3">(</span><span class="s1">source</span><span class="s3">),</span>
          <span class="s1">l </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
      <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">l</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
        <span class="s2">var </span><span class="s1">key </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
        <span class="s2">if </span><span class="s3">(!</span><span class="s1">defaults </span><span class="s3">|| </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] === </span><span class="s2">void </span><span class="s5">0</span><span class="s3">) </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">source</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Extend a given object with all the properties in passed-in object(s).</span>
<span class="s2">var </span><span class="s1">extend </span><span class="s3">= </span><span class="s1">createAssigner</span><span class="s3">(</span><span class="s1">allKeys</span><span class="s3">);</span>

<span class="s0">// Assigns a given object with all the own properties in the passed-in</span>
<span class="s0">// object(s).</span>
<span class="s0">// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)</span>
<span class="s2">var </span><span class="s1">extendOwn </span><span class="s3">= </span><span class="s1">createAssigner</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">);</span>

<span class="s0">// Fill in a given object with default properties.</span>
<span class="s2">var </span><span class="s1">defaults </span><span class="s3">= </span><span class="s1">createAssigner</span><span class="s3">(</span><span class="s1">allKeys</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>

<span class="s0">// Create a naked function reference for surrogate-prototype-swapping.</span>
<span class="s2">function </span><span class="s1">ctor</span><span class="s3">() {</span>
  <span class="s2">return function</span><span class="s3">(){};</span>
<span class="s3">}</span>

<span class="s0">// An internal function for creating a new object that inherits from another.</span>
<span class="s2">function </span><span class="s1">baseCreate</span><span class="s3">(</span><span class="s1">prototype</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">isObject</span><span class="s3">(</span><span class="s1">prototype</span><span class="s3">)) </span><span class="s2">return </span><span class="s3">{};</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">nativeCreate</span><span class="s3">) </span><span class="s2">return </span><span class="s1">nativeCreate</span><span class="s3">(</span><span class="s1">prototype</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">Ctor </span><span class="s3">= </span><span class="s1">ctor</span><span class="s3">();</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">= </span><span class="s1">prototype</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Ctor</span><span class="s3">;</span>
  <span class="s1">Ctor</span><span class="s3">.</span><span class="s1">prototype </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Creates an object that inherits from the given prototype object.</span>
<span class="s0">// If additional properties are provided then they will be added to the</span>
<span class="s0">// created object.</span>
<span class="s2">function </span><span class="s1">create</span><span class="s3">(</span><span class="s1">prototype</span><span class="s3">, </span><span class="s1">props</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= </span><span class="s1">baseCreate</span><span class="s3">(</span><span class="s1">prototype</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">props</span><span class="s3">) </span><span class="s1">extendOwn</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">props</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Create a (shallow-cloned) duplicate of an object.</span>
<span class="s2">function </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">isObject</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) ? </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">() : </span><span class="s1">extend</span><span class="s3">({}, </span><span class="s1">obj</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Invokes `interceptor` with the `obj` and then returns `obj`.</span>
<span class="s0">// The primary purpose of this method is to &quot;tap into&quot; a method chain, in</span>
<span class="s0">// order to perform operations on intermediate results within the chain.</span>
<span class="s2">function </span><span class="s1">tap</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">interceptor</span><span class="s3">) {</span>
  <span class="s1">interceptor</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Normalize a (deep) property `path` to array.</span>
<span class="s0">// Like `_.iteratee`, this function can be customized.</span>
<span class="s2">function </span><span class="s1">toPath</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) ? </span><span class="s1">path </span><span class="s3">: [</span><span class="s1">path</span><span class="s3">];</span>
<span class="s3">}</span>
<span class="s1">_</span><span class="s3">.</span><span class="s1">toPath </span><span class="s3">= </span><span class="s1">toPath</span><span class="s3">;</span>

<span class="s0">// Internal wrapper for `_.toPath` to enable minification.</span>
<span class="s0">// Similar to `cb` for `_.iteratee`.</span>
<span class="s2">function </span><span class="s1">toPath$1</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">_</span><span class="s3">.</span><span class="s1">toPath</span><span class="s3">(</span><span class="s1">path</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Internal function to obtain a nested property in `obj` along `path`.</span>
<span class="s2">function </span><span class="s1">deepGet</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">path</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">path</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return void </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">path</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]];</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">length </span><span class="s3">? </span><span class="s1">obj </span><span class="s3">: </span><span class="s2">void </span><span class="s5">0</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Get the value of the (deep) property on `path` from `object`.</span>
<span class="s0">// If any property in `path` does not exist or if the value is</span>
<span class="s0">// `undefined`, return `defaultValue` instead.</span>
<span class="s0">// The `path` is normalized through `_.toPath`.</span>
<span class="s2">function </span><span class="s1">get</span><span class="s3">(</span><span class="s1">object</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">defaultValue</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">value </span><span class="s3">= </span><span class="s1">deepGet</span><span class="s3">(</span><span class="s1">object</span><span class="s3">, </span><span class="s1">toPath$1</span><span class="s3">(</span><span class="s1">path</span><span class="s3">));</span>
  <span class="s2">return </span><span class="s1">isUndefined</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) ? </span><span class="s1">defaultValue </span><span class="s3">: </span><span class="s1">value</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Shortcut function for checking if an object has a given property directly on</span>
<span class="s0">// itself (in other words, not on a prototype). Unlike the internal `has`</span>
<span class="s0">// function, this public version can also traverse nested properties.</span>
<span class="s2">function </span><span class="s1">has$1</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">path</span><span class="s3">) {</span>
  <span class="s1">path </span><span class="s3">= </span><span class="s1">toPath$1</span><span class="s3">(</span><span class="s1">path</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">path</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">key </span><span class="s3">= </span><span class="s1">path</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">has</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
    <span class="s1">obj </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s3">!!</span><span class="s1">length</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Keep the identity function around for default iteratees.</span>
<span class="s2">function </span><span class="s1">identity</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">value</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Returns a predicate for checking whether an object has a given set of</span>
<span class="s0">// `key:value` pairs.</span>
<span class="s2">function </span><span class="s1">matcher</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">) {</span>
  <span class="s1">attrs </span><span class="s3">= </span><span class="s1">extendOwn</span><span class="s3">({}, </span><span class="s1">attrs</span><span class="s3">);</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">isMatch</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Creates a function that, when passed an object, will traverse that object’s</span>
<span class="s0">// properties down the given `path`, specified as an array of keys or indices.</span>
<span class="s2">function </span><span class="s1">property</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) {</span>
  <span class="s1">path </span><span class="s3">= </span><span class="s1">toPath$1</span><span class="s3">(</span><span class="s1">path</span><span class="s3">);</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">deepGet</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">path</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Internal function that returns an efficient (for current engines) version</span>
<span class="s0">// of the passed-in callback, to be repeatedly applied in other Underscore</span>
<span class="s0">// functions.</span>
<span class="s2">function </span><span class="s1">optimizeCb</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">argCount</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">context </span><span class="s3">=== </span><span class="s2">void </span><span class="s5">0</span><span class="s3">) </span><span class="s2">return </span><span class="s1">func</span><span class="s3">;</span>
  <span class="s2">switch </span><span class="s3">(</span><span class="s1">argCount </span><span class="s3">== </span><span class="s2">null </span><span class="s3">? </span><span class="s5">3 </span><span class="s3">: </span><span class="s1">argCount</span><span class="s3">) {</span>
    <span class="s2">case </span><span class="s5">1</span><span class="s3">: </span><span class="s2">return function</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) {</span>
      <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">value</span><span class="s3">);</span>
    <span class="s3">};</span>
    <span class="s0">// The 2-argument case is omitted because we’re not using it.</span>
    <span class="s2">case </span><span class="s5">3</span><span class="s3">: </span><span class="s2">return function</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">collection</span><span class="s3">) {</span>
      <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">collection</span><span class="s3">);</span>
    <span class="s3">};</span>
    <span class="s2">case </span><span class="s5">4</span><span class="s3">: </span><span class="s2">return function</span><span class="s3">(</span><span class="s1">accumulator</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">collection</span><span class="s3">) {</span>
      <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">accumulator</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">collection</span><span class="s3">);</span>
    <span class="s3">};</span>
  <span class="s3">}</span>
  <span class="s2">return function</span><span class="s3">() {</span>
    <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// An internal function to generate callbacks that can be applied to each</span>
<span class="s0">// element in a collection, returning the desired result — either `_.identity`,</span>
<span class="s0">// an arbitrary callback, a property matcher, or a property accessor.</span>
<span class="s2">function </span><span class="s1">baseIteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">argCount</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return </span><span class="s1">identity</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">optimizeCb</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">argCount</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isObject</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) &amp;&amp; !</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">value</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">matcher</span><span class="s3">(</span><span class="s1">value</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">property</span><span class="s3">(</span><span class="s1">value</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// External wrapper for our callback generator. Users may customize</span>
<span class="s0">// `_.iteratee` if they want additional predicate/iteratee shorthand styles.</span>
<span class="s0">// This abstraction hides the internal-only `argCount` argument.</span>
<span class="s2">function </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">baseIteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">Infinity</span><span class="s3">);</span>
<span class="s3">}</span>
<span class="s1">_</span><span class="s3">.</span><span class="s1">iteratee </span><span class="s3">= </span><span class="s1">iteratee</span><span class="s3">;</span>

<span class="s0">// The function we call internally to generate a callback. It invokes</span>
<span class="s0">// `_.iteratee` if overridden, otherwise `baseIteratee`.</span>
<span class="s2">function </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">argCount</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">_</span><span class="s3">.</span><span class="s1">iteratee </span><span class="s3">!== </span><span class="s1">iteratee</span><span class="s3">) </span><span class="s2">return </span><span class="s1">_</span><span class="s3">.</span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">baseIteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">argCount</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Returns the results of applying the `iteratee` to each element of `obj`.</span>
<span class="s0">// In contrast to `_.map` it returns an object.</span>
<span class="s2">function </span><span class="s1">mapObject</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">),</span>
      <span class="s1">length </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">,</span>
      <span class="s1">results </span><span class="s3">= {};</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">currentKey </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">index</span><span class="s3">];</span>
    <span class="s1">results</span><span class="s3">[</span><span class="s1">currentKey</span><span class="s3">] = </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">currentKey</span><span class="s3">], </span><span class="s1">currentKey</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">results</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Predicate-generating function. Often useful outside of Underscore.</span>
<span class="s2">function </span><span class="s1">noop</span><span class="s3">(){}</span>

<span class="s0">// Generates a function for a given object that returns a given property.</span>
<span class="s2">function </span><span class="s1">propertyOf</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return </span><span class="s1">noop</span><span class="s3">;</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">path</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">get</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">path</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Run a function **n** times.</span>
<span class="s2">function </span><span class="s1">times</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">accum </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">));</span>
  <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">optimizeCb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s5">1</span><span class="s3">);</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">n</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) </span><span class="s1">accum</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">i</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">accum</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Return a random integer between `min` and `max` (inclusive).</span>
<span class="s2">function </span><span class="s1">random</span><span class="s3">(</span><span class="s1">min</span><span class="s3">, </span><span class="s1">max</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">max </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s1">max </span><span class="s3">= </span><span class="s1">min</span><span class="s3">;</span>
    <span class="s1">min </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">min </span><span class="s3">+ </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">random</span><span class="s3">() * (</span><span class="s1">max </span><span class="s3">- </span><span class="s1">min </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s0">// A (possibly faster) way to get the current timestamp as an integer.</span>
<span class="s2">var </span><span class="s1">now </span><span class="s3">= </span><span class="s1">Date</span><span class="s3">.</span><span class="s1">now </span><span class="s3">|| </span><span class="s2">function</span><span class="s3">() {</span>
  <span class="s2">return new </span><span class="s1">Date</span><span class="s3">().</span><span class="s1">getTime</span><span class="s3">();</span>
<span class="s3">};</span>

<span class="s0">// Internal helper to generate functions for escaping and unescaping strings</span>
<span class="s0">// to/from HTML interpolation.</span>
<span class="s2">function </span><span class="s1">createEscaper</span><span class="s3">(</span><span class="s1">map</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">escaper </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">match</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">map</span><span class="s3">[</span><span class="s1">match</span><span class="s3">];</span>
  <span class="s3">};</span>
  <span class="s0">// Regexes for identifying a key that needs to be escaped.</span>
  <span class="s2">var </span><span class="s1">source </span><span class="s3">= </span><span class="s4">'(?:' </span><span class="s3">+ </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">map</span><span class="s3">).</span><span class="s1">join</span><span class="s3">(</span><span class="s4">'|'</span><span class="s3">) + </span><span class="s4">')'</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">testRegexp </span><span class="s3">= </span><span class="s1">RegExp</span><span class="s3">(</span><span class="s1">source</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">replaceRegexp </span><span class="s3">= </span><span class="s1">RegExp</span><span class="s3">(</span><span class="s1">source</span><span class="s3">, </span><span class="s4">'g'</span><span class="s3">);</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">string</span><span class="s3">) {</span>
    <span class="s1">string </span><span class="s3">= </span><span class="s1">string </span><span class="s3">== </span><span class="s2">null </span><span class="s3">? </span><span class="s4">'' </span><span class="s3">: </span><span class="s4">'' </span><span class="s3">+ </span><span class="s1">string</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">testRegexp</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">string</span><span class="s3">) ? </span><span class="s1">string</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">replaceRegexp</span><span class="s3">, </span><span class="s1">escaper</span><span class="s3">) : </span><span class="s1">string</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Internal list of HTML entities for escaping.</span>
<span class="s2">var </span><span class="s1">escapeMap </span><span class="s3">= {</span>
  <span class="s4">'&amp;'</span><span class="s3">: </span><span class="s4">'&amp;amp;'</span><span class="s3">,</span>
  <span class="s4">'&lt;'</span><span class="s3">: </span><span class="s4">'&amp;lt;'</span><span class="s3">,</span>
  <span class="s4">'&gt;'</span><span class="s3">: </span><span class="s4">'&amp;gt;'</span><span class="s3">,</span>
  <span class="s4">'&quot;'</span><span class="s3">: </span><span class="s4">'&amp;quot;'</span><span class="s3">,</span>
  <span class="s4">&quot;'&quot;</span><span class="s3">: </span><span class="s4">'&amp;#x27;'</span><span class="s3">,</span>
  <span class="s4">'`'</span><span class="s3">: </span><span class="s4">'&amp;#x60;'</span>
<span class="s3">};</span>

<span class="s0">// Function for escaping strings to HTML interpolation.</span>
<span class="s2">var </span><span class="s1">_escape </span><span class="s3">= </span><span class="s1">createEscaper</span><span class="s3">(</span><span class="s1">escapeMap</span><span class="s3">);</span>

<span class="s0">// Internal list of HTML entities for unescaping.</span>
<span class="s2">var </span><span class="s1">unescapeMap </span><span class="s3">= </span><span class="s1">invert</span><span class="s3">(</span><span class="s1">escapeMap</span><span class="s3">);</span>

<span class="s0">// Function for unescaping strings from HTML interpolation.</span>
<span class="s2">var </span><span class="s1">_unescape </span><span class="s3">= </span><span class="s1">createEscaper</span><span class="s3">(</span><span class="s1">unescapeMap</span><span class="s3">);</span>

<span class="s0">// By default, Underscore uses ERB-style template delimiters. Change the</span>
<span class="s0">// following template settings to use alternative delimiters.</span>
<span class="s2">var </span><span class="s1">templateSettings </span><span class="s3">= </span><span class="s1">_</span><span class="s3">.</span><span class="s1">templateSettings </span><span class="s3">= {</span>
  <span class="s1">evaluate</span><span class="s3">: </span><span class="s6">/&lt;%([\s\S]+?)%&gt;/g</span><span class="s3">,</span>
  <span class="s1">interpolate</span><span class="s3">: </span><span class="s6">/&lt;%=([\s\S]+?)%&gt;/g</span><span class="s3">,</span>
  <span class="s1">escape</span><span class="s3">: </span><span class="s6">/&lt;%-([\s\S]+?)%&gt;/g</span>
<span class="s3">};</span>

<span class="s0">// When customizing `_.templateSettings`, if you don't want to define an</span>
<span class="s0">// interpolation, evaluation or escaping regex, we need one that is</span>
<span class="s0">// guaranteed not to match.</span>
<span class="s2">var </span><span class="s1">noMatch </span><span class="s3">= </span><span class="s6">/(.)^/</span><span class="s3">;</span>

<span class="s0">// Certain characters need to be escaped so that they can be put into a</span>
<span class="s0">// string literal.</span>
<span class="s2">var </span><span class="s1">escapes </span><span class="s3">= {</span>
  <span class="s4">&quot;'&quot;</span><span class="s3">: </span><span class="s4">&quot;'&quot;</span><span class="s3">,</span>
  <span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s3">: </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">'</span><span class="s3">,</span>
  <span class="s4">'</span><span class="s2">\r</span><span class="s4">'</span><span class="s3">: </span><span class="s4">'r'</span><span class="s3">,</span>
  <span class="s4">'</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">: </span><span class="s4">'n'</span><span class="s3">,</span>
  <span class="s4">'</span><span class="s2">\u2028</span><span class="s4">'</span><span class="s3">: </span><span class="s4">'u2028'</span><span class="s3">,</span>
  <span class="s4">'</span><span class="s2">\u2029</span><span class="s4">'</span><span class="s3">: </span><span class="s4">'u2029'</span>
<span class="s3">};</span>

<span class="s2">var </span><span class="s1">escapeRegExp </span><span class="s3">= </span><span class="s6">/\\|'|\r|\n|\u2028|\u2029/g</span><span class="s3">;</span>

<span class="s2">function </span><span class="s1">escapeChar</span><span class="s3">(</span><span class="s1">match</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s4">'</span><span class="s2">\\</span><span class="s4">' </span><span class="s3">+ </span><span class="s1">escapes</span><span class="s3">[</span><span class="s1">match</span><span class="s3">];</span>
<span class="s3">}</span>

<span class="s2">var </span><span class="s1">bareIdentifier </span><span class="s3">= </span><span class="s6">/^\s*(\w|\$)+\s*$/</span><span class="s3">;</span>

<span class="s0">// JavaScript micro-templating, similar to John Resig's implementation.</span>
<span class="s0">// Underscore templating handles arbitrary delimiters, preserves whitespace,</span>
<span class="s0">// and correctly escapes quotes within interpolated code.</span>
<span class="s0">// NB: `oldSettings` only exists for backwards compatibility.</span>
<span class="s2">function </span><span class="s1">template</span><span class="s3">(</span><span class="s1">text</span><span class="s3">, </span><span class="s1">settings</span><span class="s3">, </span><span class="s1">oldSettings</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">settings </span><span class="s3">&amp;&amp; </span><span class="s1">oldSettings</span><span class="s3">) </span><span class="s1">settings </span><span class="s3">= </span><span class="s1">oldSettings</span><span class="s3">;</span>
  <span class="s1">settings </span><span class="s3">= </span><span class="s1">defaults</span><span class="s3">({}, </span><span class="s1">settings</span><span class="s3">, </span><span class="s1">_</span><span class="s3">.</span><span class="s1">templateSettings</span><span class="s3">);</span>

  <span class="s0">// Combine delimiters into one regular expression via alternation.</span>
  <span class="s2">var </span><span class="s1">matcher </span><span class="s3">= </span><span class="s1">RegExp</span><span class="s3">([</span>
    <span class="s3">(</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">escape </span><span class="s3">|| </span><span class="s1">noMatch</span><span class="s3">).</span><span class="s1">source</span><span class="s3">,</span>
    <span class="s3">(</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">interpolate </span><span class="s3">|| </span><span class="s1">noMatch</span><span class="s3">).</span><span class="s1">source</span><span class="s3">,</span>
    <span class="s3">(</span><span class="s1">settings</span><span class="s3">.</span><span class="s1">evaluate </span><span class="s3">|| </span><span class="s1">noMatch</span><span class="s3">).</span><span class="s1">source</span>
  <span class="s3">].</span><span class="s1">join</span><span class="s3">(</span><span class="s4">'|'</span><span class="s3">) + </span><span class="s4">'|$'</span><span class="s3">, </span><span class="s4">'g'</span><span class="s3">);</span>

  <span class="s0">// Compile the template source, escaping string literals appropriately.</span>
  <span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">source </span><span class="s3">= </span><span class="s4">&quot;__p+='&quot;</span><span class="s3">;</span>
  <span class="s1">text</span><span class="s3">.</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">matcher</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">match</span><span class="s3">, </span><span class="s1">escape</span><span class="s3">, </span><span class="s1">interpolate</span><span class="s3">, </span><span class="s1">evaluate</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">) {</span>
    <span class="s1">source </span><span class="s3">+= </span><span class="s1">text</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">offset</span><span class="s3">).</span><span class="s1">replace</span><span class="s3">(</span><span class="s1">escapeRegExp</span><span class="s3">, </span><span class="s1">escapeChar</span><span class="s3">);</span>
    <span class="s1">index </span><span class="s3">= </span><span class="s1">offset </span><span class="s3">+ </span><span class="s1">match</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>

    <span class="s2">if </span><span class="s3">(</span><span class="s1">escape</span><span class="s3">) {</span>
      <span class="s1">source </span><span class="s3">+= </span><span class="s4">&quot;'+</span><span class="s2">\n</span><span class="s4">((__t=(&quot; </span><span class="s3">+ </span><span class="s1">escape </span><span class="s3">+ </span><span class="s4">&quot;))==null?'':_.escape(__t))+</span><span class="s2">\n</span><span class="s4">'&quot;</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">interpolate</span><span class="s3">) {</span>
      <span class="s1">source </span><span class="s3">+= </span><span class="s4">&quot;'+</span><span class="s2">\n</span><span class="s4">((__t=(&quot; </span><span class="s3">+ </span><span class="s1">interpolate </span><span class="s3">+ </span><span class="s4">&quot;))==null?'':__t)+</span><span class="s2">\n</span><span class="s4">'&quot;</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">evaluate</span><span class="s3">) {</span>
      <span class="s1">source </span><span class="s3">+= </span><span class="s4">&quot;';</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s3">+ </span><span class="s1">evaluate </span><span class="s3">+ </span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">__p+='&quot;</span><span class="s3">;</span>
    <span class="s3">}</span>

    <span class="s0">// Adobe VMs need the match returned to produce the correct offset.</span>
    <span class="s2">return </span><span class="s1">match</span><span class="s3">;</span>
  <span class="s3">});</span>
  <span class="s1">source </span><span class="s3">+= </span><span class="s4">&quot;';</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s3">;</span>

  <span class="s2">var </span><span class="s1">argument </span><span class="s3">= </span><span class="s1">settings</span><span class="s3">.</span><span class="s1">variable</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">argument</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">bareIdentifier</span><span class="s3">.</span><span class="s1">test</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">)) </span><span class="s2">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s0">// If a variable is not specified, place data values in local scope.</span>
    <span class="s1">source </span><span class="s3">= </span><span class="s4">'with(obj||{}){</span><span class="s2">\n</span><span class="s4">' </span><span class="s3">+ </span><span class="s1">source </span><span class="s3">+ </span><span class="s4">'}</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">;</span>
    <span class="s1">argument </span><span class="s3">= </span><span class="s4">'obj'</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s1">source </span><span class="s3">= </span><span class="s4">&quot;var __t,__p='',__j=Array.prototype.join,&quot; </span><span class="s3">+</span>
    <span class="s4">&quot;print=function(){__p+=__j.call(arguments,'');};</span><span class="s2">\n</span><span class="s4">&quot; </span><span class="s3">+</span>
    <span class="s1">source </span><span class="s3">+ </span><span class="s4">'return __p;</span><span class="s2">\n</span><span class="s4">'</span><span class="s3">;</span>

  <span class="s2">var </span><span class="s1">render</span><span class="s3">;</span>
  <span class="s2">try </span><span class="s3">{</span>
    <span class="s1">render </span><span class="s3">= </span><span class="s2">new </span><span class="s1">Function</span><span class="s3">(</span><span class="s1">argument</span><span class="s3">, </span><span class="s4">'_'</span><span class="s3">, </span><span class="s1">source</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">catch </span><span class="s3">(</span><span class="s1">e</span><span class="s3">) {</span>
    <span class="s1">e</span><span class="s3">.</span><span class="s1">source </span><span class="s3">= </span><span class="s1">source</span><span class="s3">;</span>
    <span class="s2">throw </span><span class="s1">e</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">var </span><span class="s1">template </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">data</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">render</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">_</span><span class="s3">);</span>
  <span class="s3">};</span>

  <span class="s0">// Provide the compiled source as a convenience for precompilation.</span>
  <span class="s1">template</span><span class="s3">.</span><span class="s1">source </span><span class="s3">= </span><span class="s4">'function(' </span><span class="s3">+ </span><span class="s1">argument </span><span class="s3">+ </span><span class="s4">'){</span><span class="s2">\n</span><span class="s4">' </span><span class="s3">+ </span><span class="s1">source </span><span class="s3">+ </span><span class="s4">'}'</span><span class="s3">;</span>

  <span class="s2">return </span><span class="s1">template</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Traverses the children of `obj` along `path`. If a child is a function, it</span>
<span class="s0">// is invoked with its parent as context. Returns the value of the final</span>
<span class="s0">// child, or `fallback` if any child is undefined.</span>
<span class="s2">function </span><span class="s1">result</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">fallback</span><span class="s3">) {</span>
  <span class="s1">path </span><span class="s3">= </span><span class="s1">toPath$1</span><span class="s3">(</span><span class="s1">path</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">path</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">length</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">fallback</span><span class="s3">) ? </span><span class="s1">fallback</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) : </span><span class="s1">fallback</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">prop </span><span class="s3">= </span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null </span><span class="s3">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s3">: </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">path</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">prop </span><span class="s3">=== </span><span class="s2">void </span><span class="s5">0</span><span class="s3">) {</span>
      <span class="s1">prop </span><span class="s3">= </span><span class="s1">fallback</span><span class="s3">;</span>
      <span class="s1">i </span><span class="s3">= </span><span class="s1">length</span><span class="s3">; </span><span class="s0">// Ensure we don't continue iterating.</span>
    <span class="s3">}</span>
    <span class="s1">obj </span><span class="s3">= </span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">prop</span><span class="s3">) ? </span><span class="s1">prop</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) : </span><span class="s1">prop</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Generate a unique integer id (unique within the entire client session).</span>
<span class="s0">// Useful for temporary DOM ids.</span>
<span class="s2">var </span><span class="s1">idCounter </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
<span class="s2">function </span><span class="s1">uniqueId</span><span class="s3">(</span><span class="s1">prefix</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">id </span><span class="s3">= ++</span><span class="s1">idCounter </span><span class="s3">+ </span><span class="s4">''</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">prefix </span><span class="s3">? </span><span class="s1">prefix </span><span class="s3">+ </span><span class="s1">id </span><span class="s3">: </span><span class="s1">id</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Start chaining a wrapped Underscore object.</span>
<span class="s2">function </span><span class="s1">chain</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">instance </span><span class="s3">= </span><span class="s1">_</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s1">instance</span><span class="s3">.</span><span class="s1">_chain </span><span class="s3">= </span><span class="s2">true</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">instance</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Internal function to execute `sourceFunc` bound to `context` with optional</span>
<span class="s0">// `args`. Determines whether to execute a function as a constructor or as a</span>
<span class="s0">// normal function.</span>
<span class="s2">function </span><span class="s1">executeBound</span><span class="s3">(</span><span class="s1">sourceFunc</span><span class="s3">, </span><span class="s1">boundFunc</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">callingContext</span><span class="s3">, </span><span class="s1">args</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!(</span><span class="s1">callingContext </span><span class="s2">instanceof </span><span class="s1">boundFunc</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">sourceFunc</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">self </span><span class="s3">= </span><span class="s1">baseCreate</span><span class="s3">(</span><span class="s1">sourceFunc</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= </span><span class="s1">sourceFunc</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">self</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isObject</span><span class="s3">(</span><span class="s1">result</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">self</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Partially apply a function by creating a version that has had some of its</span>
<span class="s0">// arguments pre-filled, without changing its dynamic `this` context. `_` acts</span>
<span class="s0">// as a placeholder by default, allowing any combination of arguments to be</span>
<span class="s0">// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.</span>
<span class="s2">var </span><span class="s1">partial </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">boundArgs</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">placeholder </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">.</span><span class="s1">placeholder</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">bound </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">var </span><span class="s1">position </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">boundArgs</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">args </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">length</span><span class="s3">);</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
      <span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] = </span><span class="s1">boundArgs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] === </span><span class="s1">placeholder </span><span class="s3">? </span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">position</span><span class="s3">++] : </span><span class="s1">boundArgs</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s3">}</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">position </span><span class="s3">&lt; </span><span class="s1">arguments</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) </span><span class="s1">args</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">position</span><span class="s3">++]);</span>
    <span class="s2">return </span><span class="s1">executeBound</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">, </span><span class="s2">this</span><span class="s3">, </span><span class="s2">this</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
  <span class="s3">};</span>
  <span class="s2">return </span><span class="s1">bound</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s1">partial</span><span class="s3">.</span><span class="s1">placeholder </span><span class="s3">= </span><span class="s1">_</span><span class="s3">;</span>

<span class="s0">// Create a function bound to a given object (assigning `this`, and arguments,</span>
<span class="s0">// optionally).</span>
<span class="s2">var </span><span class="s1">bind </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">args</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">func</span><span class="s3">)) </span><span class="s2">throw new </span><span class="s1">TypeError</span><span class="s3">(</span><span class="s4">'Bind must be called on a function'</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">bound </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">callArgs</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">executeBound</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">bound</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s2">this</span><span class="s3">, </span><span class="s1">args</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">callArgs</span><span class="s3">));</span>
  <span class="s3">});</span>
  <span class="s2">return </span><span class="s1">bound</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s0">// Internal helper for collection methods to determine whether a collection</span>
<span class="s0">// should be iterated as an array or as an object.</span>
<span class="s0">// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength</span>
<span class="s0">// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094</span>
<span class="s2">var </span><span class="s1">isArrayLike </span><span class="s3">= </span><span class="s1">createSizePropertyCheck</span><span class="s3">(</span><span class="s1">getLength</span><span class="s3">);</span>

<span class="s0">// Internal implementation of a recursive `flatten` function.</span>
<span class="s2">function </span><span class="s1">flatten</span><span class="s3">(</span><span class="s1">input</span><span class="s3">, </span><span class="s1">depth</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">, </span><span class="s1">output</span><span class="s3">) {</span>
  <span class="s1">output </span><span class="s3">= </span><span class="s1">output </span><span class="s3">|| [];</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">depth </span><span class="s3">&amp;&amp; </span><span class="s1">depth </span><span class="s3">!== </span><span class="s5">0</span><span class="s3">) {</span>
    <span class="s1">depth </span><span class="s3">= </span><span class="s1">Infinity</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">depth </span><span class="s3">&lt;= </span><span class="s5">0</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s1">output</span><span class="s3">.</span><span class="s1">concat</span><span class="s3">(</span><span class="s1">input</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">var </span><span class="s1">idx </span><span class="s3">= </span><span class="s1">output</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">input</span><span class="s3">); </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">value </span><span class="s3">= </span><span class="s1">input</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) &amp;&amp; (</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">value</span><span class="s3">) || </span><span class="s1">isArguments$1</span><span class="s3">(</span><span class="s1">value</span><span class="s3">))) {</span>
      <span class="s0">// Flatten current level of array or arguments object.</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">depth </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">) {</span>
        <span class="s1">flatten</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">depth </span><span class="s3">- </span><span class="s5">1</span><span class="s3">, </span><span class="s1">strict</span><span class="s3">, </span><span class="s1">output</span><span class="s3">);</span>
        <span class="s1">idx </span><span class="s3">= </span><span class="s1">output</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s2">var </span><span class="s1">j </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">len </span><span class="s3">= </span><span class="s1">value</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
        <span class="s2">while </span><span class="s3">(</span><span class="s1">j </span><span class="s3">&lt; </span><span class="s1">len</span><span class="s3">) </span><span class="s1">output</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">++] = </span><span class="s1">value</span><span class="s3">[</span><span class="s1">j</span><span class="s3">++];</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(!</span><span class="s1">strict</span><span class="s3">) {</span>
      <span class="s1">output</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">++] = </span><span class="s1">value</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">output</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Bind a number of an object's methods to that object. Remaining arguments</span>
<span class="s0">// are the method names to be bound. Useful for ensuring that all callbacks</span>
<span class="s0">// defined on an object belong to it.</span>
<span class="s2">var </span><span class="s1">bindAll </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">) {</span>
  <span class="s1">keys </span><span class="s3">= </span><span class="s1">flatten</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s2">false</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">index </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">) </span><span class="s2">throw new </span><span class="s1">Error</span><span class="s3">(</span><span class="s4">'bindAll must be passed function names'</span><span class="s3">);</span>
  <span class="s2">while </span><span class="s3">(</span><span class="s1">index</span><span class="s3">--) {</span>
    <span class="s2">var </span><span class="s1">key </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">[</span><span class="s1">index</span><span class="s3">];</span>
    <span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">bind</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s0">// Memoize an expensive function by storing its results.</span>
<span class="s2">function </span><span class="s1">memoize</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">hasher</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">memoize </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">key</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">cache </span><span class="s3">= </span><span class="s1">memoize</span><span class="s3">.</span><span class="s1">cache</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">address </span><span class="s3">= </span><span class="s4">'' </span><span class="s3">+ (</span><span class="s1">hasher </span><span class="s3">? </span><span class="s1">hasher</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">) : </span><span class="s1">key</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">has</span><span class="s3">(</span><span class="s1">cache</span><span class="s3">, </span><span class="s1">address</span><span class="s3">)) </span><span class="s1">cache</span><span class="s3">[</span><span class="s1">address</span><span class="s3">] = </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
    <span class="s2">return </span><span class="s1">cache</span><span class="s3">[</span><span class="s1">address</span><span class="s3">];</span>
  <span class="s3">};</span>
  <span class="s1">memoize</span><span class="s3">.</span><span class="s1">cache </span><span class="s3">= {};</span>
  <span class="s2">return </span><span class="s1">memoize</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Delays a function for the given number of milliseconds, and then calls</span>
<span class="s0">// it with the arguments supplied.</span>
<span class="s2">var </span><span class="s1">delay </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">wait</span><span class="s3">, </span><span class="s1">args</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">setTimeout</span><span class="s3">(</span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s2">null</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
  <span class="s3">}, </span><span class="s1">wait</span><span class="s3">);</span>
<span class="s3">});</span>

<span class="s0">// Defers a function, scheduling it to run after the current call stack has</span>
<span class="s0">// cleared.</span>
<span class="s2">var </span><span class="s1">defer </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">delay</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s5">1</span><span class="s3">);</span>

<span class="s0">// Returns a function, that, when invoked, will only be triggered at most once</span>
<span class="s0">// during a given window of time. Normally, the throttled function will run</span>
<span class="s0">// as much as it can, without ever going more than once per `wait` duration;</span>
<span class="s0">// but if you'd like to disable the execution on the leading edge, pass</span>
<span class="s0">// `{leading: false}`. To disable execution on the trailing edge, ditto.</span>
<span class="s2">function </span><span class="s1">throttle</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">wait</span><span class="s3">, </span><span class="s1">options</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">previous </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">options</span><span class="s3">) </span><span class="s1">options </span><span class="s3">= {};</span>

  <span class="s2">var </span><span class="s1">later </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s1">previous </span><span class="s3">= </span><span class="s1">options</span><span class="s3">.</span><span class="s1">leading </span><span class="s3">=== </span><span class="s2">false </span><span class="s3">? </span><span class="s5">0 </span><span class="s3">: </span><span class="s1">now</span><span class="s3">();</span>
    <span class="s1">timeout </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">timeout</span><span class="s3">) </span><span class="s1">context </span><span class="s3">= </span><span class="s1">args </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
  <span class="s3">};</span>

  <span class="s2">var </span><span class="s1">throttled </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">var </span><span class="s1">_now </span><span class="s3">= </span><span class="s1">now</span><span class="s3">();</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">previous </span><span class="s3">&amp;&amp; </span><span class="s1">options</span><span class="s3">.</span><span class="s1">leading </span><span class="s3">=== </span><span class="s2">false</span><span class="s3">) </span><span class="s1">previous </span><span class="s3">= </span><span class="s1">_now</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">remaining </span><span class="s3">= </span><span class="s1">wait </span><span class="s3">- (</span><span class="s1">_now </span><span class="s3">- </span><span class="s1">previous</span><span class="s3">);</span>
    <span class="s1">context </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s1">args </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">remaining </span><span class="s3">&lt;= </span><span class="s5">0 </span><span class="s3">|| </span><span class="s1">remaining </span><span class="s3">&gt; </span><span class="s1">wait</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">) {</span>
        <span class="s1">clearTimeout</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">);</span>
        <span class="s1">timeout </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
      <span class="s3">}</span>
      <span class="s1">previous </span><span class="s3">= </span><span class="s1">_now</span><span class="s3">;</span>
      <span class="s1">result </span><span class="s3">= </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">timeout</span><span class="s3">) </span><span class="s1">context </span><span class="s3">= </span><span class="s1">args </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(!</span><span class="s1">timeout </span><span class="s3">&amp;&amp; </span><span class="s1">options</span><span class="s3">.</span><span class="s1">trailing </span><span class="s3">!== </span><span class="s2">false</span><span class="s3">) {</span>
      <span class="s1">timeout </span><span class="s3">= </span><span class="s1">setTimeout</span><span class="s3">(</span><span class="s1">later</span><span class="s3">, </span><span class="s1">remaining</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
  <span class="s3">};</span>

  <span class="s1">throttled</span><span class="s3">.</span><span class="s1">cancel </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s1">clearTimeout</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">);</span>
    <span class="s1">previous </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">timeout </span><span class="s3">= </span><span class="s1">context </span><span class="s3">= </span><span class="s1">args </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
  <span class="s3">};</span>

  <span class="s2">return </span><span class="s1">throttled</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// When a sequence of calls of the returned function ends, the argument</span>
<span class="s0">// function is triggered. The end of a sequence is defined by the `wait`</span>
<span class="s0">// parameter. If `immediate` is passed, the argument function will be</span>
<span class="s0">// triggered at the beginning of the sequence instead of at the end.</span>
<span class="s2">function </span><span class="s1">debounce</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">wait</span><span class="s3">, </span><span class="s1">immediate</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">timeout</span><span class="s3">, </span><span class="s1">previous</span><span class="s3">, </span><span class="s1">args</span><span class="s3">, </span><span class="s1">result</span><span class="s3">, </span><span class="s1">context</span><span class="s3">;</span>

  <span class="s2">var </span><span class="s1">later </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">var </span><span class="s1">passed </span><span class="s3">= </span><span class="s1">now</span><span class="s3">() - </span><span class="s1">previous</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">wait </span><span class="s3">&gt; </span><span class="s1">passed</span><span class="s3">) {</span>
      <span class="s1">timeout </span><span class="s3">= </span><span class="s1">setTimeout</span><span class="s3">(</span><span class="s1">later</span><span class="s3">, </span><span class="s1">wait </span><span class="s3">- </span><span class="s1">passed</span><span class="s3">);</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">timeout </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">immediate</span><span class="s3">) </span><span class="s1">result </span><span class="s3">= </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
      <span class="s0">// This check is needed because `func` can recursively invoke `debounced`.</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">timeout</span><span class="s3">) </span><span class="s1">args </span><span class="s3">= </span><span class="s1">context </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
    <span class="s3">}</span>
  <span class="s3">};</span>

  <span class="s2">var </span><span class="s1">debounced </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">_args</span><span class="s3">) {</span>
    <span class="s1">context </span><span class="s3">= </span><span class="s2">this</span><span class="s3">;</span>
    <span class="s1">args </span><span class="s3">= </span><span class="s1">_args</span><span class="s3">;</span>
    <span class="s1">previous </span><span class="s3">= </span><span class="s1">now</span><span class="s3">();</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">timeout</span><span class="s3">) {</span>
      <span class="s1">timeout </span><span class="s3">= </span><span class="s1">setTimeout</span><span class="s3">(</span><span class="s1">later</span><span class="s3">, </span><span class="s1">wait</span><span class="s3">);</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">immediate</span><span class="s3">) </span><span class="s1">result </span><span class="s3">= </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
  <span class="s3">});</span>

  <span class="s1">debounced</span><span class="s3">.</span><span class="s1">cancel </span><span class="s3">= </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s1">clearTimeout</span><span class="s3">(</span><span class="s1">timeout</span><span class="s3">);</span>
    <span class="s1">timeout </span><span class="s3">= </span><span class="s1">args </span><span class="s3">= </span><span class="s1">context </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
  <span class="s3">};</span>

  <span class="s2">return </span><span class="s1">debounced</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Returns the first function passed as an argument to the second,</span>
<span class="s0">// allowing you to adjust arguments, run code before and after, and</span>
<span class="s0">// conditionally execute the original function.</span>
<span class="s2">function </span><span class="s1">wrap</span><span class="s3">(</span><span class="s1">func</span><span class="s3">, </span><span class="s1">wrapper</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">wrapper</span><span class="s3">, </span><span class="s1">func</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Returns a negated version of the passed-in predicate.</span>
<span class="s2">function </span><span class="s1">negate</span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">() {</span>
    <span class="s2">return </span><span class="s3">!</span><span class="s1">predicate</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Returns a function that is the composition of a list of functions, each</span>
<span class="s0">// consuming the return value of the function that follows.</span>
<span class="s2">function </span><span class="s1">compose</span><span class="s3">() {</span>
  <span class="s2">var </span><span class="s1">args </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">start </span><span class="s3">= </span><span class="s1">args</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">;</span>
  <span class="s2">return function</span><span class="s3">() {</span>
    <span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s1">start</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">result </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s1">start</span><span class="s3">].</span><span class="s1">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
    <span class="s2">while </span><span class="s3">(</span><span class="s1">i</span><span class="s3">--) </span><span class="s1">result </span><span class="s3">= </span><span class="s1">args</span><span class="s3">[</span><span class="s1">i</span><span class="s3">].</span><span class="s1">call</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">result</span><span class="s3">);</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Returns a function that will only be executed on and after the Nth call.</span>
<span class="s2">function </span><span class="s1">after</span><span class="s3">(</span><span class="s1">times</span><span class="s3">, </span><span class="s1">func</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">() {</span>
    <span class="s2">if </span><span class="s3">(--</span><span class="s1">times </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">) {</span>
      <span class="s2">return </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Returns a function that will only be executed up to (but not including) the</span>
<span class="s0">// Nth call.</span>
<span class="s2">function </span><span class="s1">before</span><span class="s3">(</span><span class="s1">times</span><span class="s3">, </span><span class="s1">func</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">memo</span><span class="s3">;</span>
  <span class="s2">return function</span><span class="s3">() {</span>
    <span class="s2">if </span><span class="s3">(--</span><span class="s1">times </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">) {</span>
      <span class="s1">memo </span><span class="s3">= </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">times </span><span class="s3">&lt;= </span><span class="s5">1</span><span class="s3">) </span><span class="s1">func </span><span class="s3">= </span><span class="s2">null</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">memo</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Returns a function that will be executed at most one time, no matter how</span>
<span class="s0">// often you call it. Useful for lazy initialization.</span>
<span class="s2">var </span><span class="s1">once </span><span class="s3">= </span><span class="s1">partial</span><span class="s3">(</span><span class="s1">before</span><span class="s3">, </span><span class="s5">2</span><span class="s3">);</span>

<span class="s0">// Returns the first key on an object that passes a truth test.</span>
<span class="s2">function </span><span class="s1">findKey</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s1">predicate </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">), </span><span class="s1">key</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s1">key </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">], </span><span class="s1">key</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">key</span><span class="s3">;</span>
  <span class="s3">}</span>
<span class="s3">}</span>

<span class="s0">// Internal function to generate `_.findIndex` and `_.findLastIndex`.</span>
<span class="s2">function </span><span class="s1">createPredicateIndexFinder</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
    <span class="s1">predicate </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
    <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">array</span><span class="s3">);</span>
    <span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s1">dir </span><span class="s3">&gt; </span><span class="s5">0 </span><span class="s3">? </span><span class="s5">0 </span><span class="s3">: </span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">;</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">index </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index </span><span class="s3">+= </span><span class="s1">dir</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">(</span><span class="s1">array</span><span class="s3">[</span><span class="s1">index</span><span class="s3">], </span><span class="s1">index</span><span class="s3">, </span><span class="s1">array</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">index</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s3">-</span><span class="s5">1</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Returns the first index on an array-like that passes a truth test.</span>
<span class="s2">var </span><span class="s1">findIndex </span><span class="s3">= </span><span class="s1">createPredicateIndexFinder</span><span class="s3">(</span><span class="s5">1</span><span class="s3">);</span>

<span class="s0">// Returns the last index on an array-like that passes a truth test.</span>
<span class="s2">var </span><span class="s1">findLastIndex </span><span class="s3">= </span><span class="s1">createPredicateIndexFinder</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">);</span>

<span class="s0">// Use a comparator function to figure out the smallest index at which</span>
<span class="s0">// an object should be inserted so as to maintain order. Uses binary search.</span>
<span class="s2">function </span><span class="s1">sortedIndex</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s5">1</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">value </span><span class="s3">= </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">low </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">high </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">array</span><span class="s3">);</span>
  <span class="s2">while </span><span class="s3">(</span><span class="s1">low </span><span class="s3">&lt; </span><span class="s1">high</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">mid </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">floor</span><span class="s3">((</span><span class="s1">low </span><span class="s3">+ </span><span class="s1">high</span><span class="s3">) / </span><span class="s5">2</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">array</span><span class="s3">[</span><span class="s1">mid</span><span class="s3">]) &lt; </span><span class="s1">value</span><span class="s3">) </span><span class="s1">low </span><span class="s3">= </span><span class="s1">mid </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">; </span><span class="s2">else </span><span class="s1">high </span><span class="s3">= </span><span class="s1">mid</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">low</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.</span>
<span class="s2">function </span><span class="s1">createIndexFinder</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">, </span><span class="s1">predicateFind</span><span class="s3">, </span><span class="s1">sortedIndex</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">item</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">array</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s2">typeof </span><span class="s1">idx </span><span class="s3">== </span><span class="s4">'number'</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">dir </span><span class="s3">&gt; </span><span class="s5">0</span><span class="s3">) {</span>
        <span class="s1">i </span><span class="s3">= </span><span class="s1">idx </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s3">? </span><span class="s1">idx </span><span class="s3">: </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">idx </span><span class="s3">+ </span><span class="s1">length</span><span class="s3">, </span><span class="s1">i</span><span class="s3">);</span>
      <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
        <span class="s1">length </span><span class="s3">= </span><span class="s1">idx </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s3">? </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">idx </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">, </span><span class="s1">length</span><span class="s3">) : </span><span class="s1">idx </span><span class="s3">+ </span><span class="s1">length </span><span class="s3">+ </span><span class="s5">1</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">sortedIndex </span><span class="s3">&amp;&amp; </span><span class="s1">idx </span><span class="s3">&amp;&amp; </span><span class="s1">length</span><span class="s3">) {</span>
      <span class="s1">idx </span><span class="s3">= </span><span class="s1">sortedIndex</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">item</span><span class="s3">);</span>
      <span class="s2">return </span><span class="s1">array</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] === </span><span class="s1">item </span><span class="s3">? </span><span class="s1">idx </span><span class="s3">: -</span><span class="s5">1</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">item </span><span class="s3">!== </span><span class="s1">item</span><span class="s3">) {</span>
      <span class="s1">idx </span><span class="s3">= </span><span class="s1">predicateFind</span><span class="s3">(</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">length</span><span class="s3">), </span><span class="s1">isNaN$1</span><span class="s3">);</span>
      <span class="s2">return </span><span class="s1">idx </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s3">? </span><span class="s1">idx </span><span class="s3">+ </span><span class="s1">i </span><span class="s3">: -</span><span class="s5">1</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">idx </span><span class="s3">= </span><span class="s1">dir </span><span class="s3">&gt; </span><span class="s5">0 </span><span class="s3">? </span><span class="s1">i </span><span class="s3">: </span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">; </span><span class="s1">idx </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">idx </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">idx </span><span class="s3">+= </span><span class="s1">dir</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">array</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] === </span><span class="s1">item</span><span class="s3">) </span><span class="s2">return </span><span class="s1">idx</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s3">-</span><span class="s5">1</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Return the position of the first occurrence of an item in an array,</span>
<span class="s0">// or -1 if the item is not included in the array.</span>
<span class="s0">// If the array is large and already in sort order, pass `true`</span>
<span class="s0">// for **isSorted** to use binary search.</span>
<span class="s2">var </span><span class="s1">indexOf </span><span class="s3">= </span><span class="s1">createIndexFinder</span><span class="s3">(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">findIndex</span><span class="s3">, </span><span class="s1">sortedIndex</span><span class="s3">);</span>

<span class="s0">// Return the position of the last occurrence of an item in an array,</span>
<span class="s0">// or -1 if the item is not included in the array.</span>
<span class="s2">var </span><span class="s1">lastIndexOf </span><span class="s3">= </span><span class="s1">createIndexFinder</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">findLastIndex</span><span class="s3">);</span>

<span class="s0">// Return the first value which passes a truth test.</span>
<span class="s2">function </span><span class="s1">find</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">keyFinder </span><span class="s3">= </span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) ? </span><span class="s1">findIndex </span><span class="s3">: </span><span class="s1">findKey</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">key </span><span class="s3">= </span><span class="s1">keyFinder</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">key </span><span class="s3">!== </span><span class="s2">void </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">key </span><span class="s3">!== -</span><span class="s5">1</span><span class="s3">) </span><span class="s2">return </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
<span class="s3">}</span>

<span class="s0">// Convenience version of a common use case of `_.find`: getting the first</span>
<span class="s0">// object containing specific `key:value` pairs.</span>
<span class="s2">function </span><span class="s1">findWhere</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">find</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">matcher</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s0">// The cornerstone for collection functions, an `each`</span>
<span class="s0">// implementation, aka `forEach`.</span>
<span class="s0">// Handles raw objects in addition to array-likes. Treats all</span>
<span class="s0">// sparse array-likes as if they were dense.</span>
<span class="s2">function </span><span class="s1">each</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">optimizeCb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">i</span><span class="s3">, </span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) {</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
      <span class="s1">iteratee</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">i</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">_keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
      <span class="s1">iteratee</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]], </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">], </span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">obj</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Return the results of applying the iteratee to each element.</span>
<span class="s2">function </span><span class="s1">map</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= !</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">),</span>
      <span class="s1">length </span><span class="s3">= (</span><span class="s1">_keys </span><span class="s3">|| </span><span class="s1">obj</span><span class="s3">).</span><span class="s1">length</span><span class="s3">,</span>
      <span class="s1">results </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">length</span><span class="s3">);</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">currentKey </span><span class="s3">= </span><span class="s1">_keys </span><span class="s3">? </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] : </span><span class="s1">index</span><span class="s3">;</span>
    <span class="s1">results</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">currentKey</span><span class="s3">], </span><span class="s1">currentKey</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">results</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Internal helper to create a reducing function, iterating left or right.</span>
<span class="s2">function </span><span class="s1">createReduce</span><span class="s3">(</span><span class="s1">dir</span><span class="s3">) {</span>
  <span class="s0">// Wrap code that reassigns argument variables in a separate function than</span>
  <span class="s0">// the one that accesses `arguments.length` to avoid a perf hit. (#1991)</span>
  <span class="s2">var </span><span class="s1">reducer </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">memo</span><span class="s3">, </span><span class="s1">initial</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= !</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">),</span>
        <span class="s1">length </span><span class="s3">= (</span><span class="s1">_keys </span><span class="s3">|| </span><span class="s1">obj</span><span class="s3">).</span><span class="s1">length</span><span class="s3">,</span>
        <span class="s1">index </span><span class="s3">= </span><span class="s1">dir </span><span class="s3">&gt; </span><span class="s5">0 </span><span class="s3">? </span><span class="s5">0 </span><span class="s3">: </span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">initial</span><span class="s3">) {</span>
      <span class="s1">memo </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">_keys </span><span class="s3">? </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] : </span><span class="s1">index</span><span class="s3">];</span>
      <span class="s1">index </span><span class="s3">+= </span><span class="s1">dir</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">for </span><span class="s3">(; </span><span class="s1">index </span><span class="s3">&gt;= </span><span class="s5">0 </span><span class="s3">&amp;&amp; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index </span><span class="s3">+= </span><span class="s1">dir</span><span class="s3">) {</span>
      <span class="s2">var </span><span class="s1">currentKey </span><span class="s3">= </span><span class="s1">_keys </span><span class="s3">? </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] : </span><span class="s1">index</span><span class="s3">;</span>
      <span class="s1">memo </span><span class="s3">= </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">memo</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">currentKey</span><span class="s3">], </span><span class="s1">currentKey</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">memo</span><span class="s3">;</span>
  <span class="s3">};</span>

  <span class="s2">return function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">memo</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">initial </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt;= </span><span class="s5">3</span><span class="s3">;</span>
    <span class="s2">return </span><span class="s1">reducer</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">optimizeCb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">, </span><span class="s5">4</span><span class="s3">), </span><span class="s1">memo</span><span class="s3">, </span><span class="s1">initial</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// **Reduce** builds up a single result from a list of values, aka `inject`,</span>
<span class="s0">// or `foldl`.</span>
<span class="s2">var </span><span class="s1">reduce </span><span class="s3">= </span><span class="s1">createReduce</span><span class="s3">(</span><span class="s5">1</span><span class="s3">);</span>

<span class="s0">// The right-associative version of reduce, also known as `foldr`.</span>
<span class="s2">var </span><span class="s1">reduceRight </span><span class="s3">= </span><span class="s1">createReduce</span><span class="s3">(-</span><span class="s5">1</span><span class="s3">);</span>

<span class="s0">// Return all the elements that pass a truth test.</span>
<span class="s2">function </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">results </span><span class="s3">= [];</span>
  <span class="s1">predicate </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s1">each</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">list</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)) </span><span class="s1">results</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">);</span>
  <span class="s3">});</span>
  <span class="s2">return </span><span class="s1">results</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Return all the elements for which a truth test fails.</span>
<span class="s2">function </span><span class="s1">reject</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">negate</span><span class="s3">(</span><span class="s1">cb</span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">)), </span><span class="s1">context</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Determine whether all of the elements pass a truth test.</span>
<span class="s2">function </span><span class="s1">every</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s1">predicate </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= !</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">),</span>
      <span class="s1">length </span><span class="s3">= (</span><span class="s1">_keys </span><span class="s3">|| </span><span class="s1">obj</span><span class="s3">).</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">currentKey </span><span class="s3">= </span><span class="s1">_keys </span><span class="s3">? </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] : </span><span class="s1">index</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">predicate</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">currentKey</span><span class="s3">], </span><span class="s1">currentKey</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return false</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">return true</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Determine if at least one element in the object passes a truth test.</span>
<span class="s2">function </span><span class="s1">some</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s1">predicate </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">_keys </span><span class="s3">= !</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) &amp;&amp; </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">),</span>
      <span class="s1">length </span><span class="s3">= (</span><span class="s1">_keys </span><span class="s3">|| </span><span class="s1">obj</span><span class="s3">).</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">currentKey </span><span class="s3">= </span><span class="s1">_keys </span><span class="s3">? </span><span class="s1">_keys</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] : </span><span class="s1">index</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">predicate</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">currentKey</span><span class="s3">], </span><span class="s1">currentKey</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return true</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">return false</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Determine if the array or object contains a given item (using `===`).</span>
<span class="s2">function </span><span class="s1">contains</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">item</span><span class="s3">, </span><span class="s1">fromIndex</span><span class="s3">, </span><span class="s1">guard</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">values</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s2">typeof </span><span class="s1">fromIndex </span><span class="s3">!= </span><span class="s4">'number' </span><span class="s3">|| </span><span class="s1">guard</span><span class="s3">) </span><span class="s1">fromIndex </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">indexOf</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">item</span><span class="s3">, </span><span class="s1">fromIndex</span><span class="s3">) &gt;= </span><span class="s5">0</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Invoke a method (with arguments) on every item in a collection.</span>
<span class="s2">var </span><span class="s1">invoke </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">path</span><span class="s3">, </span><span class="s1">args</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">contextPath</span><span class="s3">, </span><span class="s1">func</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">path</span><span class="s3">)) {</span>
    <span class="s1">func </span><span class="s3">= </span><span class="s1">path</span><span class="s3">;</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">path </span><span class="s3">= </span><span class="s1">toPath$1</span><span class="s3">(</span><span class="s1">path</span><span class="s3">);</span>
    <span class="s1">contextPath </span><span class="s3">= </span><span class="s1">path</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, -</span><span class="s5">1</span><span class="s3">);</span>
    <span class="s1">path </span><span class="s3">= </span><span class="s1">path</span><span class="s3">[</span><span class="s1">path</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">];</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">map</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">context</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">method </span><span class="s3">= </span><span class="s1">func</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">method</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">contextPath </span><span class="s3">&amp;&amp; </span><span class="s1">contextPath</span><span class="s3">.</span><span class="s1">length</span><span class="s3">) {</span>
        <span class="s1">context </span><span class="s3">= </span><span class="s1">deepGet</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">contextPath</span><span class="s3">);</span>
      <span class="s3">}</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">context </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return void </span><span class="s5">0</span><span class="s3">;</span>
      <span class="s1">method </span><span class="s3">= </span><span class="s1">context</span><span class="s3">[</span><span class="s1">path</span><span class="s3">];</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">method </span><span class="s3">== </span><span class="s2">null </span><span class="s3">? </span><span class="s1">method </span><span class="s3">: </span><span class="s1">method</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">context</span><span class="s3">, </span><span class="s1">args</span><span class="s3">);</span>
  <span class="s3">});</span>
<span class="s3">});</span>

<span class="s0">// Convenience version of a common use case of `_.map`: fetching a property.</span>
<span class="s2">function </span><span class="s1">pluck</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">map</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">property</span><span class="s3">(</span><span class="s1">key</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s0">// Convenience version of a common use case of `_.filter`: selecting only</span>
<span class="s0">// objects containing specific `key:value` pairs.</span>
<span class="s2">function </span><span class="s1">where</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">attrs</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">matcher</span><span class="s3">(</span><span class="s1">attrs</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s0">// Return the maximum element (or element-based computation).</span>
<span class="s2">function </span><span class="s1">max</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= -</span><span class="s1">Infinity</span><span class="s3">, </span><span class="s1">lastComputed </span><span class="s3">= -</span><span class="s1">Infinity</span><span class="s3">,</span>
      <span class="s1">value</span><span class="s3">, </span><span class="s1">computed</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">iteratee </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s2">typeof </span><span class="s1">iteratee </span><span class="s3">== </span><span class="s4">'number' </span><span class="s3">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s4">'object' </span><span class="s3">&amp;&amp; </span><span class="s1">obj </span><span class="s3">!= </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s1">obj </span><span class="s3">= </span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) ? </span><span class="s1">obj </span><span class="s3">: </span><span class="s1">values</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
      <span class="s1">value </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">!= </span><span class="s2">null </span><span class="s3">&amp;&amp; </span><span class="s1">value </span><span class="s3">&gt; </span><span class="s1">result</span><span class="s3">) {</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">value</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
    <span class="s1">each</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">list</span><span class="s3">) {</span>
      <span class="s1">computed </span><span class="s3">= </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">list</span><span class="s3">);</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">computed </span><span class="s3">&gt; </span><span class="s1">lastComputed </span><span class="s3">|| </span><span class="s1">computed </span><span class="s3">=== -</span><span class="s1">Infinity </span><span class="s3">&amp;&amp; </span><span class="s1">result </span><span class="s3">=== -</span><span class="s1">Infinity</span><span class="s3">) {</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">v</span><span class="s3">;</span>
        <span class="s1">lastComputed </span><span class="s3">= </span><span class="s1">computed</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">});</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Return the minimum element (or element-based computation).</span>
<span class="s2">function </span><span class="s1">min</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= </span><span class="s1">Infinity</span><span class="s3">, </span><span class="s1">lastComputed </span><span class="s3">= </span><span class="s1">Infinity</span><span class="s3">,</span>
      <span class="s1">value</span><span class="s3">, </span><span class="s1">computed</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">iteratee </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s2">typeof </span><span class="s1">iteratee </span><span class="s3">== </span><span class="s4">'number' </span><span class="s3">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj</span><span class="s3">[</span><span class="s5">0</span><span class="s3">] != </span><span class="s4">'object' </span><span class="s3">&amp;&amp; </span><span class="s1">obj </span><span class="s3">!= </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s1">obj </span><span class="s3">= </span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) ? </span><span class="s1">obj </span><span class="s3">: </span><span class="s1">values</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
      <span class="s1">value </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">value </span><span class="s3">!= </span><span class="s2">null </span><span class="s3">&amp;&amp; </span><span class="s1">value </span><span class="s3">&lt; </span><span class="s1">result</span><span class="s3">) {</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">value</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
    <span class="s1">each</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">list</span><span class="s3">) {</span>
      <span class="s1">computed </span><span class="s3">= </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">v</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">list</span><span class="s3">);</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">computed </span><span class="s3">&lt; </span><span class="s1">lastComputed </span><span class="s3">|| </span><span class="s1">computed </span><span class="s3">=== </span><span class="s1">Infinity </span><span class="s3">&amp;&amp; </span><span class="s1">result </span><span class="s3">=== </span><span class="s1">Infinity</span><span class="s3">) {</span>
        <span class="s1">result </span><span class="s3">= </span><span class="s1">v</span><span class="s3">;</span>
        <span class="s1">lastComputed </span><span class="s3">= </span><span class="s1">computed</span><span class="s3">;</span>
      <span class="s3">}</span>
    <span class="s3">});</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Sample **n** random values from a collection using the modern version of the</span>
<span class="s0">// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).</span>
<span class="s0">// If **n** is not specified, returns a single random element.</span>
<span class="s0">// The internal `guard` argument allows it to work with `_.map`.</span>
<span class="s2">function </span><span class="s1">sample</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">guard</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">guard</span><span class="s3">) {</span>
    <span class="s2">if </span><span class="s3">(!</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">values</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
    <span class="s2">return </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">random</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">)];</span>
  <span class="s3">}</span>
  <span class="s2">var </span><span class="s1">sample </span><span class="s3">= </span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) ? </span><span class="s1">clone</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) : </span><span class="s1">values</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">sample</span><span class="s3">);</span>
  <span class="s1">n </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">n</span><span class="s3">, </span><span class="s1">length</span><span class="s3">), </span><span class="s5">0</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">last </span><span class="s3">= </span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">n</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">rand </span><span class="s3">= </span><span class="s1">random</span><span class="s3">(</span><span class="s1">index</span><span class="s3">, </span><span class="s1">last</span><span class="s3">);</span>
    <span class="s2">var </span><span class="s1">temp </span><span class="s3">= </span><span class="s1">sample</span><span class="s3">[</span><span class="s1">index</span><span class="s3">];</span>
    <span class="s1">sample</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">sample</span><span class="s3">[</span><span class="s1">rand</span><span class="s3">];</span>
    <span class="s1">sample</span><span class="s3">[</span><span class="s1">rand</span><span class="s3">] = </span><span class="s1">temp</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">sample</span><span class="s3">.</span><span class="s1">slice</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">n</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Shuffle a collection.</span>
<span class="s2">function </span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">sample</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">Infinity</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Sort the object's values by a criterion produced by an iteratee.</span>
<span class="s2">function </span><span class="s1">sortBy</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">pluck</span><span class="s3">(</span><span class="s1">map</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">list</span><span class="s3">) {</span>
    <span class="s2">return </span><span class="s3">{</span>
      <span class="s1">value</span><span class="s3">: </span><span class="s1">value</span><span class="s3">,</span>
      <span class="s1">index</span><span class="s3">: </span><span class="s1">index</span><span class="s3">++,</span>
      <span class="s1">criteria</span><span class="s3">: </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">list</span><span class="s3">)</span>
    <span class="s3">};</span>
  <span class="s3">}).</span><span class="s1">sort</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">left</span><span class="s3">, </span><span class="s1">right</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">a </span><span class="s3">= </span><span class="s1">left</span><span class="s3">.</span><span class="s1">criteria</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">b </span><span class="s3">= </span><span class="s1">right</span><span class="s3">.</span><span class="s1">criteria</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">!== </span><span class="s1">b</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">&gt; </span><span class="s1">b </span><span class="s3">|| </span><span class="s1">a </span><span class="s3">=== </span><span class="s2">void </span><span class="s5">0</span><span class="s3">) </span><span class="s2">return </span><span class="s5">1</span><span class="s3">;</span>
      <span class="s2">if </span><span class="s3">(</span><span class="s1">a </span><span class="s3">&lt; </span><span class="s1">b </span><span class="s3">|| </span><span class="s1">b </span><span class="s3">=== </span><span class="s2">void </span><span class="s5">0</span><span class="s3">) </span><span class="s2">return </span><span class="s3">-</span><span class="s5">1</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">left</span><span class="s3">.</span><span class="s1">index </span><span class="s3">- </span><span class="s1">right</span><span class="s3">.</span><span class="s1">index</span><span class="s3">;</span>
  <span class="s3">}), </span><span class="s4">'value'</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// An internal function used for aggregate &quot;group by&quot; operations.</span>
<span class="s2">function </span><span class="s1">group</span><span class="s3">(</span><span class="s1">behavior</span><span class="s3">, </span><span class="s1">partition</span><span class="s3">) {</span>
  <span class="s2">return function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">result </span><span class="s3">= </span><span class="s1">partition </span><span class="s3">? [[], []] : {};</span>
    <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
    <span class="s1">each</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">) {</span>
      <span class="s2">var </span><span class="s1">key </span><span class="s3">= </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">index</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">);</span>
      <span class="s1">behavior</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">);</span>
    <span class="s3">});</span>
    <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
  <span class="s3">};</span>
<span class="s3">}</span>

<span class="s0">// Groups the object's values by a criterion. Pass either a string attribute</span>
<span class="s0">// to group by, or a function that returns the criterion.</span>
<span class="s2">var </span><span class="s1">groupBy </span><span class="s3">= </span><span class="s1">group</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">has</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)) </span><span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">].</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">); </span><span class="s2">else </span><span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = [</span><span class="s1">value</span><span class="s3">];</span>
<span class="s3">});</span>

<span class="s0">// Indexes the object's values by a criterion, similar to `_.groupBy`, but for</span>
<span class="s0">// when you know that your index values will be unique.</span>
<span class="s2">var </span><span class="s1">indexBy </span><span class="s3">= </span><span class="s1">group</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) {</span>
  <span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s0">// Counts instances of an object that group by a certain criterion. Pass</span>
<span class="s0">// either a string attribute to count by, or a function that returns the</span>
<span class="s0">// criterion.</span>
<span class="s2">var </span><span class="s1">countBy </span><span class="s3">= </span><span class="s1">group</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">has</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">key</span><span class="s3">)) </span><span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">]++; </span><span class="s2">else </span><span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s5">1</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s0">// Split a collection into two arrays: one whose elements all pass the given</span>
<span class="s0">// truth test, and one whose elements all do not pass the truth test.</span>
<span class="s2">var </span><span class="s1">partition </span><span class="s3">= </span><span class="s1">group</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">pass</span><span class="s3">) {</span>
  <span class="s1">result</span><span class="s3">[</span><span class="s1">pass </span><span class="s3">? </span><span class="s5">0 </span><span class="s3">: </span><span class="s5">1</span><span class="s3">].</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">);</span>
<span class="s3">}, </span><span class="s2">true</span><span class="s3">);</span>

<span class="s0">// Safely create a real, live array from anything iterable.</span>
<span class="s2">var </span><span class="s1">reStrSymbol </span><span class="s3">= </span><span class="s6">/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g</span><span class="s3">;</span>
<span class="s2">function </span><span class="s1">toArray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">obj</span><span class="s3">) </span><span class="s2">return </span><span class="s3">[];</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isArray</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">slice</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isString</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) {</span>
    <span class="s0">// Keep surrogate pair characters together.</span>
    <span class="s2">return </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">match</span><span class="s3">(</span><span class="s1">reStrSymbol</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">)) </span><span class="s2">return </span><span class="s1">map</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">identity</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">values</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Return the number of elements in a collection.</span>
<span class="s2">function </span><span class="s1">size</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s2">return </span><span class="s1">isArrayLike</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) ? </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">length </span><span class="s3">: </span><span class="s1">keys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">).</span><span class="s1">length</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Internal `_.pick` helper function to determine whether `key` is an enumerable</span>
<span class="s0">// property name of `obj`.</span>
<span class="s2">function </span><span class="s1">keyInObj</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Return a copy of the object only containing the allowed properties.</span>
<span class="s2">var </span><span class="s1">pick </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= {}, </span><span class="s1">iteratee </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">[</span><span class="s5">0</span><span class="s3">];</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) </span><span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">)) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">keys</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">) </span><span class="s1">iteratee </span><span class="s3">= </span><span class="s1">optimizeCb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">[</span><span class="s5">1</span><span class="s3">]);</span>
    <span class="s1">keys </span><span class="s3">= </span><span class="s1">allKeys</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">keyInObj</span><span class="s3">;</span>
    <span class="s1">keys </span><span class="s3">= </span><span class="s1">flatten</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s2">false</span><span class="s3">);</span>
    <span class="s1">obj </span><span class="s3">= </span><span class="s1">Object</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">.</span><span class="s1">length</span><span class="s3">; </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">key </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s2">var </span><span class="s1">value </span><span class="s3">= </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">key</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">)) </span><span class="s1">result</span><span class="s3">[</span><span class="s1">key</span><span class="s3">] = </span><span class="s1">value</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">});</span>

<span class="s0">// Return a copy of the object without the disallowed properties.</span>
<span class="s2">var </span><span class="s1">omit </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">iteratee </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">[</span><span class="s5">0</span><span class="s3">], </span><span class="s1">context</span><span class="s3">;</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">isFunction$1</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">)) {</span>
    <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">negate</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">);</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">keys</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&gt; </span><span class="s5">1</span><span class="s3">) </span><span class="s1">context </span><span class="s3">= </span><span class="s1">keys</span><span class="s3">[</span><span class="s5">1</span><span class="s3">];</span>
  <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
    <span class="s1">keys </span><span class="s3">= </span><span class="s1">map</span><span class="s3">(</span><span class="s1">flatten</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">, </span><span class="s2">false</span><span class="s3">, </span><span class="s2">false</span><span class="s3">), </span><span class="s1">String</span><span class="s3">);</span>
    <span class="s1">iteratee </span><span class="s3">= </span><span class="s2">function</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">key</span><span class="s3">) {</span>
      <span class="s2">return </span><span class="s3">!</span><span class="s1">contains</span><span class="s3">(</span><span class="s1">keys</span><span class="s3">, </span><span class="s1">key</span><span class="s3">);</span>
    <span class="s3">};</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">pick</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
<span class="s3">});</span>

<span class="s0">// Returns everything but the last entry of the array. Especially useful on</span>
<span class="s0">// the arguments object. Passing **n** will return all the values in</span>
<span class="s0">// the array, excluding the last N.</span>
<span class="s2">function </span><span class="s1">initial</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">guard</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">slice</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">array</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- (</span><span class="s1">n </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">guard </span><span class="s3">? </span><span class="s5">1 </span><span class="s3">: </span><span class="s1">n</span><span class="s3">)));</span>
<span class="s3">}</span>

<span class="s0">// Get the first element of an array. Passing **n** will return the first N</span>
<span class="s0">// values in the array. The **guard** check allows it to work with `_.map`.</span>
<span class="s2">function </span><span class="s1">first</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">guard</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">array </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">array</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">) </span><span class="s2">return </span><span class="s1">n </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">guard </span><span class="s3">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s3">: [];</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">guard</span><span class="s3">) </span><span class="s2">return </span><span class="s1">array</span><span class="s3">[</span><span class="s5">0</span><span class="s3">];</span>
  <span class="s2">return </span><span class="s1">initial</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">array</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s1">n</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Returns everything but the first entry of the `array`. Especially useful on</span>
<span class="s0">// the `arguments` object. Passing an **n** will return the rest N values in the</span>
<span class="s0">// `array`.</span>
<span class="s2">function </span><span class="s1">rest</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">guard</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">slice</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">n </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">guard </span><span class="s3">? </span><span class="s5">1 </span><span class="s3">: </span><span class="s1">n</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Get the last element of an array. Passing **n** will return the last N</span>
<span class="s0">// values in the array.</span>
<span class="s2">function </span><span class="s1">last</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">n</span><span class="s3">, </span><span class="s1">guard</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">array </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">array</span><span class="s3">.</span><span class="s1">length </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">) </span><span class="s2">return </span><span class="s1">n </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">guard </span><span class="s3">? </span><span class="s2">void </span><span class="s5">0 </span><span class="s3">: [];</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">n </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">guard</span><span class="s3">) </span><span class="s2">return </span><span class="s1">array</span><span class="s3">[</span><span class="s1">array</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s5">1</span><span class="s3">];</span>
  <span class="s2">return </span><span class="s1">rest</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">array</span><span class="s3">.</span><span class="s1">length </span><span class="s3">- </span><span class="s1">n</span><span class="s3">));</span>
<span class="s3">}</span>

<span class="s0">// Trim out all falsy values from an array.</span>
<span class="s2">function </span><span class="s1">compact</span><span class="s3">(</span><span class="s1">array</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">Boolean</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Flatten out an array, either recursively (by default), or up to `depth`.</span>
<span class="s0">// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.</span>
<span class="s2">function </span><span class="s1">flatten$1</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">depth</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">flatten</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">depth</span><span class="s3">, </span><span class="s2">false</span><span class="s3">);</span>
<span class="s3">}</span>

<span class="s0">// Take the difference between one array and a number of other arrays.</span>
<span class="s0">// Only the elements present in just the first array will remain.</span>
<span class="s2">var </span><span class="s1">difference </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">rest</span><span class="s3">) {</span>
  <span class="s1">rest </span><span class="s3">= </span><span class="s1">flatten</span><span class="s3">(</span><span class="s1">rest</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s2">true</span><span class="s3">);</span>
  <span class="s2">return </span><span class="s1">filter</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s2">function</span><span class="s3">(</span><span class="s1">value</span><span class="s3">){</span>
    <span class="s2">return </span><span class="s3">!</span><span class="s1">contains</span><span class="s3">(</span><span class="s1">rest</span><span class="s3">, </span><span class="s1">value</span><span class="s3">);</span>
  <span class="s3">});</span>
<span class="s3">});</span>

<span class="s0">// Return a version of the array that does not contain the specified value(s).</span>
<span class="s2">var </span><span class="s1">without </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">otherArrays</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">difference</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">otherArrays</span><span class="s3">);</span>
<span class="s3">});</span>

<span class="s0">// Produce a duplicate-free version of the array. If the array has already</span>
<span class="s0">// been sorted, you have the option of using a faster algorithm.</span>
<span class="s0">// The faster algorithm will not work with an iteratee if the iteratee</span>
<span class="s0">// is not a one-to-one function, so providing an iteratee will disable</span>
<span class="s0">// the faster algorithm.</span>
<span class="s2">function </span><span class="s1">uniq</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">isSorted</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">isBoolean</span><span class="s3">(</span><span class="s1">isSorted</span><span class="s3">)) {</span>
    <span class="s1">context </span><span class="s3">= </span><span class="s1">iteratee</span><span class="s3">;</span>
    <span class="s1">iteratee </span><span class="s3">= </span><span class="s1">isSorted</span><span class="s3">;</span>
    <span class="s1">isSorted </span><span class="s3">= </span><span class="s2">false</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">iteratee </span><span class="s3">!= </span><span class="s2">null</span><span class="s3">) </span><span class="s1">iteratee </span><span class="s3">= </span><span class="s1">cb</span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">context</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= [];</span>
  <span class="s2">var </span><span class="s1">seen </span><span class="s3">= [];</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">array</span><span class="s3">); </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">value </span><span class="s3">= </span><span class="s1">array</span><span class="s3">[</span><span class="s1">i</span><span class="s3">],</span>
        <span class="s1">computed </span><span class="s3">= </span><span class="s1">iteratee </span><span class="s3">? </span><span class="s1">iteratee</span><span class="s3">(</span><span class="s1">value</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">array</span><span class="s3">) : </span><span class="s1">value</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">isSorted </span><span class="s3">&amp;&amp; !</span><span class="s1">iteratee</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">i </span><span class="s3">|| </span><span class="s1">seen </span><span class="s3">!== </span><span class="s1">computed</span><span class="s3">) </span><span class="s1">result</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">);</span>
      <span class="s1">seen </span><span class="s3">= </span><span class="s1">computed</span><span class="s3">;</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(</span><span class="s1">iteratee</span><span class="s3">) {</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">contains</span><span class="s3">(</span><span class="s1">seen</span><span class="s3">, </span><span class="s1">computed</span><span class="s3">)) {</span>
        <span class="s1">seen</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">computed</span><span class="s3">);</span>
        <span class="s1">result</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">);</span>
      <span class="s3">}</span>
    <span class="s3">} </span><span class="s2">else if </span><span class="s3">(!</span><span class="s1">contains</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">value</span><span class="s3">)) {</span>
      <span class="s1">result</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">value</span><span class="s3">);</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Produce an array that contains the union: each distinct element from all of</span>
<span class="s0">// the passed-in arrays.</span>
<span class="s2">var </span><span class="s1">union </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s2">function</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">uniq</span><span class="s3">(</span><span class="s1">flatten</span><span class="s3">(</span><span class="s1">arrays</span><span class="s3">, </span><span class="s2">true</span><span class="s3">, </span><span class="s2">true</span><span class="s3">));</span>
<span class="s3">});</span>

<span class="s0">// Produce an array that contains every item shared between all the</span>
<span class="s0">// passed-in arrays.</span>
<span class="s2">function </span><span class="s1">intersection</span><span class="s3">(</span><span class="s1">array</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= [];</span>
  <span class="s2">var </span><span class="s1">argsLength </span><span class="s3">= </span><span class="s1">arguments</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">array</span><span class="s3">); </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">var </span><span class="s1">item </span><span class="s3">= </span><span class="s1">array</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">contains</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">item</span><span class="s3">)) </span><span class="s2">continue</span><span class="s3">;</span>
    <span class="s2">var </span><span class="s1">j</span><span class="s3">;</span>
    <span class="s2">for </span><span class="s3">(</span><span class="s1">j </span><span class="s3">= </span><span class="s5">1</span><span class="s3">; </span><span class="s1">j </span><span class="s3">&lt; </span><span class="s1">argsLength</span><span class="s3">; </span><span class="s1">j</span><span class="s3">++) {</span>
      <span class="s2">if </span><span class="s3">(!</span><span class="s1">contains</span><span class="s3">(</span><span class="s1">arguments</span><span class="s3">[</span><span class="s1">j</span><span class="s3">], </span><span class="s1">item</span><span class="s3">)) </span><span class="s2">break</span><span class="s3">;</span>
    <span class="s3">}</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">j </span><span class="s3">=== </span><span class="s1">argsLength</span><span class="s3">) </span><span class="s1">result</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">item</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Complement of zip. Unzip accepts an array of arrays and groups</span>
<span class="s0">// each array's elements on shared indices.</span>
<span class="s2">function </span><span class="s1">unzip</span><span class="s3">(</span><span class="s1">array</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">array </span><span class="s3">&amp;&amp; </span><span class="s1">max</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">getLength</span><span class="s3">).</span><span class="s1">length </span><span class="s3">|| </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">length</span><span class="s3">);</span>

  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">index </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">index </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">index</span><span class="s3">++) {</span>
    <span class="s1">result</span><span class="s3">[</span><span class="s1">index</span><span class="s3">] = </span><span class="s1">pluck</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">index</span><span class="s3">);</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Zip together multiple lists into a single array -- elements that share</span>
<span class="s0">// an index go together.</span>
<span class="s2">var </span><span class="s1">zip </span><span class="s3">= </span><span class="s1">restArguments</span><span class="s3">(</span><span class="s1">unzip</span><span class="s3">);</span>

<span class="s0">// Converts lists into objects. Pass either a single array of `[key, value]`</span>
<span class="s0">// pairs, or two parallel arrays of the same length -- one of keys, and one of</span>
<span class="s0">// the corresponding values. Passing by pairs is the reverse of `_.pairs`.</span>
<span class="s2">function </span><span class="s1">object</span><span class="s3">(</span><span class="s1">list</span><span class="s3">, </span><span class="s1">values</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= {};</span>
  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">getLength</span><span class="s3">(</span><span class="s1">list</span><span class="s3">); </span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">i</span><span class="s3">++) {</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">values</span><span class="s3">) {</span>
      <span class="s1">result</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">i</span><span class="s3">]] = </span><span class="s1">values</span><span class="s3">[</span><span class="s1">i</span><span class="s3">];</span>
    <span class="s3">} </span><span class="s2">else </span><span class="s3">{</span>
      <span class="s1">result</span><span class="s3">[</span><span class="s1">list</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s5">0</span><span class="s3">]] = </span><span class="s1">list</span><span class="s3">[</span><span class="s1">i</span><span class="s3">][</span><span class="s5">1</span><span class="s3">];</span>
    <span class="s3">}</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Generate an integer Array containing an arithmetic progression. A port of</span>
<span class="s0">// the native Python `range()` function. See</span>
<span class="s0">// [the Python documentation](https://docs.python.org/library/functions.html#range).</span>
<span class="s2">function </span><span class="s1">range</span><span class="s3">(</span><span class="s1">start</span><span class="s3">, </span><span class="s1">stop</span><span class="s3">, </span><span class="s1">step</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">stop </span><span class="s3">== </span><span class="s2">null</span><span class="s3">) {</span>
    <span class="s1">stop </span><span class="s3">= </span><span class="s1">start </span><span class="s3">|| </span><span class="s5">0</span><span class="s3">;</span>
    <span class="s1">start </span><span class="s3">= </span><span class="s5">0</span><span class="s3">;</span>
  <span class="s3">}</span>
  <span class="s2">if </span><span class="s3">(!</span><span class="s1">step</span><span class="s3">) {</span>
    <span class="s1">step </span><span class="s3">= </span><span class="s1">stop </span><span class="s3">&lt; </span><span class="s1">start </span><span class="s3">? -</span><span class="s5">1 </span><span class="s3">: </span><span class="s5">1</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">var </span><span class="s1">length </span><span class="s3">= </span><span class="s1">Math</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">Math</span><span class="s3">.</span><span class="s1">ceil</span><span class="s3">((</span><span class="s1">stop </span><span class="s3">- </span><span class="s1">start</span><span class="s3">) / </span><span class="s1">step</span><span class="s3">), </span><span class="s5">0</span><span class="s3">);</span>
  <span class="s2">var </span><span class="s1">range </span><span class="s3">= </span><span class="s1">Array</span><span class="s3">(</span><span class="s1">length</span><span class="s3">);</span>

  <span class="s2">for </span><span class="s3">(</span><span class="s2">var </span><span class="s1">idx </span><span class="s3">= </span><span class="s5">0</span><span class="s3">; </span><span class="s1">idx </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">; </span><span class="s1">idx</span><span class="s3">++, </span><span class="s1">start </span><span class="s3">+= </span><span class="s1">step</span><span class="s3">) {</span>
    <span class="s1">range</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">] = </span><span class="s1">start</span><span class="s3">;</span>
  <span class="s3">}</span>

  <span class="s2">return </span><span class="s1">range</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Chunk a single array into multiple arrays, each containing `count` or fewer</span>
<span class="s0">// items.</span>
<span class="s2">function </span><span class="s1">chunk</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">count</span><span class="s3">) {</span>
  <span class="s2">if </span><span class="s3">(</span><span class="s1">count </span><span class="s3">== </span><span class="s2">null </span><span class="s3">|| </span><span class="s1">count </span><span class="s3">&lt; </span><span class="s5">1</span><span class="s3">) </span><span class="s2">return </span><span class="s3">[];</span>
  <span class="s2">var </span><span class="s1">result </span><span class="s3">= [];</span>
  <span class="s2">var </span><span class="s1">i </span><span class="s3">= </span><span class="s5">0</span><span class="s3">, </span><span class="s1">length </span><span class="s3">= </span><span class="s1">array</span><span class="s3">.</span><span class="s1">length</span><span class="s3">;</span>
  <span class="s2">while </span><span class="s3">(</span><span class="s1">i </span><span class="s3">&lt; </span><span class="s1">length</span><span class="s3">) {</span>
    <span class="s1">result</span><span class="s3">.</span><span class="s1">push</span><span class="s3">(</span><span class="s1">slice</span><span class="s3">.</span><span class="s1">call</span><span class="s3">(</span><span class="s1">array</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s1">i </span><span class="s3">+= </span><span class="s1">count</span><span class="s3">));</span>
  <span class="s3">}</span>
  <span class="s2">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Helper function to continue chaining intermediate results.</span>
<span class="s2">function </span><span class="s1">chainResult</span><span class="s3">(</span><span class="s1">instance</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s2">return </span><span class="s1">instance</span><span class="s3">.</span><span class="s1">_chain </span><span class="s3">? </span><span class="s1">_</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">).</span><span class="s1">chain</span><span class="s3">() : </span><span class="s1">obj</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Add your own custom functions to the Underscore object.</span>
<span class="s2">function </span><span class="s1">mixin</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">) {</span>
  <span class="s1">each</span><span class="s3">(</span><span class="s1">functions</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">), </span><span class="s2">function</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
    <span class="s2">var </span><span class="s1">func </span><span class="s3">= </span><span class="s1">_</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s1">obj</span><span class="s3">[</span><span class="s1">name</span><span class="s3">];</span>
    <span class="s1">_</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s2">function</span><span class="s3">() {</span>
      <span class="s2">var </span><span class="s1">args </span><span class="s3">= [</span><span class="s2">this</span><span class="s3">.</span><span class="s1">_wrapped</span><span class="s3">];</span>
      <span class="s1">push</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">args</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
      <span class="s2">return </span><span class="s1">chainResult</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">func</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">_</span><span class="s3">, </span><span class="s1">args</span><span class="s3">));</span>
    <span class="s3">};</span>
  <span class="s3">});</span>
  <span class="s2">return </span><span class="s1">_</span><span class="s3">;</span>
<span class="s3">}</span>

<span class="s0">// Add all mutator `Array` functions to the wrapper.</span>
<span class="s1">each</span><span class="s3">([</span><span class="s4">'pop'</span><span class="s3">, </span><span class="s4">'push'</span><span class="s3">, </span><span class="s4">'reverse'</span><span class="s3">, </span><span class="s4">'shift'</span><span class="s3">, </span><span class="s4">'sort'</span><span class="s3">, </span><span class="s4">'splice'</span><span class="s3">, </span><span class="s4">'unshift'</span><span class="s3">], </span><span class="s2">function</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">method </span><span class="s3">= </span><span class="s1">ArrayProto</span><span class="s3">[</span><span class="s1">name</span><span class="s3">];</span>
  <span class="s1">_</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">var </span><span class="s1">obj </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">_wrapped</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">!= </span><span class="s2">null</span><span class="s3">) {</span>
      <span class="s1">method</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
      <span class="s2">if </span><span class="s3">((</span><span class="s1">name </span><span class="s3">=== </span><span class="s4">'shift' </span><span class="s3">|| </span><span class="s1">name </span><span class="s3">=== </span><span class="s4">'splice'</span><span class="s3">) &amp;&amp; </span><span class="s1">obj</span><span class="s3">.</span><span class="s1">length </span><span class="s3">=== </span><span class="s5">0</span><span class="s3">) {</span>
        <span class="s2">delete </span><span class="s1">obj</span><span class="s3">[</span><span class="s5">0</span><span class="s3">];</span>
      <span class="s3">}</span>
    <span class="s3">}</span>
    <span class="s2">return </span><span class="s1">chainResult</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">});</span>

<span class="s0">// Add all accessor `Array` functions to the wrapper.</span>
<span class="s1">each</span><span class="s3">([</span><span class="s4">'concat'</span><span class="s3">, </span><span class="s4">'join'</span><span class="s3">, </span><span class="s4">'slice'</span><span class="s3">], </span><span class="s2">function</span><span class="s3">(</span><span class="s1">name</span><span class="s3">) {</span>
  <span class="s2">var </span><span class="s1">method </span><span class="s3">= </span><span class="s1">ArrayProto</span><span class="s3">[</span><span class="s1">name</span><span class="s3">];</span>
  <span class="s1">_</span><span class="s3">.</span><span class="s1">prototype</span><span class="s3">[</span><span class="s1">name</span><span class="s3">] = </span><span class="s2">function</span><span class="s3">() {</span>
    <span class="s2">var </span><span class="s1">obj </span><span class="s3">= </span><span class="s2">this</span><span class="s3">.</span><span class="s1">_wrapped</span><span class="s3">;</span>
    <span class="s2">if </span><span class="s3">(</span><span class="s1">obj </span><span class="s3">!= </span><span class="s2">null</span><span class="s3">) </span><span class="s1">obj </span><span class="s3">= </span><span class="s1">method</span><span class="s3">.</span><span class="s1">apply</span><span class="s3">(</span><span class="s1">obj</span><span class="s3">, </span><span class="s1">arguments</span><span class="s3">);</span>
    <span class="s2">return </span><span class="s1">chainResult</span><span class="s3">(</span><span class="s2">this</span><span class="s3">, </span><span class="s1">obj</span><span class="s3">);</span>
  <span class="s3">};</span>
<span class="s3">});</span>

<span class="s0">// Named Exports</span>

<span class="s2">var </span><span class="s1">allExports </span><span class="s3">= {</span>
  <span class="s1">__proto__</span><span class="s3">: </span><span class="s2">null</span><span class="s3">,</span>
  <span class="s1">VERSION</span><span class="s3">: </span><span class="s1">VERSION</span><span class="s3">,</span>
  <span class="s1">restArguments</span><span class="s3">: </span><span class="s1">restArguments</span><span class="s3">,</span>
  <span class="s1">isObject</span><span class="s3">: </span><span class="s1">isObject</span><span class="s3">,</span>
  <span class="s1">isNull</span><span class="s3">: </span><span class="s1">isNull</span><span class="s3">,</span>
  <span class="s1">isUndefined</span><span class="s3">: </span><span class="s1">isUndefined</span><span class="s3">,</span>
  <span class="s1">isBoolean</span><span class="s3">: </span><span class="s1">isBoolean</span><span class="s3">,</span>
  <span class="s1">isElement</span><span class="s3">: </span><span class="s1">isElement</span><span class="s3">,</span>
  <span class="s1">isString</span><span class="s3">: </span><span class="s1">isString</span><span class="s3">,</span>
  <span class="s1">isNumber</span><span class="s3">: </span><span class="s1">isNumber</span><span class="s3">,</span>
  <span class="s1">isDate</span><span class="s3">: </span><span class="s1">isDate</span><span class="s3">,</span>
  <span class="s1">isRegExp</span><span class="s3">: </span><span class="s1">isRegExp</span><span class="s3">,</span>
  <span class="s1">isError</span><span class="s3">: </span><span class="s1">isError</span><span class="s3">,</span>
  <span class="s1">isSymbol</span><span class="s3">: </span><span class="s1">isSymbol</span><span class="s3">,</span>
  <span class="s1">isArrayBuffer</span><span class="s3">: </span><span class="s1">isArrayBuffer</span><span class="s3">,</span>
  <span class="s1">isDataView</span><span class="s3">: </span><span class="s1">isDataView$1</span><span class="s3">,</span>
  <span class="s1">isArray</span><span class="s3">: </span><span class="s1">isArray</span><span class="s3">,</span>
  <span class="s1">isFunction</span><span class="s3">: </span><span class="s1">isFunction$1</span><span class="s3">,</span>
  <span class="s1">isArguments</span><span class="s3">: </span><span class="s1">isArguments$1</span><span class="s3">,</span>
  <span class="s1">isFinite</span><span class="s3">: </span><span class="s1">isFinite$1</span><span class="s3">,</span>
  <span class="s1">isNaN</span><span class="s3">: </span><span class="s1">isNaN$1</span><span class="s3">,</span>
  <span class="s1">isTypedArray</span><span class="s3">: </span><span class="s1">isTypedArray$1</span><span class="s3">,</span>
  <span class="s1">isEmpty</span><span class="s3">: </span><span class="s1">isEmpty</span><span class="s3">,</span>
  <span class="s1">isMatch</span><span class="s3">: </span><span class="s1">isMatch</span><span class="s3">,</span>
  <span class="s1">isEqual</span><span class="s3">: </span><span class="s1">isEqual</span><span class="s3">,</span>
  <span class="s1">isMap</span><span class="s3">: </span><span class="s1">isMap</span><span class="s3">,</span>
  <span class="s1">isWeakMap</span><span class="s3">: </span><span class="s1">isWeakMap</span><span class="s3">,</span>
  <span class="s1">isSet</span><span class="s3">: </span><span class="s1">isSet</span><span class="s3">,</span>
  <span class="s1">isWeakSet</span><span class="s3">: </span><span class="s1">isWeakSet</span><span class="s3">,</span>
  <span class="s1">keys</span><span class="s3">: </span><span class="s1">keys</span><span class="s3">,</span>
  <span class="s1">allKeys</span><span class="s3">: </span><span class="s1">allKeys</span><span class="s3">,</span>
  <span class="s1">values</span><span class="s3">: </span><span class="s1">values</span><span class="s3">,</span>
  <span class="s1">pairs</span><span class="s3">: </span><span class="s1">pairs</span><span class="s3">,</span>
  <span class="s1">invert</span><span class="s3">: </span><span class="s1">invert</span><span class="s3">,</span>
  <span class="s1">functions</span><span class="s3">: </span><span class="s1">functions</span><span class="s3">,</span>
  <span class="s1">methods</span><span class="s3">: </span><span class="s1">functions</span><span class="s3">,</span>
  <span class="s1">extend</span><span class="s3">: </span><span class="s1">extend</span><span class="s3">,</span>
  <span class="s1">extendOwn</span><span class="s3">: </span><span class="s1">extendOwn</span><span class="s3">,</span>
  <span class="s1">assign</span><span class="s3">: </span><span class="s1">extendOwn</span><span class="s3">,</span>
  <span class="s1">defaults</span><span class="s3">: </span><span class="s1">defaults</span><span class="s3">,</span>
  <span class="s1">create</span><span class="s3">: </span><span class="s1">create</span><span class="s3">,</span>
  <span class="s1">clone</span><span class="s3">: </span><span class="s1">clone</span><span class="s3">,</span>
  <span class="s1">tap</span><span class="s3">: </span><span class="s1">tap</span><span class="s3">,</span>
  <span class="s1">get</span><span class="s3">: </span><span class="s1">get</span><span class="s3">,</span>
  <span class="s1">has</span><span class="s3">: </span><span class="s1">has$1</span><span class="s3">,</span>
  <span class="s1">mapObject</span><span class="s3">: </span><span class="s1">mapObject</span><span class="s3">,</span>
  <span class="s1">identity</span><span class="s3">: </span><span class="s1">identity</span><span class="s3">,</span>
  <span class="s1">constant</span><span class="s3">: </span><span class="s1">constant</span><span class="s3">,</span>
  <span class="s1">noop</span><span class="s3">: </span><span class="s1">noop</span><span class="s3">,</span>
  <span class="s1">toPath</span><span class="s3">: </span><span class="s1">toPath</span><span class="s3">,</span>
  <span class="s1">property</span><span class="s3">: </span><span class="s1">property</span><span class="s3">,</span>
  <span class="s1">propertyOf</span><span class="s3">: </span><span class="s1">propertyOf</span><span class="s3">,</span>
  <span class="s1">matcher</span><span class="s3">: </span><span class="s1">matcher</span><span class="s3">,</span>
  <span class="s1">matches</span><span class="s3">: </span><span class="s1">matcher</span><span class="s3">,</span>
  <span class="s1">times</span><span class="s3">: </span><span class="s1">times</span><span class="s3">,</span>
  <span class="s1">random</span><span class="s3">: </span><span class="s1">random</span><span class="s3">,</span>
  <span class="s1">now</span><span class="s3">: </span><span class="s1">now</span><span class="s3">,</span>
  <span class="s1">escape</span><span class="s3">: </span><span class="s1">_escape</span><span class="s3">,</span>
  <span class="s1">unescape</span><span class="s3">: </span><span class="s1">_unescape</span><span class="s3">,</span>
  <span class="s1">templateSettings</span><span class="s3">: </span><span class="s1">templateSettings</span><span class="s3">,</span>
  <span class="s1">template</span><span class="s3">: </span><span class="s1">template</span><span class="s3">,</span>
  <span class="s1">result</span><span class="s3">: </span><span class="s1">result</span><span class="s3">,</span>
  <span class="s1">uniqueId</span><span class="s3">: </span><span class="s1">uniqueId</span><span class="s3">,</span>
  <span class="s1">chain</span><span class="s3">: </span><span class="s1">chain</span><span class="s3">,</span>
  <span class="s1">iteratee</span><span class="s3">: </span><span class="s1">iteratee</span><span class="s3">,</span>
  <span class="s1">partial</span><span class="s3">: </span><span class="s1">partial</span><span class="s3">,</span>
  <span class="s1">bind</span><span class="s3">: </span><span class="s1">bind</span><span class="s3">,</span>
  <span class="s1">bindAll</span><span class="s3">: </span><span class="s1">bindAll</span><span class="s3">,</span>
  <span class="s1">memoize</span><span class="s3">: </span><span class="s1">memoize</span><span class="s3">,</span>
  <span class="s1">delay</span><span class="s3">: </span><span class="s1">delay</span><span class="s3">,</span>
  <span class="s1">defer</span><span class="s3">: </span><span class="s1">defer</span><span class="s3">,</span>
  <span class="s1">throttle</span><span class="s3">: </span><span class="s1">throttle</span><span class="s3">,</span>
  <span class="s1">debounce</span><span class="s3">: </span><span class="s1">debounce</span><span class="s3">,</span>
  <span class="s1">wrap</span><span class="s3">: </span><span class="s1">wrap</span><span class="s3">,</span>
  <span class="s1">negate</span><span class="s3">: </span><span class="s1">negate</span><span class="s3">,</span>
  <span class="s1">compose</span><span class="s3">: </span><span class="s1">compose</span><span class="s3">,</span>
  <span class="s1">after</span><span class="s3">: </span><span class="s1">after</span><span class="s3">,</span>
  <span class="s1">before</span><span class="s3">: </span><span class="s1">before</span><span class="s3">,</span>
  <span class="s1">once</span><span class="s3">: </span><span class="s1">once</span><span class="s3">,</span>
  <span class="s1">findKey</span><span class="s3">: </span><span class="s1">findKey</span><span class="s3">,</span>
  <span class="s1">findIndex</span><span class="s3">: </span><span class="s1">findIndex</span><span class="s3">,</span>
  <span class="s1">findLastIndex</span><span class="s3">: </span><span class="s1">findLastIndex</span><span class="s3">,</span>
  <span class="s1">sortedIndex</span><span class="s3">: </span><span class="s1">sortedIndex</span><span class="s3">,</span>
  <span class="s1">indexOf</span><span class="s3">: </span><span class="s1">indexOf</span><span class="s3">,</span>
  <span class="s1">lastIndexOf</span><span class="s3">: </span><span class="s1">lastIndexOf</span><span class="s3">,</span>
  <span class="s1">find</span><span class="s3">: </span><span class="s1">find</span><span class="s3">,</span>
  <span class="s1">detect</span><span class="s3">: </span><span class="s1">find</span><span class="s3">,</span>
  <span class="s1">findWhere</span><span class="s3">: </span><span class="s1">findWhere</span><span class="s3">,</span>
  <span class="s1">each</span><span class="s3">: </span><span class="s1">each</span><span class="s3">,</span>
  <span class="s1">forEach</span><span class="s3">: </span><span class="s1">each</span><span class="s3">,</span>
  <span class="s1">map</span><span class="s3">: </span><span class="s1">map</span><span class="s3">,</span>
  <span class="s1">collect</span><span class="s3">: </span><span class="s1">map</span><span class="s3">,</span>
  <span class="s1">reduce</span><span class="s3">: </span><span class="s1">reduce</span><span class="s3">,</span>
  <span class="s1">foldl</span><span class="s3">: </span><span class="s1">reduce</span><span class="s3">,</span>
  <span class="s1">inject</span><span class="s3">: </span><span class="s1">reduce</span><span class="s3">,</span>
  <span class="s1">reduceRight</span><span class="s3">: </span><span class="s1">reduceRight</span><span class="s3">,</span>
  <span class="s1">foldr</span><span class="s3">: </span><span class="s1">reduceRight</span><span class="s3">,</span>
  <span class="s1">filter</span><span class="s3">: </span><span class="s1">filter</span><span class="s3">,</span>
  <span class="s1">select</span><span class="s3">: </span><span class="s1">filter</span><span class="s3">,</span>
  <span class="s1">reject</span><span class="s3">: </span><span class="s1">reject</span><span class="s3">,</span>
  <span class="s1">every</span><span class="s3">: </span><span class="s1">every</span><span class="s3">,</span>
  <span class="s1">all</span><span class="s3">: </span><span class="s1">every</span><span class="s3">,</span>
  <span class="s1">some</span><span class="s3">: </span><span class="s1">some</span><span class="s3">,</span>
  <span class="s1">any</span><span class="s3">: </span><span class="s1">some</span><span class="s3">,</span>
  <span class="s1">contains</span><span class="s3">: </span><span class="s1">contains</span><span class="s3">,</span>
  <span class="s1">includes</span><span class="s3">: </span><span class="s1">contains</span><span class="s3">,</span>
  <span class="s1">include</span><span class="s3">: </span><span class="s1">contains</span><span class="s3">,</span>
  <span class="s1">invoke</span><span class="s3">: </span><span class="s1">invoke</span><span class="s3">,</span>
  <span class="s1">pluck</span><span class="s3">: </span><span class="s1">pluck</span><span class="s3">,</span>
  <span class="s1">where</span><span class="s3">: </span><span class="s1">where</span><span class="s3">,</span>
  <span class="s1">max</span><span class="s3">: </span><span class="s1">max</span><span class="s3">,</span>
  <span class="s1">min</span><span class="s3">: </span><span class="s1">min</span><span class="s3">,</span>
  <span class="s1">shuffle</span><span class="s3">: </span><span class="s1">shuffle</span><span class="s3">,</span>
  <span class="s1">sample</span><span class="s3">: </span><span class="s1">sample</span><span class="s3">,</span>
  <span class="s1">sortBy</span><span class="s3">: </span><span class="s1">sortBy</span><span class="s3">,</span>
  <span class="s1">groupBy</span><span class="s3">: </span><span class="s1">groupBy</span><span class="s3">,</span>
  <span class="s1">indexBy</span><span class="s3">: </span><span class="s1">indexBy</span><span class="s3">,</span>
  <span class="s1">countBy</span><span class="s3">: </span><span class="s1">countBy</span><span class="s3">,</span>
  <span class="s1">partition</span><span class="s3">: </span><span class="s1">partition</span><span class="s3">,</span>
  <span class="s1">toArray</span><span class="s3">: </span><span class="s1">toArray</span><span class="s3">,</span>
  <span class="s1">size</span><span class="s3">: </span><span class="s1">size</span><span class="s3">,</span>
  <span class="s1">pick</span><span class="s3">: </span><span class="s1">pick</span><span class="s3">,</span>
  <span class="s1">omit</span><span class="s3">: </span><span class="s1">omit</span><span class="s3">,</span>
  <span class="s1">first</span><span class="s3">: </span><span class="s1">first</span><span class="s3">,</span>
  <span class="s1">head</span><span class="s3">: </span><span class="s1">first</span><span class="s3">,</span>
  <span class="s1">take</span><span class="s3">: </span><span class="s1">first</span><span class="s3">,</span>
  <span class="s1">initial</span><span class="s3">: </span><span class="s1">initial</span><span class="s3">,</span>
  <span class="s1">last</span><span class="s3">: </span><span class="s1">last</span><span class="s3">,</span>
  <span class="s1">rest</span><span class="s3">: </span><span class="s1">rest</span><span class="s3">,</span>
  <span class="s1">tail</span><span class="s3">: </span><span class="s1">rest</span><span class="s3">,</span>
  <span class="s1">drop</span><span class="s3">: </span><span class="s1">rest</span><span class="s3">,</span>
  <span class="s1">compact</span><span class="s3">: </span><span class="s1">compact</span><span class="s3">,</span>
  <span class="s1">flatten</span><span class="s3">: </span><span class="s1">flatten$1</span><span class="s3">,</span>
  <span class="s1">without</span><span class="s3">: </span><span class="s1">without</span><span class="s3">,</span>
  <span class="s1">uniq</span><span class="s3">: </span><span class="s1">uniq</span><span class="s3">,</span>
  <span class="s1">unique</span><span class="s3">: </span><span class="s1">uniq</span><span class="s3">,</span>
  <span class="s1">union</span><span class="s3">: </span><span class="s1">union</span><span class="s3">,</span>
  <span class="s1">intersection</span><span class="s3">: </span><span class="s1">intersection</span><span class="s3">,</span>
  <span class="s1">difference</span><span class="s3">: </span><span class="s1">difference</span><span class="s3">,</span>
  <span class="s1">unzip</span><span class="s3">: </span><span class="s1">unzip</span><span class="s3">,</span>
  <span class="s1">transpose</span><span class="s3">: </span><span class="s1">unzip</span><span class="s3">,</span>
  <span class="s1">zip</span><span class="s3">: </span><span class="s1">zip</span><span class="s3">,</span>
  <span class="s1">object</span><span class="s3">: </span><span class="s1">object</span><span class="s3">,</span>
  <span class="s1">range</span><span class="s3">: </span><span class="s1">range</span><span class="s3">,</span>
  <span class="s1">chunk</span><span class="s3">: </span><span class="s1">chunk</span><span class="s3">,</span>
  <span class="s1">mixin</span><span class="s3">: </span><span class="s1">mixin</span><span class="s3">,</span>
  <span class="s4">'default'</span><span class="s3">: </span><span class="s1">_</span>
<span class="s3">};</span>

<span class="s0">// Default Export</span>

<span class="s0">// Add all of the Underscore functions to the wrapper object.</span>
<span class="s2">var </span><span class="s1">_$1 </span><span class="s3">= </span><span class="s1">mixin</span><span class="s3">(</span><span class="s1">allExports</span><span class="s3">);</span>
<span class="s0">// Legacy Node.js API.</span>
<span class="s1">_$1</span><span class="s3">.</span><span class="s1">_ </span><span class="s3">= </span><span class="s1">_$1</span><span class="s3">;</span>

<span class="s0">// ESM Exports</span>

<span class="s2">export default </span><span class="s1">_$1</span><span class="s3">;</span>
<span class="s2">export </span><span class="s3">{ </span><span class="s1">VERSION</span><span class="s3">, </span><span class="s1">after</span><span class="s3">, </span><span class="s1">every </span><span class="s3">as </span><span class="s1">all</span><span class="s3">, </span><span class="s1">allKeys</span><span class="s3">, </span><span class="s1">some </span><span class="s3">as </span><span class="s1">any</span><span class="s3">, </span><span class="s1">extendOwn </span><span class="s3">as </span><span class="s1">assign</span><span class="s3">, </span><span class="s1">before</span><span class="s3">, </span><span class="s1">bind</span><span class="s3">, </span><span class="s1">bindAll</span><span class="s3">, </span><span class="s1">chain</span><span class="s3">, </span><span class="s1">chunk</span><span class="s3">, </span><span class="s1">clone</span><span class="s3">, </span><span class="s1">map </span><span class="s3">as </span><span class="s1">collect</span><span class="s3">, </span><span class="s1">compact</span><span class="s3">, </span><span class="s1">compose</span><span class="s3">, </span><span class="s1">constant</span><span class="s3">, </span><span class="s1">contains</span><span class="s3">, </span><span class="s1">countBy</span><span class="s3">, </span><span class="s1">create</span><span class="s3">, </span><span class="s1">debounce</span><span class="s3">, </span><span class="s1">defaults</span><span class="s3">, </span><span class="s1">defer</span><span class="s3">, </span><span class="s1">delay</span><span class="s3">, </span><span class="s1">find </span><span class="s3">as </span><span class="s1">detect</span><span class="s3">, </span><span class="s1">difference</span><span class="s3">, </span><span class="s1">rest </span><span class="s3">as </span><span class="s1">drop</span><span class="s3">, </span><span class="s1">each</span><span class="s3">, </span><span class="s1">_escape </span><span class="s3">as </span><span class="s1">escape</span><span class="s3">, </span><span class="s1">every</span><span class="s3">, </span><span class="s1">extend</span><span class="s3">, </span><span class="s1">extendOwn</span><span class="s3">, </span><span class="s1">filter</span><span class="s3">, </span><span class="s1">find</span><span class="s3">, </span><span class="s1">findIndex</span><span class="s3">, </span><span class="s1">findKey</span><span class="s3">, </span><span class="s1">findLastIndex</span><span class="s3">, </span><span class="s1">findWhere</span><span class="s3">, </span><span class="s1">first</span><span class="s3">, </span><span class="s1">flatten$1 </span><span class="s3">as </span><span class="s1">flatten</span><span class="s3">, </span><span class="s1">reduce </span><span class="s3">as </span><span class="s1">foldl</span><span class="s3">, </span><span class="s1">reduceRight </span><span class="s3">as </span><span class="s1">foldr</span><span class="s3">, </span><span class="s1">each </span><span class="s3">as </span><span class="s1">forEach</span><span class="s3">, </span><span class="s1">functions</span><span class="s3">, </span><span class="s1">get</span><span class="s3">, </span><span class="s1">groupBy</span><span class="s3">, </span><span class="s1">has$1 </span><span class="s3">as </span><span class="s1">has</span><span class="s3">, </span><span class="s1">first </span><span class="s3">as </span><span class="s1">head</span><span class="s3">, </span><span class="s1">identity</span><span class="s3">, </span><span class="s1">contains </span><span class="s3">as </span><span class="s1">include</span><span class="s3">, </span><span class="s1">contains </span><span class="s3">as </span><span class="s1">includes</span><span class="s3">, </span><span class="s1">indexBy</span><span class="s3">, </span><span class="s1">indexOf</span><span class="s3">, </span><span class="s1">initial</span><span class="s3">, </span><span class="s1">reduce </span><span class="s3">as </span><span class="s1">inject</span><span class="s3">, </span><span class="s1">intersection</span><span class="s3">, </span><span class="s1">invert</span><span class="s3">, </span><span class="s1">invoke</span><span class="s3">, </span><span class="s1">isArguments$1 </span><span class="s3">as </span><span class="s1">isArguments</span><span class="s3">, </span><span class="s1">isArray</span><span class="s3">, </span><span class="s1">isArrayBuffer</span><span class="s3">, </span><span class="s1">isBoolean</span><span class="s3">, </span><span class="s1">isDataView$1 </span><span class="s3">as </span><span class="s1">isDataView</span><span class="s3">, </span><span class="s1">isDate</span><span class="s3">, </span><span class="s1">isElement</span><span class="s3">, </span><span class="s1">isEmpty</span><span class="s3">, </span><span class="s1">isEqual</span><span class="s3">, </span><span class="s1">isError</span><span class="s3">, </span><span class="s1">isFinite$1 </span><span class="s3">as </span><span class="s1">isFinite</span><span class="s3">, </span><span class="s1">isFunction$1 </span><span class="s3">as </span><span class="s1">isFunction</span><span class="s3">, </span><span class="s1">isMap</span><span class="s3">, </span><span class="s1">isMatch</span><span class="s3">, </span><span class="s1">isNaN$1 </span><span class="s3">as </span><span class="s1">isNaN</span><span class="s3">, </span><span class="s1">isNull</span><span class="s3">, </span><span class="s1">isNumber</span><span class="s3">, </span><span class="s1">isObject</span><span class="s3">, </span><span class="s1">isRegExp</span><span class="s3">, </span><span class="s1">isSet</span><span class="s3">, </span><span class="s1">isString</span><span class="s3">, </span><span class="s1">isSymbol</span><span class="s3">, </span><span class="s1">isTypedArray$1 </span><span class="s3">as </span><span class="s1">isTypedArray</span><span class="s3">, </span><span class="s1">isUndefined</span><span class="s3">, </span><span class="s1">isWeakMap</span><span class="s3">, </span><span class="s1">isWeakSet</span><span class="s3">, </span><span class="s1">iteratee</span><span class="s3">, </span><span class="s1">keys</span><span class="s3">, </span><span class="s1">last</span><span class="s3">, </span><span class="s1">lastIndexOf</span><span class="s3">, </span><span class="s1">map</span><span class="s3">, </span><span class="s1">mapObject</span><span class="s3">, </span><span class="s1">matcher</span><span class="s3">, </span><span class="s1">matcher </span><span class="s3">as </span><span class="s1">matches</span><span class="s3">, </span><span class="s1">max</span><span class="s3">, </span><span class="s1">memoize</span><span class="s3">, </span><span class="s1">functions </span><span class="s3">as </span><span class="s1">methods</span><span class="s3">, </span><span class="s1">min</span><span class="s3">, </span><span class="s1">mixin</span><span class="s3">, </span><span class="s1">negate</span><span class="s3">, </span><span class="s1">noop</span><span class="s3">, </span><span class="s1">now</span><span class="s3">, </span><span class="s1">object</span><span class="s3">, </span><span class="s1">omit</span><span class="s3">, </span><span class="s1">once</span><span class="s3">, </span><span class="s1">pairs</span><span class="s3">, </span><span class="s1">partial</span><span class="s3">, </span><span class="s1">partition</span><span class="s3">, </span><span class="s1">pick</span><span class="s3">, </span><span class="s1">pluck</span><span class="s3">, </span><span class="s1">property</span><span class="s3">, </span><span class="s1">propertyOf</span><span class="s3">, </span><span class="s1">random</span><span class="s3">, </span><span class="s1">range</span><span class="s3">, </span><span class="s1">reduce</span><span class="s3">, </span><span class="s1">reduceRight</span><span class="s3">, </span><span class="s1">reject</span><span class="s3">, </span><span class="s1">rest</span><span class="s3">, </span><span class="s1">restArguments</span><span class="s3">, </span><span class="s1">result</span><span class="s3">, </span><span class="s1">sample</span><span class="s3">, </span><span class="s1">filter </span><span class="s3">as </span><span class="s1">select</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">, </span><span class="s1">size</span><span class="s3">, </span><span class="s1">some</span><span class="s3">, </span><span class="s1">sortBy</span><span class="s3">, </span><span class="s1">sortedIndex</span><span class="s3">, </span><span class="s1">rest </span><span class="s3">as </span><span class="s1">tail</span><span class="s3">, </span><span class="s1">first </span><span class="s3">as </span><span class="s1">take</span><span class="s3">, </span><span class="s1">tap</span><span class="s3">, </span><span class="s1">template</span><span class="s3">, </span><span class="s1">templateSettings</span><span class="s3">, </span><span class="s1">throttle</span><span class="s3">, </span><span class="s1">times</span><span class="s3">, </span><span class="s1">toArray</span><span class="s3">, </span><span class="s1">toPath</span><span class="s3">, </span><span class="s1">unzip </span><span class="s3">as </span><span class="s1">transpose</span><span class="s3">, </span><span class="s1">_unescape </span><span class="s3">as </span><span class="s1">unescape</span><span class="s3">, </span><span class="s1">union</span><span class="s3">, </span><span class="s1">uniq</span><span class="s3">, </span><span class="s1">uniq </span><span class="s3">as </span><span class="s1">unique</span><span class="s3">, </span><span class="s1">uniqueId</span><span class="s3">, </span><span class="s1">unzip</span><span class="s3">, </span><span class="s1">values</span><span class="s3">, </span><span class="s1">where</span><span class="s3">, </span><span class="s1">without</span><span class="s3">, </span><span class="s1">wrap</span><span class="s3">, </span><span class="s1">zip </span><span class="s3">};</span>
<span class="s0">//# sourceMappingURL=underscore-esm.js.map</span>
</pre>
</body>
</html>