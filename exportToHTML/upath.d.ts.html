<html>
<head>
<title>upath.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #bcbec4;}
.s3 { color: #5f826b; font-style: italic;}
.s4 { color: #cf8e6d;}
.s5 { color: #67a37c; font-style: italic;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
upath.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">declare module </span><span class="s1">&quot;upath&quot; </span><span class="s2">{</span>

  <span class="s3">/**</span>
   <span class="s3">* A parsed path object generated by path.parse() or consumed by path.format().</span>
   <span class="s3">*/</span>
  <span class="s4">export interface </span><span class="s0">ParsedPath </span><span class="s2">{</span>
    <span class="s3">/**</span>
     <span class="s3">* The root of the path such as '/' or 'c:\'</span>
     <span class="s3">*/</span>
    <span class="s0">root</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The full directory path such as '/home/user/dir' or 'c:\path\dir'</span>
     <span class="s3">*/</span>
    <span class="s0">dir</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The file name including extension (if any) such as 'index.html'</span>
     <span class="s3">*/</span>
    <span class="s0">base</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The file extension (if any) such as '.html'</span>
     <span class="s3">*/</span>
    <span class="s0">ext</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The file name without extension (if any) such as 'index'</span>
     <span class="s3">*/</span>
    <span class="s0">name</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s3">/**</span>
   <span class="s3">* Version of the library</span>
   <span class="s3">*/</span>
  <span class="s4">export var </span><span class="s0">VERSION</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Just converts all `to/` and consolidates duplicates, without performing any normalization.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">p string path to convert to unix.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">toUnix</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Exactly like path.normalize(path), but it keeps the first meaningful ./.</span>
   <span class="s3">*</span>
   <span class="s3">* Note that the unix / is returned everywhere, so windows \ is always converted to unix /.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">p string path to normalize.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">normalizeSafe</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Exactly like path.normalizeSafe(path), but it trims any useless ending /.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">p string path to normalize</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">normalizeTrim</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Exactly like path.join(), but it keeps the first meaningful ./.</span>
   <span class="s3">*</span>
   <span class="s3">* Note that the unix / is returned everywhere, so windows \ is always converted to unix /.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">paths string paths to join</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">joinSafe</span><span class="s2">(</span><span class="s0">...p</span><span class="s2">: </span><span class="s0">any</span><span class="s2">[]): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Adds .ext to filename, but only if it doesn't already have the exact extension.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">file string filename to add extension to</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">ext string extension to add</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">addExt</span><span class="s2">(</span><span class="s0">file</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ext</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Trims a filename's extension.</span>
   <span class="s3">*</span>
   <span class="s3">* Extensions are considered to be up to maxSize chars long, counting the dot (defaults to 7).</span>
   <span class="s3">*</span>
   <span class="s3">* An Array of ignoreExts (eg ['.min']) prevents these from being considered as extension, thus are not trimmed.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">filename string filename to trim it's extension</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">ignoreExts array extensions to ignore</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">maxSize number max length of the extension</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">trimExt</span><span class="s2">(</span><span class="s0">filename</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ignoreExts</span><span class="s2">?: </span><span class="s0">string</span><span class="s2">[], </span><span class="s0">maxSize</span><span class="s2">?: </span><span class="s0">number</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Removes the specific ext extension from filename, if it has it. Otherwise it leaves it as is. As in all upath functions, it be .ext or ext.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">file string filename to remove extension to</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">ext string extension to remove</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">removeExt</span><span class="s2">(</span><span class="s0">filename</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ext</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Changes a filename's extension to ext. If it has no (valid) extension, it adds it.</span>
   <span class="s3">*</span>
   <span class="s3">* Valid extensions are considered to be up to maxSize chars long, counting the dot (defaults to 7).</span>
   <span class="s3">*</span>
   <span class="s3">* An Array of ignoreExts (eg ['.min']) prevents these from being considered as extension, thus are not changed - the new extension is added instead.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">filename string filename to change it's extension</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">ext string extension to change to</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">ignoreExts array extensions to ignore</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">maxSize number max length of the extension</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">changeExt</span><span class="s2">(</span><span class="s0">filename</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ext</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ignoreExts</span><span class="s2">?: </span><span class="s0">string</span><span class="s2">[], </span><span class="s0">maxSize</span><span class="s2">?: </span><span class="s0">number</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Adds .ext to filename, only if it doesn't already have any old extension.</span>
   <span class="s3">*</span>
   <span class="s3">* (Old) extensions are considered to be up to maxSize chars long, counting the dot (defaults to 7).</span>
   <span class="s3">*</span>
   <span class="s3">* An Array of ignoreExts (eg ['.min']) will force adding default .ext even if one of these is present.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">filename string filename to default to it's extension</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">ext string extension to default to</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">ignoreExts array extensions to ignore</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">maxSize number max length of the extension</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">defaultExt</span><span class="s2">(</span><span class="s0">filename</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ext</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ignoreExts</span><span class="s2">?: </span><span class="s0">string</span><span class="s2">[], </span><span class="s0">maxSize</span><span class="s2">?: </span><span class="s0">number</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s3">/**</span>
   <span class="s3">* Normalize a string path, reducing '..' and '.' parts.</span>
   <span class="s3">* When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">p string path to normalize.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">normalize</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Join all arguments together and normalize the resulting path.</span>
   <span class="s3">* Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">paths string paths to join.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">join</span><span class="s2">(</span><span class="s0">...paths</span><span class="s2">: </span><span class="s0">any</span><span class="s2">[]): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Join all arguments together and normalize the resulting path.</span>
   <span class="s3">* Arguments must be strings. In v0.8, non-string arguments were silently ignored. In v0.10 and up, an exception is thrown.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">paths string paths to join.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">join</span><span class="s2">(</span><span class="s0">...paths</span><span class="s2">: </span><span class="s0">string</span><span class="s2">[]): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* The right-most parameter is considered {to}.  Other parameters are considered an array of {from}.</span>
   <span class="s3">*</span>
   <span class="s3">* Starting from leftmost {from} parameter, resolves {to} to an absolute path.</span>
   <span class="s3">*</span>
   <span class="s3">* If {to} isn't already absolute, {from} arguments are prepended in right to left order, until an absolute path is found. If after using all {from} paths still no absolute path is found, the current working directory is used as well. The resulting path is normalized, and trailing slashes are removed unless the path gets resolved to the root directory.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">pathSegments string paths to join.  Non-string arguments are ignored.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">resolve</span><span class="s2">(</span><span class="s0">...pathSegments</span><span class="s2">: </span><span class="s0">any</span><span class="s2">[]): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">path path to test.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">isAbsolute</span><span class="s2">(</span><span class="s0">path</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">boolean</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Solve the relative path from {from} to {to}.</span>
   <span class="s3">* At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">from</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">to</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">relative</span><span class="s2">(</span><span class="s0">from</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">to</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Return the directory name of a path. Similar to the Unix dirname command.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">p the path to evaluate.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">dirname</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Return the last portion of a path. Similar to the Unix basename command.</span>
   <span class="s3">* Often used to extract the file name from a fully qualified path.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">p the path to evaluate.</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">ext optionally, an extension to remove from the result.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">basename</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ext</span><span class="s2">?: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Return the extension of the path, from the last '.' to end of string in the last portion of the path.</span>
   <span class="s3">* If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">p the path to evaluate.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">extname</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* The platform-specific file separator. '\\' or '/'.</span>
   <span class="s3">*/</span>
  <span class="s4">export var </span><span class="s0">sep</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* The platform-specific file delimiter. ';' or ':'.</span>
   <span class="s3">*/</span>
  <span class="s4">export var </span><span class="s0">delimiter</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Returns an object from a path string - the opposite of format().</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">pathString path to evaluate.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">parse</span><span class="s2">(</span><span class="s0">pathString</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">ParsedPath</span><span class="s2">;</span>
  <span class="s3">/**</span>
   <span class="s3">* Returns a path string from an object - the opposite of parse().</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">pathString path to evaluate.</span>
   <span class="s3">*/</span>
  <span class="s4">export function </span><span class="s0">format</span><span class="s2">(</span><span class="s0">pathObject</span><span class="s2">: </span><span class="s0">ParsedPath</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>

  <span class="s4">export </span><span class="s0">module posix </span><span class="s2">{</span>
    <span class="s4">export function </span><span class="s0">normalize</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">join</span><span class="s2">(</span><span class="s0">...paths</span><span class="s2">: </span><span class="s0">any</span><span class="s2">[]): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">resolve</span><span class="s2">(</span><span class="s0">...pathSegments</span><span class="s2">: </span><span class="s0">any</span><span class="s2">[]): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">isAbsolute</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">boolean</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">relative</span><span class="s2">(</span><span class="s0">from</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">to</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">dirname</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">basename</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ext</span><span class="s2">?: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">extname</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export var </span><span class="s0">sep</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export var </span><span class="s0">delimiter</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">parse</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">ParsedPath</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">format</span><span class="s2">(</span><span class="s0">pP</span><span class="s2">: </span><span class="s0">ParsedPath</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s4">export </span><span class="s0">module win32 </span><span class="s2">{</span>
    <span class="s4">export function </span><span class="s0">normalize</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">join</span><span class="s2">(</span><span class="s0">...paths</span><span class="s2">: </span><span class="s0">any</span><span class="s2">[]): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">resolve</span><span class="s2">(</span><span class="s0">...pathSegments</span><span class="s2">: </span><span class="s0">any</span><span class="s2">[]): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">isAbsolute</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">boolean</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">relative</span><span class="s2">(</span><span class="s0">from</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">to</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">dirname</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">basename</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">, </span><span class="s0">ext</span><span class="s2">?: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">extname</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export var </span><span class="s0">sep</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export var </span><span class="s0">delimiter</span><span class="s2">: </span><span class="s0">string</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">parse</span><span class="s2">(</span><span class="s0">p</span><span class="s2">: </span><span class="s0">string</span><span class="s2">): </span><span class="s0">ParsedPath</span><span class="s2">;</span>
    <span class="s4">export function </span><span class="s0">format</span><span class="s2">(</span><span class="s0">pP</span><span class="s2">: </span><span class="s0">ParsedPath</span><span class="s2">): </span><span class="s0">string</span><span class="s2">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
</pre>
</body>
</html>