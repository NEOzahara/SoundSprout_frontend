<html>
<head>
<title>valueToNode.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
valueToNode.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_isValidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_index&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;valueToNode&quot;</span><span class="s0">,</span><span class="s1">&quot;objectToString&quot;</span><span class="s0">,</span><span class="s1">&quot;Function&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;isRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;isPlainObject&quot;</span><span class="s0">,</span><span class="s1">&quot;proto&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrototypeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;booleanLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;nullLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinite&quot;</span><span class="s0">,</span><span class="s1">&quot;numericLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;abs&quot;</span><span class="s0">,</span><span class="s1">&quot;numerator&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;binaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;is&quot;</span><span class="s0">,</span><span class="s1">&quot;unaryExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;bigIntLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;regExpLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;computed&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;objectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;objectExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/converters/valueToNode.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import isValidIdentifier from </span><span class="s3">\&quot;</span><span class="s1">../validators/isValidIdentifier.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">identifier,</span><span class="s3">\n  </span><span class="s1">booleanLiteral,</span><span class="s3">\n  </span><span class="s1">nullLiteral,</span><span class="s3">\n  </span><span class="s1">stringLiteral,</span><span class="s3">\n  </span><span class="s1">numericLiteral,</span><span class="s3">\n  </span><span class="s1">bigIntLiteral,</span><span class="s3">\n  </span><span class="s1">regExpLiteral,</span><span class="s3">\n  </span><span class="s1">arrayExpression,</span><span class="s3">\n  </span><span class="s1">objectProperty,</span><span class="s3">\n  </span><span class="s1">objectExpression,</span><span class="s3">\n  </span><span class="s1">unaryExpression,</span><span class="s3">\n  </span><span class="s1">binaryExpression,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">../builders/generated/index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type * as t from </span><span class="s3">\&quot;</span><span class="s1">../index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export default valueToNode as {</span><span class="s3">\n  </span><span class="s1">(value: undefined): t.Identifier; // TODO: This should return </span><span class="s3">\&quot;</span><span class="s1">void 0</span><span class="s3">\&quot;\n  </span><span class="s1">(value: boolean): t.BooleanLiteral;</span><span class="s3">\n  </span><span class="s1">(value: null): t.NullLiteral;</span><span class="s3">\n  </span><span class="s1">(value: string): t.StringLiteral;</span><span class="s3">\n  </span><span class="s1">// Infinities and NaN need to use a BinaryExpression; negative values must be wrapped in UnaryExpression</span><span class="s3">\n  </span><span class="s1">(value: number): t.NumericLiteral | t.BinaryExpression | t.UnaryExpression;</span><span class="s3">\n  </span><span class="s1">(value: bigint): t.BigIntLiteral;</span><span class="s3">\n  </span><span class="s1">(value: RegExp): t.RegExpLiteral;</span><span class="s3">\n  </span><span class="s1">(value: ReadonlyArray&lt;unknown&gt;): t.ArrayExpression;</span><span class="s3">\n\n  </span><span class="s1">// this throws with objects that are not plain objects,</span><span class="s3">\n  </span><span class="s1">// or if there are non-valueToNode-able values</span><span class="s3">\n  </span><span class="s1">(value: object): t.ObjectExpression;</span><span class="s3">\n\n  </span><span class="s1">(value: unknown): t.Expression;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// @ts-expect-error: Object.prototype.toString must return a string</span><span class="s3">\n</span><span class="s1">const objectToString: (value: unknown) =&gt; string = Function.call.bind(</span><span class="s3">\n  </span><span class="s1">Object.prototype.toString,</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">function isRegExp(value: unknown): value is RegExp {</span><span class="s3">\n  </span><span class="s1">return objectToString(value) === </span><span class="s3">\&quot;</span><span class="s1">[object RegExp]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isPlainObject(value: unknown): value is object {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof value !== </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n    </span><span class="s1">value === null ||</span><span class="s3">\n    </span><span class="s1">Object.prototype.toString.call(value) !== </span><span class="s3">\&quot;</span><span class="s1">[object Object]</span><span class="s3">\&quot;\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const proto = Object.getPrototypeOf(value);</span><span class="s3">\n  </span><span class="s1">// Object.prototype's __proto__ is null. Every other class's __proto__.__proto__ is</span><span class="s3">\n  </span><span class="s1">// not null by default. We cannot check if proto === Object.prototype because it</span><span class="s3">\n  </span><span class="s1">// could come from another realm.</span><span class="s3">\n  </span><span class="s1">return proto === null || Object.getPrototypeOf(proto) === null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function valueToNode(value: unknown): t.Expression {</span><span class="s3">\n  </span><span class="s1">// undefined</span><span class="s3">\n  </span><span class="s1">if (value === undefined) {</span><span class="s3">\n    </span><span class="s1">return identifier(</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// boolean</span><span class="s3">\n  </span><span class="s1">if (value === true || value === false) {</span><span class="s3">\n    </span><span class="s1">return booleanLiteral(value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// null</span><span class="s3">\n  </span><span class="s1">if (value === null) {</span><span class="s3">\n    </span><span class="s1">return nullLiteral();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// strings</span><span class="s3">\n  </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return stringLiteral(value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// numbers</span><span class="s3">\n  </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let result;</span><span class="s3">\n    </span><span class="s1">if (Number.isFinite(value)) {</span><span class="s3">\n      </span><span class="s1">result = numericLiteral(Math.abs(value));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">let numerator;</span><span class="s3">\n      </span><span class="s1">if (Number.isNaN(value)) {</span><span class="s3">\n        </span><span class="s1">// NaN</span><span class="s3">\n        </span><span class="s1">numerator = numericLiteral(0);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Infinity / -Infinity</span><span class="s3">\n        </span><span class="s1">numerator = numericLiteral(1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">result = binaryExpression(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">, numerator, numericLiteral(0));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (value &lt; 0 || Object.is(value, -0)) {</span><span class="s3">\n      </span><span class="s1">result = unaryExpression(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">, result);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// bigints</span><span class="s3">\n  </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return bigIntLiteral(value.toString());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// regexes</span><span class="s3">\n  </span><span class="s1">if (isRegExp(value)) {</span><span class="s3">\n    </span><span class="s1">const pattern = value.source;</span><span class="s3">\n    </span><span class="s1">const flags = /</span><span class="s3">\\</span><span class="s1">/([a-z]*)$/.exec(value.toString())[1];</span><span class="s3">\n    </span><span class="s1">return regExpLiteral(pattern, flags);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// array</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">return arrayExpression(value.map(valueToNode));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// object</span><span class="s3">\n  </span><span class="s1">if (isPlainObject(value)) {</span><span class="s3">\n    </span><span class="s1">const props = [];</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(value)) {</span><span class="s3">\n      </span><span class="s1">let nodeKey,</span><span class="s3">\n        </span><span class="s1">computed = false;</span><span class="s3">\n      </span><span class="s1">if (isValidIdentifier(key)) {</span><span class="s3">\n        </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">computed = true;</span><span class="s3">\n          </span><span class="s1">nodeKey = stringLiteral(key);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">nodeKey = identifier(key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">nodeKey = stringLiteral(key);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">props.push(</span><span class="s3">\n        </span><span class="s1">objectProperty(</span><span class="s3">\n          </span><span class="s1">nodeKey,</span><span class="s3">\n          </span><span class="s1">valueToNode(</span><span class="s3">\n            </span><span class="s1">// @ts-expect-error key must present in value</span><span class="s3">\n            </span><span class="s1">value[key],</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">computed,</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return objectExpression(props);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">don't know how to turn this value into a node</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>