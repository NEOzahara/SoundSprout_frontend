<html>
<head>
<title>visitors.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
visitors.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;virtualTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;virtualTypesValidators&quot;</span><span class="s0">,</span><span class="s1">&quot;_t&quot;</span><span class="s0">,</span><span class="s1">&quot;_context&quot;</span><span class="s0">,</span><span class="s1">&quot;DEPRECATED_KEYS&quot;</span><span class="s0">,</span><span class="s1">&quot;DEPRECATED_ALIASES&quot;</span><span class="s0">,</span><span class="s1">&quot;FLIPPED_ALIAS_KEYS&quot;</span><span class="s0">,</span><span class="s1">&quot;TYPES&quot;</span><span class="s0">,</span><span class="s1">&quot;__internal__deprecationWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;deprecationWarning&quot;</span><span class="s0">,</span><span class="s1">&quot;isVirtualType&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;isExplodedVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;_exploded&quot;</span><span class="s0">,</span><span class="s1">&quot;explode$1&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeType&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldIgnoreKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parts&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;fns&quot;</span><span class="s0">,</span><span class="s1">&quot;part&quot;</span><span class="s0">,</span><span class="s1">&quot;verify$1&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureEntranceObjects&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureCallbackArrays&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapCheck&quot;</span><span class="s0">,</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;mergePair&quot;</span><span class="s0">,</span><span class="s1">&quot;aliases&quot;</span><span class="s0">,</span><span class="s1">&quot;deprecatedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;deprecatedAlias&quot;</span><span class="s0">,</span><span class="s1">&quot;alias&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;_verified&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;validateVisitorMethods&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;visitors&quot;</span><span class="s0">,</span><span class="s1">&quot;visitorKey&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;states&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;mergedVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;topVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapWithStateOrWrapper&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;typeVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;oldVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;newVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;newFn&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;enter&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;fnKey&quot;</span><span class="s0">,</span><span class="s1">&quot;validator&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;dest&quot;</span><span class="s0">,</span><span class="s1">&quot;src&quot;</span><span class="s0">,</span><span class="s1">&quot;_environmentVisitor&quot;</span><span class="s0">,</span><span class="s1">&quot;FunctionParent&quot;</span><span class="s0">,</span><span class="s1">&quot;isArrowFunctionExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;skip&quot;</span><span class="s0">,</span><span class="s1">&quot;isMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;requeueComputedKeyAndDecorators&quot;</span><span class="s0">,</span><span class="s1">&quot;Property&quot;</span><span class="s0">,</span><span class="s1">&quot;isObjectProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentVisitor&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/visitors.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import * as virtualTypes from </span><span class="s3">\&quot;</span><span class="s1">./path/lib/virtual-types.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import * as virtualTypesValidators from </span><span class="s3">\&quot;</span><span class="s1">./path/lib/virtual-types-validator.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { Node } from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">DEPRECATED_KEYS,</span><span class="s3">\n  </span><span class="s1">DEPRECATED_ALIASES,</span><span class="s3">\n  </span><span class="s1">FLIPPED_ALIAS_KEYS,</span><span class="s3">\n  </span><span class="s1">TYPES,</span><span class="s3">\n  </span><span class="s1">__internal__deprecationWarning as deprecationWarning,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">@babel/types</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { ExplodedVisitor, NodePath, Visitor } from </span><span class="s3">\&quot;</span><span class="s1">./index.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import type { ExplVisitNode, VisitNodeFunction, VisitPhase } from </span><span class="s3">\&quot;</span><span class="s1">./types.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { requeueComputedKeyAndDecorators } from </span><span class="s3">\&quot;</span><span class="s1">./path/context.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">type VIRTUAL_TYPES = keyof typeof virtualTypes;</span><span class="s3">\n</span><span class="s1">function isVirtualType(type: string): type is VIRTUAL_TYPES {</span><span class="s3">\n  </span><span class="s1">return type in virtualTypes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export type VisitWrapper&lt;S = any&gt; = (</span><span class="s3">\n  </span><span class="s1">stateName: string | undefined,</span><span class="s3">\n  </span><span class="s1">visitorType: VisitPhase,</span><span class="s3">\n  </span><span class="s1">callback: VisitNodeFunction&lt;S, Node&gt;,</span><span class="s3">\n</span><span class="s1">) =&gt; VisitNodeFunction&lt;S, Node&gt;;</span><span class="s3">\n\n</span><span class="s1">export function isExplodedVisitor(</span><span class="s3">\n  </span><span class="s1">visitor: Visitor,</span><span class="s3">\n</span><span class="s1">): visitor is ExplodedVisitor {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error _exploded is not defined on non-exploded Visitor</span><span class="s3">\n  </span><span class="s1">return visitor?._exploded;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We need to name this function `explode$1` because otherwise rollup-plugin-dts</span><span class="s3">\n</span><span class="s1">// will generate a `namespace traverse { var explode: typeof explode; }` when</span><span class="s3">\n</span><span class="s1">// bundling @babel/traverse's index.d.ts.</span><span class="s3">\n</span><span class="s1">// TODO: Just call it `explode` once https://github.com/Swatinem/rollup-plugin-dts/issues/307</span><span class="s3">\n</span><span class="s1">// is fixed.</span><span class="s3">\n</span><span class="s1">export { explode$1 as explode };</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* explode() will take a visitor object with all of the various shorthands</span><span class="s3">\n </span><span class="s1">* that we support, and validates &amp; normalizes it into a common format, ready</span><span class="s3">\n </span><span class="s1">* to be used in traversal</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The various shorthands are:</span><span class="s3">\n </span><span class="s1">* * `Identifier() { ... }` -&gt; `Identifier: { enter() { ... } }`</span><span class="s3">\n </span><span class="s1">* * `</span><span class="s3">\&quot;</span><span class="s1">Identifier|NumericLiteral</span><span class="s3">\&quot;</span><span class="s1">: { ... }` -&gt; `Identifier: { ... }, NumericLiteral: { ... }`</span><span class="s3">\n </span><span class="s1">* * Aliases in `@babel/types`: e.g. `Property: { ... }` -&gt; `ObjectProperty: { ... }, ClassProperty: { ... }`</span><span class="s3">\n </span><span class="s1">* Other normalizations are:</span><span class="s3">\n </span><span class="s1">* * Visitors of virtual types are wrapped, so that they are only visited when</span><span class="s3">\n </span><span class="s1">*   their dynamic check passes</span><span class="s3">\n </span><span class="s1">* * `enter` and `exit` functions are wrapped in arrays, to ease merging of</span><span class="s3">\n </span><span class="s1">*   visitors</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function explode$1&lt;S&gt;(visitor: Visitor&lt;S&gt;): ExplodedVisitor&lt;S&gt; {</span><span class="s3">\n  </span><span class="s1">if (isExplodedVisitor(visitor)) return visitor;</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error `visitor` will be cast to ExplodedVisitor by this function</span><span class="s3">\n  </span><span class="s1">visitor._exploded = true;</span><span class="s3">\n\n  </span><span class="s1">// normalise pipes</span><span class="s3">\n  </span><span class="s1">for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">const parts: Array&lt;string&gt; = nodeType.split(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (parts.length === 1) continue;</span><span class="s3">\n\n    </span><span class="s1">const fns = visitor[nodeType];</span><span class="s3">\n    </span><span class="s1">delete visitor[nodeType];</span><span class="s3">\n\n    </span><span class="s1">for (const part of parts) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error part will be verified by `verify` later</span><span class="s3">\n      </span><span class="s1">visitor[part] = fns;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// verify data structure</span><span class="s3">\n  </span><span class="s1">verify$1(visitor);</span><span class="s3">\n\n  </span><span class="s1">// make sure there's no __esModule type since this is because we're using loose mode</span><span class="s3">\n  </span><span class="s1">// and it sets __esModule to be enumerable on all modules :(</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error ESModule interop</span><span class="s3">\n  </span><span class="s1">delete visitor.__esModule;</span><span class="s3">\n\n  </span><span class="s1">// ensure visitors are objects</span><span class="s3">\n  </span><span class="s1">ensureEntranceObjects(visitor);</span><span class="s3">\n\n  </span><span class="s1">// ensure enter/exit callbacks are arrays</span><span class="s3">\n  </span><span class="s1">ensureCallbackArrays(visitor);</span><span class="s3">\n\n  </span><span class="s1">// add type wrappers</span><span class="s3">\n  </span><span class="s1">for (const nodeType of Object.keys(visitor)) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">if (!isVirtualType(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">// wrap all the functions</span><span class="s3">\n    </span><span class="s1">const fns = visitor[nodeType];</span><span class="s3">\n    </span><span class="s1">for (const type of Object.keys(fns)) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error normalised as VisitNodeObject</span><span class="s3">\n      </span><span class="s1">fns[type] = wrapCheck(nodeType, fns[type]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// clear it from the visitor</span><span class="s3">\n    </span><span class="s1">delete visitor[nodeType];</span><span class="s3">\n\n    </span><span class="s1">const types = virtualTypes[nodeType];</span><span class="s3">\n    </span><span class="s1">if (types !== null) {</span><span class="s3">\n      </span><span class="s1">for (const type of types) {</span><span class="s3">\n        </span><span class="s1">// merge the visitor if necessary or just put it back in</span><span class="s3">\n        </span><span class="s1">if (visitor[type]) {</span><span class="s3">\n          </span><span class="s1">mergePair(visitor[type], fns);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error Expression produces too complex union</span><span class="s3">\n          </span><span class="s1">visitor[type] = fns;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">mergePair(visitor, fns);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add aliases</span><span class="s3">\n  </span><span class="s1">for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">let aliases = FLIPPED_ALIAS_KEYS[nodeType];</span><span class="s3">\n\n    </span><span class="s1">if (nodeType in DEPRECATED_KEYS) {</span><span class="s3">\n      </span><span class="s1">const deprecatedKey = DEPRECATED_KEYS[nodeType];</span><span class="s3">\n      </span><span class="s1">deprecationWarning(nodeType, deprecatedKey, </span><span class="s3">\&quot;</span><span class="s1">Visitor </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">aliases = [deprecatedKey];</span><span class="s3">\n    </span><span class="s1">} else if (nodeType in DEPRECATED_ALIASES) {</span><span class="s3">\n      </span><span class="s1">const deprecatedAlias =</span><span class="s3">\n        </span><span class="s1">DEPRECATED_ALIASES[nodeType as keyof typeof DEPRECATED_ALIASES];</span><span class="s3">\n      </span><span class="s1">deprecationWarning(nodeType, deprecatedAlias, </span><span class="s3">\&quot;</span><span class="s1">Visitor </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!aliases) continue;</span><span class="s3">\n\n    </span><span class="s1">const fns = visitor[nodeType];</span><span class="s3">\n    </span><span class="s1">// clear it from the visitor</span><span class="s3">\n    </span><span class="s1">delete visitor[nodeType];</span><span class="s3">\n\n    </span><span class="s1">for (const alias of aliases) {</span><span class="s3">\n      </span><span class="s1">const existing = visitor[alias];</span><span class="s3">\n      </span><span class="s1">if (existing) {</span><span class="s3">\n        </span><span class="s1">mergePair(existing, fns);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">visitor[alias] = { ...fns };</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const nodeType of Object.keys(visitor)) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">ensureCallbackArrays(</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error nodeType must present in visitor after previous validations</span><span class="s3">\n      </span><span class="s1">visitor[nodeType],</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error explosion has been performed</span><span class="s3">\n  </span><span class="s1">return visitor as ExplodedVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We need to name this function `verify$1` because otherwise rollup-plugin-dts</span><span class="s3">\n</span><span class="s1">// will generate a `namespace traverse { var verify: typeof verify; }` when</span><span class="s3">\n</span><span class="s1">// bundling @babel/traverse's index.d.ts.</span><span class="s3">\n</span><span class="s1">// TODO: Just call it `verify` once https://github.com/Swatinem/rollup-plugin-dts/issues/307</span><span class="s3">\n</span><span class="s1">// is fixed.</span><span class="s3">\n</span><span class="s1">export { verify$1 as verify };</span><span class="s3">\n</span><span class="s1">function verify$1(visitor: Visitor) {</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error _verified is not defined on non-verified Visitor.</span><span class="s3">\n  </span><span class="s1">// TODO: unify _verified and _exploded.</span><span class="s3">\n  </span><span class="s1">if (visitor._verified) return;</span><span class="s3">\n\n  </span><span class="s1">if (typeof visitor === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      \&quot;</span><span class="s1">You passed `traverse()` a function when it expected a visitor object, </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;</span><span class="s1">are you sure you didn't mean `{ enter: Function }`?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {</span><span class="s3">\n    </span><span class="s1">if (nodeType === </span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot; </span><span class="s1">|| nodeType === </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">validateVisitorMethods(nodeType, visitor[nodeType]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (shouldIgnoreKey(nodeType)) continue;</span><span class="s3">\n\n    </span><span class="s1">if (!TYPES.includes(nodeType)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${PACKAGE_JSON.version}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const visitors = visitor[nodeType];</span><span class="s3">\n    </span><span class="s1">if (typeof visitors === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">for (const visitorKey of Object.keys(visitors)) {</span><span class="s3">\n        </span><span class="s1">if (visitorKey === </span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot; </span><span class="s1">|| visitorKey === </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// verify that it just contains functions</span><span class="s3">\n          </span><span class="s1">validateVisitorMethods(</span><span class="s3">\n            </span><span class="s1">`${nodeType}.${visitorKey}`,</span><span class="s3">\n            </span><span class="s1">visitors[visitorKey],</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            \&quot;</span><span class="s1">You passed `traverse()` a visitor object with the property </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n              </span><span class="s1">`${nodeType} that has the invalid property ${visitorKey}`,</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @ts-expect-error _verified is not defined on non-verified Visitor.</span><span class="s3">\n  </span><span class="s1">// TODO: unify _verified and _exploded.</span><span class="s3">\n  </span><span class="s1">visitor._verified = true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function validateVisitorMethods(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">val: any,</span><span class="s3">\n</span><span class="s1">): asserts val is Function | Function[] {</span><span class="s3">\n  </span><span class="s1">const fns = [].concat(val);</span><span class="s3">\n  </span><span class="s1">for (const fn of fns) {</span><span class="s3">\n    </span><span class="s1">if (typeof fn !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(</span><span class="s3">\n        </span><span class="s1">`Non-function found defined in ${path} with type ${typeof fn}`,</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function merge&lt;State&gt;(</span><span class="s3">\n  </span><span class="s1">visitors: Visitor&lt;State&gt;[],</span><span class="s3">\n</span><span class="s1">): ExplodedVisitor&lt;State&gt;;</span><span class="s3">\n</span><span class="s1">export function merge(</span><span class="s3">\n  </span><span class="s1">visitors: Visitor&lt;unknown&gt;[],</span><span class="s3">\n  </span><span class="s1">states?: any[],</span><span class="s3">\n  </span><span class="s1">wrapper?: Function | null,</span><span class="s3">\n</span><span class="s1">): ExplodedVisitor&lt;unknown&gt;;</span><span class="s3">\n</span><span class="s1">export function merge(</span><span class="s3">\n  </span><span class="s1">visitors: any[],</span><span class="s3">\n  </span><span class="s1">states: any[] = [],</span><span class="s3">\n  </span><span class="s1">wrapper?: VisitWrapper | null,</span><span class="s3">\n</span><span class="s1">): ExplodedVisitor {</span><span class="s3">\n  </span><span class="s1">const mergedVisitor: ExplodedVisitor = { _verified: true, _exploded: true };</span><span class="s3">\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">// For compatibility with old Babel versions, we must hide _verified and _exploded.</span><span class="s3">\n    </span><span class="s1">// Otherwise, old versions of the validator will throw sayng that `true` is not</span><span class="s3">\n    </span><span class="s1">// a function, because it tries to validate it as a visitor.</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(mergedVisitor, </span><span class="s3">\&quot;</span><span class="s1">_exploded</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: false });</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(mergedVisitor, </span><span class="s3">\&quot;</span><span class="s1">_verified</span><span class="s3">\&quot;</span><span class="s1">, { enumerable: false });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; visitors.length; i++) {</span><span class="s3">\n    </span><span class="s1">const visitor = explode$1(visitors[i]);</span><span class="s3">\n    </span><span class="s1">const state = states[i];</span><span class="s3">\n\n    </span><span class="s1">let topVisitor: ExplVisitNode&lt;unknown, Node&gt; = visitor;</span><span class="s3">\n    </span><span class="s1">if (state || wrapper) {</span><span class="s3">\n      </span><span class="s1">topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mergePair(mergedVisitor, topVisitor);</span><span class="s3">\n\n    </span><span class="s1">for (const key of Object.keys(visitor) as (keyof ExplodedVisitor)[]) {</span><span class="s3">\n      </span><span class="s1">if (shouldIgnoreKey(key)) continue;</span><span class="s3">\n\n      </span><span class="s1">let typeVisitor = visitor[key];</span><span class="s3">\n\n      </span><span class="s1">// if we have state or wrapper then overload the callbacks to take it</span><span class="s3">\n      </span><span class="s1">if (state || wrapper) {</span><span class="s3">\n        </span><span class="s1">typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const nodeVisitor = (mergedVisitor[key] ||= {});</span><span class="s3">\n      </span><span class="s1">mergePair(nodeVisitor, typeVisitor);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return mergedVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function wrapWithStateOrWrapper&lt;State&gt;(</span><span class="s3">\n  </span><span class="s1">oldVisitor: ExplVisitNode&lt;State, Node&gt;,</span><span class="s3">\n  </span><span class="s1">state: State | null,</span><span class="s3">\n  </span><span class="s1">wrapper?: VisitWrapper&lt;State&gt; | null,</span><span class="s3">\n</span><span class="s1">): ExplVisitNode&lt;State, Node&gt; {</span><span class="s3">\n  </span><span class="s1">const newVisitor: ExplVisitNode&lt;State, Node&gt; = {};</span><span class="s3">\n\n  </span><span class="s1">for (const phase of [</span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">] as VisitPhase[]) {</span><span class="s3">\n    </span><span class="s1">let fns = oldVisitor[phase];</span><span class="s3">\n\n    </span><span class="s1">// not an enter/exit array of callbacks</span><span class="s3">\n    </span><span class="s1">if (!Array.isArray(fns)) continue;</span><span class="s3">\n\n    </span><span class="s1">fns = fns.map(function (fn) {</span><span class="s3">\n      </span><span class="s1">let newFn = fn;</span><span class="s3">\n\n      </span><span class="s1">if (state) {</span><span class="s3">\n        </span><span class="s1">newFn = function (path: NodePath) {</span><span class="s3">\n          </span><span class="s1">fn.call(state, path, state);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (wrapper) {</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error Fixme: actually PluginPass.key (aka pluginAlias)?</span><span class="s3">\n        </span><span class="s1">newFn = wrapper(state?.key, phase, newFn);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Override toString in case this function is printed, we want to print the wrapped function, same as we do in `wrapCheck`</span><span class="s3">\n      </span><span class="s1">if (newFn !== fn) {</span><span class="s3">\n        </span><span class="s1">newFn.toString = () =&gt; fn.toString();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return newFn;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">newVisitor[phase] = fns;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return newVisitor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ensureEntranceObjects(obj: Visitor) {</span><span class="s3">\n  </span><span class="s1">for (const key of Object.keys(obj) as (keyof Visitor)[]) {</span><span class="s3">\n    </span><span class="s1">if (shouldIgnoreKey(key)) continue;</span><span class="s3">\n\n    </span><span class="s1">const fns = obj[key];</span><span class="s3">\n    </span><span class="s1">if (typeof fns === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error: Expression produces a union type that is too complex to represent.</span><span class="s3">\n      </span><span class="s1">obj[key] = { enter: fns };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ensureCallbackArrays(obj: Visitor) {</span><span class="s3">\n  </span><span class="s1">if (obj.enter &amp;&amp; !Array.isArray(obj.enter)) obj.enter = [obj.enter];</span><span class="s3">\n  </span><span class="s1">if (obj.exit &amp;&amp; !Array.isArray(obj.exit)) obj.exit = [obj.exit];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function wrapCheck(nodeType: VIRTUAL_TYPES, fn: Function) {</span><span class="s3">\n  </span><span class="s1">const fnKey = `is${nodeType}`;</span><span class="s3">\n  </span><span class="s1">// @ts-expect-error we know virtualTypesValidators will contain `fnKey`, but TS doesn't</span><span class="s3">\n  </span><span class="s1">const validator = virtualTypesValidators[fnKey];</span><span class="s3">\n  </span><span class="s1">const newFn = function (this: unknown, path: NodePath) {</span><span class="s3">\n    </span><span class="s1">if (validator.call(path)) {</span><span class="s3">\n      </span><span class="s1">return fn.apply(this, arguments);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">newFn.toString = () =&gt; fn.toString();</span><span class="s3">\n  </span><span class="s1">return newFn;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function shouldIgnoreKey(key: string): key is</span><span class="s3">\n  </span><span class="s1">| `_${string}` // ` // Comment to fix syntax highlighting in vscode</span><span class="s3">\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">shouldSkip</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">denylist</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">noScope</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">skipKeys</span><span class="s3">\&quot;\n  </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">blacklist</span><span class="s3">\&quot; </span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">// internal/hidden key</span><span class="s3">\n  </span><span class="s1">if (key[0] === </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">) return true;</span><span class="s3">\n\n  </span><span class="s1">// ignore function keys</span><span class="s3">\n  </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">shouldSkip</span><span class="s3">\&quot;</span><span class="s1">) return true;</span><span class="s3">\n\n  </span><span class="s1">// ignore other options</span><span class="s3">\n  </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">denylist</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">noScope</span><span class="s3">\&quot; </span><span class="s1">|| key === </span><span class="s3">\&quot;</span><span class="s1">skipKeys</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.BABEL_8_BREAKING) {</span><span class="s3">\n    </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">blacklist</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n</span><span class="s1">function mergePair(</span><span class="s3">\n  </span><span class="s1">dest: ExplVisitNode&lt;unknown, Node&gt;,</span><span class="s3">\n  </span><span class="s1">src: ExplVisitNode&lt;unknown, Node&gt;,</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mergePair(dest: any, src: any) {</span><span class="s3">\n  </span><span class="s1">for (const phase of [</span><span class="s3">\&quot;</span><span class="s1">enter</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">] as VisitPhase[]) {</span><span class="s3">\n    </span><span class="s1">if (!src[phase]) continue;</span><span class="s3">\n    </span><span class="s1">dest[phase] = [].concat(dest[phase] || [], src[phase]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// environmentVisitor should be used when traversing the whole class and not for specific class elements/methods.</span><span class="s3">\n</span><span class="s1">// For perf reasons, the environmentVisitor might be traversed with `{ noScope: true }`, which means `path.scope` is undefined.</span><span class="s3">\n</span><span class="s1">// Avoid using `path.scope` here</span><span class="s3">\n</span><span class="s1">const _environmentVisitor: Visitor = {</span><span class="s3">\n  </span><span class="s1">FunctionParent(path) {</span><span class="s3">\n    </span><span class="s1">// arrows are not skipped because they inherit the context.</span><span class="s3">\n    </span><span class="s1">if (path.isArrowFunctionExpression()) return;</span><span class="s3">\n\n    </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">if (path.isMethod()) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!process.env.BABEL_8_BREAKING &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!path.requeueComputedKeyAndDecorators</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// See https://github.com/babel/babel/issues/16694</span><span class="s3">\n        </span><span class="s1">requeueComputedKeyAndDecorators.call(path);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">path.requeueComputedKeyAndDecorators();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">Property(path) {</span><span class="s3">\n    </span><span class="s1">if (path.isObjectProperty()) return;</span><span class="s3">\n    </span><span class="s1">path.skip();</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!process.env.BABEL_8_BREAKING &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!path.requeueComputedKeyAndDecorators</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// See https://github.com/babel/babel/issues/16694</span><span class="s3">\n      </span><span class="s1">requeueComputedKeyAndDecorators.call(path);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">path.requeueComputedKeyAndDecorators();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export function environmentVisitor&lt;S&gt;(visitor: Visitor&lt;S&gt;): Visitor&lt;S&gt; {</span><span class="s3">\n  </span><span class="s1">return merge([_environmentVisitor, visitor]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>