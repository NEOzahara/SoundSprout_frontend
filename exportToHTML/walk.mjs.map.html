<html>
<head>
<title>walk.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
walk.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;walk.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../src/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// AST walker module for Mozilla Parser API compatible trees</span><span class="s3">\n\n</span><span class="s1">// A simple walk is one where you simply specify callbacks to be</span><span class="s3">\n</span><span class="s1">// called on specific nodes. The last two arguments are optional. A</span><span class="s3">\n</span><span class="s1">// simple use would be</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//     walk.simple(myTree, {</span><span class="s3">\n</span><span class="s1">//         Expression: function(node) { ... }</span><span class="s3">\n</span><span class="s1">//     });</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// to do something with all expressions. All Parser API node types</span><span class="s3">\n</span><span class="s1">// can be used to identify node types, as well as Expression and</span><span class="s3">\n</span><span class="s1">// Statement, which denote categories of nodes.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The base argument can be used to pass a custom (recursive)</span><span class="s3">\n</span><span class="s1">// walker, and state can be used to give this walked an initial</span><span class="s3">\n</span><span class="s1">// state.</span><span class="s3">\n\n</span><span class="s1">export function simple(node, visitors, baseVisitor, state, override) {</span><span class="s3">\n  </span><span class="s1">if (!baseVisitor) baseVisitor = base</span><span class="s3">\n  </span><span class="s1">;(function c(node, st, override) {</span><span class="s3">\n    </span><span class="s1">let type = override || node.type, found = visitors[type]</span><span class="s3">\n    </span><span class="s1">baseVisitor[type](node, st, c)</span><span class="s3">\n    </span><span class="s1">if (found) found(node, st)</span><span class="s3">\n  </span><span class="s1">})(node, state, override)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// An ancestor walk keeps an array of ancestor nodes (including the</span><span class="s3">\n</span><span class="s1">// current node) and passes them to the callback as third parameter</span><span class="s3">\n</span><span class="s1">// (and also as state parameter when no other state is present).</span><span class="s3">\n</span><span class="s1">export function ancestor(node, visitors, baseVisitor, state) {</span><span class="s3">\n  </span><span class="s1">let ancestors = []</span><span class="s3">\n  </span><span class="s1">if (!baseVisitor) baseVisitor = base</span><span class="s3">\n  </span><span class="s1">;(function c(node, st, override) {</span><span class="s3">\n    </span><span class="s1">let type = override || node.type, found = visitors[type]</span><span class="s3">\n    </span><span class="s1">let isNew = node !== ancestors[ancestors.length - 1]</span><span class="s3">\n    </span><span class="s1">if (isNew) ancestors.push(node)</span><span class="s3">\n    </span><span class="s1">baseVisitor[type](node, st, c)</span><span class="s3">\n    </span><span class="s1">if (found) found(node, st || ancestors, ancestors)</span><span class="s3">\n    </span><span class="s1">if (isNew) ancestors.pop()</span><span class="s3">\n  </span><span class="s1">})(node, state)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// A recursive walk is one where your functions override the default</span><span class="s3">\n</span><span class="s1">// walkers. They can modify and replace the state parameter that's</span><span class="s3">\n</span><span class="s1">// threaded through the walk, and can opt how and whether to walk</span><span class="s3">\n</span><span class="s1">// their child nodes (by calling their third argument on these</span><span class="s3">\n</span><span class="s1">// nodes).</span><span class="s3">\n</span><span class="s1">export function recursive(node, state, funcs, baseVisitor, override) {</span><span class="s3">\n  </span><span class="s1">let visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor</span><span class="s3">\n  </span><span class="s1">;(function c(node, st, override) {</span><span class="s3">\n    </span><span class="s1">visitor[override || node.type](node, st, c)</span><span class="s3">\n  </span><span class="s1">})(node, state, override)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function makeTest(test) {</span><span class="s3">\n  </span><span class="s1">if (typeof test === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return type =&gt; type === test</span><span class="s3">\n  </span><span class="s1">else if (!test)</span><span class="s3">\n    </span><span class="s1">return () =&gt; true</span><span class="s3">\n  </span><span class="s1">else</span><span class="s3">\n    </span><span class="s1">return test</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class Found {</span><span class="s3">\n  </span><span class="s1">constructor(node, state) { this.node = node; this.state = state }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// A full walk triggers the callback on each node</span><span class="s3">\n</span><span class="s1">export function full(node, callback, baseVisitor, state, override) {</span><span class="s3">\n  </span><span class="s1">if (!baseVisitor) baseVisitor = base</span><span class="s3">\n  </span><span class="s1">;(function c(node, st, override) {</span><span class="s3">\n    </span><span class="s1">let type = override || node.type</span><span class="s3">\n    </span><span class="s1">baseVisitor[type](node, st, c)</span><span class="s3">\n    </span><span class="s1">if (!override) callback(node, st, type)</span><span class="s3">\n  </span><span class="s1">})(node, state, override)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// An fullAncestor walk is like an ancestor walk, but triggers</span><span class="s3">\n</span><span class="s1">// the callback on each node</span><span class="s3">\n</span><span class="s1">export function fullAncestor(node, callback, baseVisitor, state) {</span><span class="s3">\n  </span><span class="s1">if (!baseVisitor) baseVisitor = base</span><span class="s3">\n  </span><span class="s1">let ancestors = []</span><span class="s3">\n  </span><span class="s1">;(function c(node, st, override) {</span><span class="s3">\n    </span><span class="s1">let type = override || node.type</span><span class="s3">\n    </span><span class="s1">let isNew = node !== ancestors[ancestors.length - 1]</span><span class="s3">\n    </span><span class="s1">if (isNew) ancestors.push(node)</span><span class="s3">\n    </span><span class="s1">baseVisitor[type](node, st, c)</span><span class="s3">\n    </span><span class="s1">if (!override) callback(node, st || ancestors, ancestors, type)</span><span class="s3">\n    </span><span class="s1">if (isNew) ancestors.pop()</span><span class="s3">\n  </span><span class="s1">})(node, state)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Find a node with a given start, end, and type (all are optional,</span><span class="s3">\n</span><span class="s1">// null can be used as wildcard). Returns a {node, state} object, or</span><span class="s3">\n</span><span class="s1">// undefined when it doesn't find a matching node.</span><span class="s3">\n</span><span class="s1">export function findNodeAt(node, start, end, test, baseVisitor, state) {</span><span class="s3">\n  </span><span class="s1">if (!baseVisitor) baseVisitor = base</span><span class="s3">\n  </span><span class="s1">test = makeTest(test)</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">(function c(node, st, override) {</span><span class="s3">\n      </span><span class="s1">let type = override || node.type</span><span class="s3">\n      </span><span class="s1">if ((start == null || node.start &lt;= start) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(end == null || node.end &gt;= end))</span><span class="s3">\n        </span><span class="s1">baseVisitor[type](node, st, c)</span><span class="s3">\n      </span><span class="s1">if ((start == null || node.start === start) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(end == null || node.end === end) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">test(type, node))</span><span class="s3">\n        </span><span class="s1">throw new Found(node, st)</span><span class="s3">\n    </span><span class="s1">})(node, state)</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">if (e instanceof Found) return e</span><span class="s3">\n    </span><span class="s1">throw e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Find the innermost node of a given type that contains the given</span><span class="s3">\n</span><span class="s1">// position. Interface similar to findNodeAt.</span><span class="s3">\n</span><span class="s1">export function findNodeAround(node, pos, test, baseVisitor, state) {</span><span class="s3">\n  </span><span class="s1">test = makeTest(test)</span><span class="s3">\n  </span><span class="s1">if (!baseVisitor) baseVisitor = base</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">(function c(node, st, override) {</span><span class="s3">\n      </span><span class="s1">let type = override || node.type</span><span class="s3">\n      </span><span class="s1">if (node.start &gt; pos || node.end &lt; pos) return</span><span class="s3">\n      </span><span class="s1">baseVisitor[type](node, st, c)</span><span class="s3">\n      </span><span class="s1">if (test(type, node)) throw new Found(node, st)</span><span class="s3">\n    </span><span class="s1">})(node, state)</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">if (e instanceof Found) return e</span><span class="s3">\n    </span><span class="s1">throw e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Find the outermost matching node after a given position.</span><span class="s3">\n</span><span class="s1">export function findNodeAfter(node, pos, test, baseVisitor, state) {</span><span class="s3">\n  </span><span class="s1">test = makeTest(test)</span><span class="s3">\n  </span><span class="s1">if (!baseVisitor) baseVisitor = base</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">(function c(node, st, override) {</span><span class="s3">\n      </span><span class="s1">if (node.end &lt; pos) return</span><span class="s3">\n      </span><span class="s1">let type = override || node.type</span><span class="s3">\n      </span><span class="s1">if (node.start &gt;= pos &amp;&amp; test(type, node)) throw new Found(node, st)</span><span class="s3">\n      </span><span class="s1">baseVisitor[type](node, st, c)</span><span class="s3">\n    </span><span class="s1">})(node, state)</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">if (e instanceof Found) return e</span><span class="s3">\n    </span><span class="s1">throw e</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Find the outermost matching node before a given position.</span><span class="s3">\n</span><span class="s1">export function findNodeBefore(node, pos, test, baseVisitor, state) {</span><span class="s3">\n  </span><span class="s1">test = makeTest(test)</span><span class="s3">\n  </span><span class="s1">if (!baseVisitor) baseVisitor = base</span><span class="s3">\n  </span><span class="s1">let max</span><span class="s3">\n  </span><span class="s1">;(function c(node, st, override) {</span><span class="s3">\n    </span><span class="s1">if (node.start &gt; pos) return</span><span class="s3">\n    </span><span class="s1">let type = override || node.type</span><span class="s3">\n    </span><span class="s1">if (node.end &lt;= pos &amp;&amp; (!max || max.node.end &lt; node.end) &amp;&amp; test(type, node))</span><span class="s3">\n      </span><span class="s1">max = new Found(node, st)</span><span class="s3">\n    </span><span class="s1">baseVisitor[type](node, st, c)</span><span class="s3">\n  </span><span class="s1">})(node, state)</span><span class="s3">\n  </span><span class="s1">return max</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Fallback to an Object.create polyfill for older environments.</span><span class="s3">\n</span><span class="s1">const create = Object.create || function(proto) {</span><span class="s3">\n  </span><span class="s1">function Ctor() {}</span><span class="s3">\n  </span><span class="s1">Ctor.prototype = proto</span><span class="s3">\n  </span><span class="s1">return new Ctor</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Used to create a custom walker. Will fill in all missing node</span><span class="s3">\n</span><span class="s1">// type properties with the defaults.</span><span class="s3">\n</span><span class="s1">export function make(funcs, baseVisitor) {</span><span class="s3">\n  </span><span class="s1">let visitor = create(baseVisitor || base)</span><span class="s3">\n  </span><span class="s1">for (let type in funcs) visitor[type] = funcs[type]</span><span class="s3">\n  </span><span class="s1">return visitor</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function skipThrough(node, st, c) { c(node, st) }</span><span class="s3">\n</span><span class="s1">function ignore(_node, _st, _c) {}</span><span class="s3">\n\n</span><span class="s1">// Node walkers.</span><span class="s3">\n\n</span><span class="s1">export const base = {}</span><span class="s3">\n\n</span><span class="s1">base.Program = base.BlockStatement = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let stmt of node.body)</span><span class="s3">\n    </span><span class="s1">c(stmt, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.Statement = skipThrough</span><span class="s3">\n</span><span class="s1">base.EmptyStatement = ignore</span><span class="s3">\n</span><span class="s1">base.ExpressionStatement = base.ParenthesizedExpression =</span><span class="s3">\n  </span><span class="s1">(node, st, c) =&gt; c(node.expression, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">base.IfStatement = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.test, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.consequent, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.alternate) c(node.alternate, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.LabeledStatement = (node, st, c) =&gt; c(node.body, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">base.BreakStatement = base.ContinueStatement = ignore</span><span class="s3">\n</span><span class="s1">base.WithStatement = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.object, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.body, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.SwitchStatement = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.discriminant, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">for (let cs of node.cases) {</span><span class="s3">\n    </span><span class="s1">if (cs.test) c(cs.test, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">for (let cons of cs.consequent)</span><span class="s3">\n      </span><span class="s1">c(cons, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.SwitchCase = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.test) c(node.test, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">for (let cons of node.consequent)</span><span class="s3">\n    </span><span class="s1">c(cons, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ReturnStatement = base.YieldExpression = base.AwaitExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.argument) c(node.argument, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ThrowStatement = base.SpreadElement =</span><span class="s3">\n  </span><span class="s1">(node, st, c) =&gt; c(node.argument, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">base.TryStatement = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.block, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.handler) c(node.handler, st)</span><span class="s3">\n  </span><span class="s1">if (node.finalizer) c(node.finalizer, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.CatchClause = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.param) c(node.param, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.body, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.WhileStatement = base.DoWhileStatement = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.test, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.body, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ForStatement = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.init) c(node.init, st, </span><span class="s3">\&quot;</span><span class="s1">ForInit</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.test) c(node.test, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.update) c(node.update, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.body, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ForInStatement = base.ForOfStatement = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.left, st, </span><span class="s3">\&quot;</span><span class="s1">ForInit</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.right, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.body, st, </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ForInit = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">VariableDeclaration</span><span class="s3">\&quot;</span><span class="s1">) c(node, st)</span><span class="s3">\n  </span><span class="s1">else c(node, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.DebuggerStatement = ignore</span><span class="s3">\n\n</span><span class="s1">base.FunctionDeclaration = (node, st, c) =&gt; c(node, st, </span><span class="s3">\&quot;</span><span class="s1">Function</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">base.VariableDeclaration = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let decl of node.declarations)</span><span class="s3">\n    </span><span class="s1">c(decl, st)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.VariableDeclarator = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.id, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.init) c(node.init, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">base.Function = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.id) c(node.id, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">for (let param of node.params)</span><span class="s3">\n    </span><span class="s1">c(param, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.body, st, node.expression ? </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">base.Pattern = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">c(node, st, </span><span class="s3">\&quot;</span><span class="s1">VariablePattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">else if (node.type === </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">c(node, st, </span><span class="s3">\&quot;</span><span class="s1">MemberPattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">else</span><span class="s3">\n    </span><span class="s1">c(node, st)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.VariablePattern = ignore</span><span class="s3">\n</span><span class="s1">base.MemberPattern = skipThrough</span><span class="s3">\n</span><span class="s1">base.RestElement = (node, st, c) =&gt; c(node.argument, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">base.ArrayPattern = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let elt of node.elements) {</span><span class="s3">\n    </span><span class="s1">if (elt) c(elt, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ObjectPattern = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let prop of node.properties) {</span><span class="s3">\n    </span><span class="s1">if (prop.type === </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (prop.computed) c(prop.key, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">c(prop.value, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (prop.type === </span><span class="s3">\&quot;</span><span class="s1">RestElement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">c(prop.argument, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">base.Expression = skipThrough</span><span class="s3">\n</span><span class="s1">base.ThisExpression = base.Super = base.MetaProperty = ignore</span><span class="s3">\n</span><span class="s1">base.ArrayExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let elt of node.elements) {</span><span class="s3">\n    </span><span class="s1">if (elt) c(elt, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ObjectExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let prop of node.properties)</span><span class="s3">\n    </span><span class="s1">c(prop, st)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration</span><span class="s3">\n</span><span class="s1">base.SequenceExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let expr of node.expressions)</span><span class="s3">\n    </span><span class="s1">c(expr, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.TemplateLiteral = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let quasi of node.quasis)</span><span class="s3">\n    </span><span class="s1">c(quasi, st)</span><span class="s3">\n\n  </span><span class="s1">for (let expr of node.expressions)</span><span class="s3">\n    </span><span class="s1">c(expr, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.TemplateElement = ignore</span><span class="s3">\n</span><span class="s1">base.UnaryExpression = base.UpdateExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.argument, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.BinaryExpression = base.LogicalExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.left, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.right, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.AssignmentExpression = base.AssignmentPattern = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.left, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.right, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ConditionalExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.test, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.consequent, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.alternate, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.NewExpression = base.CallExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.callee, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.arguments)</span><span class="s3">\n    </span><span class="s1">for (let arg of node.arguments)</span><span class="s3">\n      </span><span class="s1">c(arg, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.MemberExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.object, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.computed) c(node.property, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ExportNamedDeclaration = base.ExportDefaultDeclaration = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.declaration)</span><span class="s3">\n    </span><span class="s1">c(node.declaration, st, node.type === </span><span class="s3">\&quot;</span><span class="s1">ExportNamedDeclaration</span><span class="s3">\&quot; </span><span class="s1">|| node.declaration.id ? </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.source) c(node.source, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ExportAllDeclaration = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.source, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ImportDeclaration = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let spec of node.specifiers)</span><span class="s3">\n    </span><span class="s1">c(spec, st)</span><span class="s3">\n  </span><span class="s1">c(node.source, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore</span><span class="s3">\n\n</span><span class="s1">base.TaggedTemplateExpression = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">c(node.tag, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.quasi, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ClassDeclaration = base.ClassExpression = (node, st, c) =&gt; c(node, st, </span><span class="s3">\&quot;</span><span class="s1">Class</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">base.Class = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.id) c(node.id, st, </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (node.superClass) c(node.superClass, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.body, st)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.ClassBody = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let elt of node.body)</span><span class="s3">\n    </span><span class="s1">c(elt, st)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">base.MethodDefinition = base.Property = (node, st, c) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (node.computed) c(node.key, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">c(node.value, st, </span><span class="s3">\&quot;</span><span class="s1">Expression</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;let&quot;</span><span class="s0">,</span><span class="s1">&quot;const&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>