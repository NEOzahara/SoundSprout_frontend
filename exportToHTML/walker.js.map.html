<html>
<head>
<title>walker.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
walker.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;walker.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/walker.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Single-use utility classes to provide functionality to the {@link Glob}</span><span class="s3">\n </span><span class="s1">* methods.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">import { Minipass } from 'minipass'</span><span class="s3">\n</span><span class="s1">import { Path } from 'path-scurry'</span><span class="s3">\n</span><span class="s1">import { Ignore, IgnoreLike } from './ignore.js'</span><span class="s3">\n\n</span><span class="s1">// XXX can we somehow make it so that it NEVER processes a given path more than</span><span class="s3">\n</span><span class="s1">// once, enough that the match set tracking is no longer needed?  that'd speed</span><span class="s3">\n</span><span class="s1">// things up a lot.  Or maybe bring back nounique, and skip it in that case?</span><span class="s3">\n\n</span><span class="s1">// a single minimatch set entry with 1 or more parts</span><span class="s3">\n</span><span class="s1">import { Pattern } from './pattern.js'</span><span class="s3">\n</span><span class="s1">import { Processor } from './processor.js'</span><span class="s3">\n\n</span><span class="s1">export interface GlobWalkerOpts {</span><span class="s3">\n  </span><span class="s1">absolute?: boolean</span><span class="s3">\n  </span><span class="s1">allowWindowsEscape?: boolean</span><span class="s3">\n  </span><span class="s1">cwd?: string | URL</span><span class="s3">\n  </span><span class="s1">dot?: boolean</span><span class="s3">\n  </span><span class="s1">dotRelative?: boolean</span><span class="s3">\n  </span><span class="s1">follow?: boolean</span><span class="s3">\n  </span><span class="s1">ignore?: string | string[] | IgnoreLike</span><span class="s3">\n  </span><span class="s1">mark?: boolean</span><span class="s3">\n  </span><span class="s1">matchBase?: boolean</span><span class="s3">\n  </span><span class="s1">// Note: maxDepth here means </span><span class="s3">\&quot;</span><span class="s1">maximum actual Path.depth()</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">// not </span><span class="s3">\&quot;</span><span class="s1">maximum depth beyond cwd</span><span class="s3">\&quot;\n  </span><span class="s1">maxDepth?: number</span><span class="s3">\n  </span><span class="s1">nobrace?: boolean</span><span class="s3">\n  </span><span class="s1">nocase?: boolean</span><span class="s3">\n  </span><span class="s1">nodir?: boolean</span><span class="s3">\n  </span><span class="s1">noext?: boolean</span><span class="s3">\n  </span><span class="s1">noglobstar?: boolean</span><span class="s3">\n  </span><span class="s1">platform?: NodeJS.Platform</span><span class="s3">\n  </span><span class="s1">posix?: boolean</span><span class="s3">\n  </span><span class="s1">realpath?: boolean</span><span class="s3">\n  </span><span class="s1">root?: string</span><span class="s3">\n  </span><span class="s1">stat?: boolean</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n  </span><span class="s1">windowsPathsNoEscape?: boolean</span><span class="s3">\n  </span><span class="s1">withFileTypes?: boolean</span><span class="s3">\n  </span><span class="s1">includeChildMatches?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type GWOFileTypesTrue = GlobWalkerOpts &amp; {</span><span class="s3">\n  </span><span class="s1">withFileTypes: true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export type GWOFileTypesFalse = GlobWalkerOpts &amp; {</span><span class="s3">\n  </span><span class="s1">withFileTypes: false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export type GWOFileTypesUnset = GlobWalkerOpts &amp; {</span><span class="s3">\n  </span><span class="s1">withFileTypes?: undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type Result&lt;O extends GlobWalkerOpts&gt; =</span><span class="s3">\n  </span><span class="s1">O extends GWOFileTypesTrue ? Path</span><span class="s3">\n  </span><span class="s1">: O extends GWOFileTypesFalse ? string</span><span class="s3">\n  </span><span class="s1">: O extends GWOFileTypesUnset ? string</span><span class="s3">\n  </span><span class="s1">: Path | string</span><span class="s3">\n\n</span><span class="s1">export type Matches&lt;O extends GlobWalkerOpts&gt; =</span><span class="s3">\n  </span><span class="s1">O extends GWOFileTypesTrue ? Set&lt;Path&gt;</span><span class="s3">\n  </span><span class="s1">: O extends GWOFileTypesFalse ? Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">: O extends GWOFileTypesUnset ? Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">: Set&lt;Path | string&gt;</span><span class="s3">\n\n</span><span class="s1">export type MatchStream&lt;O extends GlobWalkerOpts&gt; = Minipass&lt;</span><span class="s3">\n  </span><span class="s1">Result&lt;O&gt;,</span><span class="s3">\n  </span><span class="s1">Result&lt;O&gt;</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">const makeIgnore = (</span><span class="s3">\n  </span><span class="s1">ignore: string | string[] | IgnoreLike,</span><span class="s3">\n  </span><span class="s1">opts: GlobWalkerOpts,</span><span class="s3">\n</span><span class="s1">): IgnoreLike =&gt;</span><span class="s3">\n  </span><span class="s1">typeof ignore === 'string' ? new Ignore([ignore], opts)</span><span class="s3">\n  </span><span class="s1">: Array.isArray(ignore) ? new Ignore(ignore, opts)</span><span class="s3">\n  </span><span class="s1">: ignore</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* basic walking utilities that all the glob walker types use</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export abstract class GlobUtil&lt;O extends GlobWalkerOpts = GlobWalkerOpts&gt; {</span><span class="s3">\n  </span><span class="s1">path: Path</span><span class="s3">\n  </span><span class="s1">patterns: Pattern[]</span><span class="s3">\n  </span><span class="s1">opts: O</span><span class="s3">\n  </span><span class="s1">seen: Set&lt;Path&gt; = new Set&lt;Path&gt;()</span><span class="s3">\n  </span><span class="s1">paused: boolean = false</span><span class="s3">\n  </span><span class="s1">aborted: boolean = false</span><span class="s3">\n  </span><span class="s1">#onResume: (() =&gt; any)[] = []</span><span class="s3">\n  </span><span class="s1">#ignore?: IgnoreLike</span><span class="s3">\n  </span><span class="s1">#sep: '</span><span class="s3">\\\\</span><span class="s1">' | '/'</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n  </span><span class="s1">maxDepth: number</span><span class="s3">\n  </span><span class="s1">includeChildMatches: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(patterns: Pattern[], path: Path, opts: O)</span><span class="s3">\n  </span><span class="s1">constructor(patterns: Pattern[], path: Path, opts: O) {</span><span class="s3">\n    </span><span class="s1">this.patterns = patterns</span><span class="s3">\n    </span><span class="s1">this.path = path</span><span class="s3">\n    </span><span class="s1">this.opts = opts</span><span class="s3">\n    </span><span class="s1">this.#sep = !opts.posix &amp;&amp; opts.platform === 'win32' ? '</span><span class="s3">\\\\</span><span class="s1">' : '/'</span><span class="s3">\n    </span><span class="s1">this.includeChildMatches = opts.includeChildMatches !== false</span><span class="s3">\n    </span><span class="s1">if (opts.ignore || !this.includeChildMatches) {</span><span class="s3">\n      </span><span class="s1">this.#ignore = makeIgnore(opts.ignore ?? [], opts)</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!this.includeChildMatches &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof this.#ignore.add !== 'function'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const m = 'cannot ignore child matches, ignore lacks add() method.'</span><span class="s3">\n        </span><span class="s1">throw new Error(m)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// ignore, always set with maxDepth, but it's optional on the</span><span class="s3">\n    </span><span class="s1">// GlobOptions type</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">this.maxDepth = opts.maxDepth || Infinity</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">if (opts.signal) {</span><span class="s3">\n      </span><span class="s1">this.signal = opts.signal</span><span class="s3">\n      </span><span class="s1">this.signal.addEventListener('abort', () =&gt; {</span><span class="s3">\n        </span><span class="s1">this.#onResume.length = 0</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">#ignored(path: Path): boolean {</span><span class="s3">\n    </span><span class="s1">return this.seen.has(path) || !!this.#ignore?.ignored?.(path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">#childrenIgnored(path: Path): boolean {</span><span class="s3">\n    </span><span class="s1">return !!this.#ignore?.childrenIgnored?.(path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// backpressure mechanism</span><span class="s3">\n  </span><span class="s1">pause() {</span><span class="s3">\n    </span><span class="s1">this.paused = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">resume() {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (this.signal?.aborted) return</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">this.paused = false</span><span class="s3">\n    </span><span class="s1">let fn: (() =&gt; any) | undefined = undefined</span><span class="s3">\n    </span><span class="s1">while (!this.paused &amp;&amp; (fn = this.#onResume.shift())) {</span><span class="s3">\n      </span><span class="s1">fn()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">onResume(fn: () =&gt; any) {</span><span class="s3">\n    </span><span class="s1">if (this.signal?.aborted) return</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (!this.paused) {</span><span class="s3">\n      </span><span class="s1">fn()</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n      </span><span class="s1">this.#onResume.push(fn)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// do the requisite realpath/stat checking, and return the path</span><span class="s3">\n  </span><span class="s1">// to add or undefined to filter it out.</span><span class="s3">\n  </span><span class="s1">async matchCheck(e: Path, ifDir: boolean): Promise&lt;Path | undefined&gt; {</span><span class="s3">\n    </span><span class="s1">if (ifDir &amp;&amp; this.opts.nodir) return undefined</span><span class="s3">\n    </span><span class="s1">let rpc: Path | undefined</span><span class="s3">\n    </span><span class="s1">if (this.opts.realpath) {</span><span class="s3">\n      </span><span class="s1">rpc = e.realpathCached() || (await e.realpath())</span><span class="s3">\n      </span><span class="s1">if (!rpc) return undefined</span><span class="s3">\n      </span><span class="s1">e = rpc</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const needStat = e.isUnknown() || this.opts.stat</span><span class="s3">\n    </span><span class="s1">const s = needStat ? await e.lstat() : e</span><span class="s3">\n    </span><span class="s1">if (this.opts.follow &amp;&amp; this.opts.nodir &amp;&amp; s?.isSymbolicLink()) {</span><span class="s3">\n      </span><span class="s1">const target = await s.realpath()</span><span class="s3">\n      </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n      </span><span class="s1">if (target &amp;&amp; (target.isUnknown() || this.opts.stat)) {</span><span class="s3">\n        </span><span class="s1">await target.lstat()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.matchCheckTest(s, ifDir)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">e &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(this.maxDepth === Infinity || e.depth() &lt;= this.maxDepth) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(!ifDir || e.canReaddir()) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(!this.opts.nodir || !e.isDirectory()) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(!this.opts.nodir ||</span><span class="s3">\n            </span><span class="s1">!this.opts.follow ||</span><span class="s3">\n            </span><span class="s1">!e.isSymbolicLink() ||</span><span class="s3">\n            </span><span class="s1">!e.realpathCached()?.isDirectory()) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">!this.#ignored(e)</span><span class="s3">\n      </span><span class="s1">) ?</span><span class="s3">\n        </span><span class="s1">e</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">matchCheckSync(e: Path, ifDir: boolean): Path | undefined {</span><span class="s3">\n    </span><span class="s1">if (ifDir &amp;&amp; this.opts.nodir) return undefined</span><span class="s3">\n    </span><span class="s1">let rpc: Path | undefined</span><span class="s3">\n    </span><span class="s1">if (this.opts.realpath) {</span><span class="s3">\n      </span><span class="s1">rpc = e.realpathCached() || e.realpathSync()</span><span class="s3">\n      </span><span class="s1">if (!rpc) return undefined</span><span class="s3">\n      </span><span class="s1">e = rpc</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const needStat = e.isUnknown() || this.opts.stat</span><span class="s3">\n    </span><span class="s1">const s = needStat ? e.lstatSync() : e</span><span class="s3">\n    </span><span class="s1">if (this.opts.follow &amp;&amp; this.opts.nodir &amp;&amp; s?.isSymbolicLink()) {</span><span class="s3">\n      </span><span class="s1">const target = s.realpathSync()</span><span class="s3">\n      </span><span class="s1">if (target &amp;&amp; (target?.isUnknown() || this.opts.stat)) {</span><span class="s3">\n        </span><span class="s1">target.lstatSync()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.matchCheckTest(s, ifDir)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">abstract matchEmit(p: Result&lt;O&gt;): void</span><span class="s3">\n  </span><span class="s1">abstract matchEmit(p: string | Path): void</span><span class="s3">\n\n  </span><span class="s1">matchFinish(e: Path, absolute: boolean) {</span><span class="s3">\n    </span><span class="s1">if (this.#ignored(e)) return</span><span class="s3">\n    </span><span class="s1">// we know we have an ignore if this is false, but TS doesn't</span><span class="s3">\n    </span><span class="s1">if (!this.includeChildMatches &amp;&amp; this.#ignore?.add) {</span><span class="s3">\n      </span><span class="s1">const ign = `${e.relativePosix()}/**`</span><span class="s3">\n      </span><span class="s1">this.#ignore.add(ign)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const abs =</span><span class="s3">\n      </span><span class="s1">this.opts.absolute === undefined ? absolute : this.opts.absolute</span><span class="s3">\n    </span><span class="s1">this.seen.add(e)</span><span class="s3">\n    </span><span class="s1">const mark = this.opts.mark &amp;&amp; e.isDirectory() ? this.#sep : ''</span><span class="s3">\n    </span><span class="s1">// ok, we have what we need!</span><span class="s3">\n    </span><span class="s1">if (this.opts.withFileTypes) {</span><span class="s3">\n      </span><span class="s1">this.matchEmit(e)</span><span class="s3">\n    </span><span class="s1">} else if (abs) {</span><span class="s3">\n      </span><span class="s1">const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()</span><span class="s3">\n      </span><span class="s1">this.matchEmit(abs + mark)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const rel = this.opts.posix ? e.relativePosix() : e.relative()</span><span class="s3">\n      </span><span class="s1">const pre =</span><span class="s3">\n        </span><span class="s1">this.opts.dotRelative &amp;&amp; !rel.startsWith('..' + this.#sep) ?</span><span class="s3">\n          </span><span class="s1">'.' + this.#sep</span><span class="s3">\n        </span><span class="s1">: ''</span><span class="s3">\n      </span><span class="s1">this.matchEmit(!rel ? '.' + mark : pre + rel + mark)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async match(e: Path, absolute: boolean, ifDir: boolean): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const p = await this.matchCheck(e, ifDir)</span><span class="s3">\n    </span><span class="s1">if (p) this.matchFinish(p, absolute)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">matchSync(e: Path, absolute: boolean, ifDir: boolean): void {</span><span class="s3">\n    </span><span class="s1">const p = this.matchCheckSync(e, ifDir)</span><span class="s3">\n    </span><span class="s1">if (p) this.matchFinish(p, absolute)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">walkCB(target: Path, patterns: Pattern[], cb: () =&gt; any) {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (this.signal?.aborted) cb()</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">this.walkCB2(target, patterns, new Processor(this.opts), cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">walkCB2(</span><span class="s3">\n    </span><span class="s1">target: Path,</span><span class="s3">\n    </span><span class="s1">patterns: Pattern[],</span><span class="s3">\n    </span><span class="s1">processor: Processor,</span><span class="s3">\n    </span><span class="s1">cb: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (this.#childrenIgnored(target)) return cb()</span><span class="s3">\n    </span><span class="s1">if (this.signal?.aborted) cb()</span><span class="s3">\n    </span><span class="s1">if (this.paused) {</span><span class="s3">\n      </span><span class="s1">this.onResume(() =&gt; this.walkCB2(target, patterns, processor, cb))</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">processor.processPatterns(target, patterns)</span><span class="s3">\n\n    </span><span class="s1">// done processing.  all of the above is sync, can be abstracted out.</span><span class="s3">\n    </span><span class="s1">// subwalks is a map of paths to the entry filters they need</span><span class="s3">\n    </span><span class="s1">// matches is a map of paths to [absolute, ifDir] tuples.</span><span class="s3">\n    </span><span class="s1">let tasks = 1</span><span class="s3">\n    </span><span class="s1">const next = () =&gt; {</span><span class="s3">\n      </span><span class="s1">if (--tasks === 0) cb()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [m, absolute, ifDir] of processor.matches.entries()) {</span><span class="s3">\n      </span><span class="s1">if (this.#ignored(m)) continue</span><span class="s3">\n      </span><span class="s1">tasks++</span><span class="s3">\n      </span><span class="s1">this.match(m, absolute, ifDir).then(() =&gt; next())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const t of processor.subwalkTargets()) {</span><span class="s3">\n      </span><span class="s1">if (this.maxDepth !== Infinity &amp;&amp; t.depth() &gt;= this.maxDepth) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">tasks++</span><span class="s3">\n      </span><span class="s1">const childrenCached = t.readdirCached()</span><span class="s3">\n      </span><span class="s1">if (t.calledReaddir())</span><span class="s3">\n        </span><span class="s1">this.walkCB3(t, childrenCached, processor, next)</span><span class="s3">\n      </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">t.readdirCB(</span><span class="s3">\n          </span><span class="s1">(_, entries) =&gt; this.walkCB3(t, entries, processor, next),</span><span class="s3">\n          </span><span class="s1">true,</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">next()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">walkCB3(</span><span class="s3">\n    </span><span class="s1">target: Path,</span><span class="s3">\n    </span><span class="s1">entries: Path[],</span><span class="s3">\n    </span><span class="s1">processor: Processor,</span><span class="s3">\n    </span><span class="s1">cb: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">processor = processor.filterEntries(target, entries)</span><span class="s3">\n\n    </span><span class="s1">let tasks = 1</span><span class="s3">\n    </span><span class="s1">const next = () =&gt; {</span><span class="s3">\n      </span><span class="s1">if (--tasks === 0) cb()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [m, absolute, ifDir] of processor.matches.entries()) {</span><span class="s3">\n      </span><span class="s1">if (this.#ignored(m)) continue</span><span class="s3">\n      </span><span class="s1">tasks++</span><span class="s3">\n      </span><span class="s1">this.match(m, absolute, ifDir).then(() =&gt; next())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const [target, patterns] of processor.subwalks.entries()) {</span><span class="s3">\n      </span><span class="s1">tasks++</span><span class="s3">\n      </span><span class="s1">this.walkCB2(target, patterns, processor.child(), next)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">next()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">walkCBSync(target: Path, patterns: Pattern[], cb: () =&gt; any) {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (this.signal?.aborted) cb()</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">walkCB2Sync(</span><span class="s3">\n    </span><span class="s1">target: Path,</span><span class="s3">\n    </span><span class="s1">patterns: Pattern[],</span><span class="s3">\n    </span><span class="s1">processor: Processor,</span><span class="s3">\n    </span><span class="s1">cb: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (this.#childrenIgnored(target)) return cb()</span><span class="s3">\n    </span><span class="s1">if (this.signal?.aborted) cb()</span><span class="s3">\n    </span><span class="s1">if (this.paused) {</span><span class="s3">\n      </span><span class="s1">this.onResume(() =&gt;</span><span class="s3">\n        </span><span class="s1">this.walkCB2Sync(target, patterns, processor, cb),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">processor.processPatterns(target, patterns)</span><span class="s3">\n\n    </span><span class="s1">// done processing.  all of the above is sync, can be abstracted out.</span><span class="s3">\n    </span><span class="s1">// subwalks is a map of paths to the entry filters they need</span><span class="s3">\n    </span><span class="s1">// matches is a map of paths to [absolute, ifDir] tuples.</span><span class="s3">\n    </span><span class="s1">let tasks = 1</span><span class="s3">\n    </span><span class="s1">const next = () =&gt; {</span><span class="s3">\n      </span><span class="s1">if (--tasks === 0) cb()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [m, absolute, ifDir] of processor.matches.entries()) {</span><span class="s3">\n      </span><span class="s1">if (this.#ignored(m)) continue</span><span class="s3">\n      </span><span class="s1">this.matchSync(m, absolute, ifDir)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const t of processor.subwalkTargets()) {</span><span class="s3">\n      </span><span class="s1">if (this.maxDepth !== Infinity &amp;&amp; t.depth() &gt;= this.maxDepth) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">tasks++</span><span class="s3">\n      </span><span class="s1">const children = t.readdirSync()</span><span class="s3">\n      </span><span class="s1">this.walkCB3Sync(t, children, processor, next)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">next()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">walkCB3Sync(</span><span class="s3">\n    </span><span class="s1">target: Path,</span><span class="s3">\n    </span><span class="s1">entries: Path[],</span><span class="s3">\n    </span><span class="s1">processor: Processor,</span><span class="s3">\n    </span><span class="s1">cb: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">processor = processor.filterEntries(target, entries)</span><span class="s3">\n\n    </span><span class="s1">let tasks = 1</span><span class="s3">\n    </span><span class="s1">const next = () =&gt; {</span><span class="s3">\n      </span><span class="s1">if (--tasks === 0) cb()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [m, absolute, ifDir] of processor.matches.entries()) {</span><span class="s3">\n      </span><span class="s1">if (this.#ignored(m)) continue</span><span class="s3">\n      </span><span class="s1">this.matchSync(m, absolute, ifDir)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const [target, patterns] of processor.subwalks.entries()) {</span><span class="s3">\n      </span><span class="s1">tasks++</span><span class="s3">\n      </span><span class="s1">this.walkCB2Sync(target, patterns, processor.child(), next)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">next()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class GlobWalker&lt;</span><span class="s3">\n  </span><span class="s1">O extends GlobWalkerOpts = GlobWalkerOpts,</span><span class="s3">\n</span><span class="s1">&gt; extends GlobUtil&lt;O&gt; {</span><span class="s3">\n  </span><span class="s1">matches = new Set&lt;Result&lt;O&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">constructor(patterns: Pattern[], path: Path, opts: O) {</span><span class="s3">\n    </span><span class="s1">super(patterns, path, opts)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">matchEmit(e: Result&lt;O&gt;): void {</span><span class="s3">\n    </span><span class="s1">this.matches.add(e)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async walk(): Promise&lt;Set&lt;Result&lt;O&gt;&gt;&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.signal?.aborted) throw this.signal.reason</span><span class="s3">\n    </span><span class="s1">if (this.path.isUnknown()) {</span><span class="s3">\n      </span><span class="s1">await this.path.lstat()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">await new Promise((res, rej) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.walkCB(this.path, this.patterns, () =&gt; {</span><span class="s3">\n        </span><span class="s1">if (this.signal?.aborted) {</span><span class="s3">\n          </span><span class="s1">rej(this.signal.reason)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">res(this.matches)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return this.matches</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">walkSync(): Set&lt;Result&lt;O&gt;&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.signal?.aborted) throw this.signal.reason</span><span class="s3">\n    </span><span class="s1">if (this.path.isUnknown()) {</span><span class="s3">\n      </span><span class="s1">this.path.lstatSync()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// nothing for the callback to do, because this never pauses</span><span class="s3">\n    </span><span class="s1">this.walkCBSync(this.path, this.patterns, () =&gt; {</span><span class="s3">\n      </span><span class="s1">if (this.signal?.aborted) throw this.signal.reason</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return this.matches</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class GlobStream&lt;</span><span class="s3">\n  </span><span class="s1">O extends GlobWalkerOpts = GlobWalkerOpts,</span><span class="s3">\n</span><span class="s1">&gt; extends GlobUtil&lt;O&gt; {</span><span class="s3">\n  </span><span class="s1">results: Minipass&lt;Result&lt;O&gt;, Result&lt;O&gt;&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(patterns: Pattern[], path: Path, opts: O) {</span><span class="s3">\n    </span><span class="s1">super(patterns, path, opts)</span><span class="s3">\n    </span><span class="s1">this.results = new Minipass&lt;Result&lt;O&gt;, Result&lt;O&gt;&gt;({</span><span class="s3">\n      </span><span class="s1">signal: this.signal,</span><span class="s3">\n      </span><span class="s1">objectMode: true,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">this.results.on('drain', () =&gt; this.resume())</span><span class="s3">\n    </span><span class="s1">this.results.on('resume', () =&gt; this.resume())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">matchEmit(e: Result&lt;O&gt;): void {</span><span class="s3">\n    </span><span class="s1">this.results.write(e)</span><span class="s3">\n    </span><span class="s1">if (!this.results.flowing) this.pause()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">stream(): MatchStream&lt;O&gt; {</span><span class="s3">\n    </span><span class="s1">const target = this.path</span><span class="s3">\n    </span><span class="s1">if (target.isUnknown()) {</span><span class="s3">\n      </span><span class="s1">target.lstat().then(() =&gt; {</span><span class="s3">\n        </span><span class="s1">this.walkCB(target, this.patterns, () =&gt; this.results.end())</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.walkCB(target, this.patterns, () =&gt; this.results.end())</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.results</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">streamSync(): MatchStream&lt;O&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.path.isUnknown()) {</span><span class="s3">\n      </span><span class="s1">this.path.lstatSync()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.walkCBSync(this.path, this.patterns, () =&gt; this.results.end())</span><span class="s3">\n    </span><span class="s1">return this.results</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>