<html>
<head>
<title>wrapAsyncGenerator.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wrapAsyncGenerator.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_OverloadYield&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_wrapAsyncGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;AsyncGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;gen&quot;</span><span class="s0">,</span><span class="s1">&quot;front&quot;</span><span class="s0">,</span><span class="s1">&quot;back&quot;</span><span class="s0">,</span><span class="s1">&quot;send&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;resume&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;overloaded&quot;</span><span class="s0">,</span><span class="s1">&quot;OverloadYield&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;nextKey&quot;</span><span class="s0">,</span><span class="s1">&quot;k&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;settle&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;_invoke&quot;</span><span class="s0">,</span><span class="s1">&quot;return&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;asyncIterator&quot;</span><span class="s0">,</span><span class="s1">&quot;throw&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/helpers/wrapAsyncGenerator.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* @minVersion 7.0.0-beta.0 */</span><span class="s3">\n\n</span><span class="s1">import OverloadYield from </span><span class="s3">\&quot;</span><span class="s1">./OverloadYield.ts</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export default function _wrapAsyncGenerator(fn: GeneratorFunction) {</span><span class="s3">\n  </span><span class="s1">return function (this: any) {</span><span class="s3">\n    </span><span class="s1">// Use </span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot; </span><span class="s1">here for better compatibility and smaller bundle size</span><span class="s3">\n    </span><span class="s1">return new AsyncGenerator(fn.apply(this, arguments as any));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* == The implementation of the AsyncGenerator class == */</span><span class="s3">\n\n</span><span class="s1">type AsyncIteratorMethod = </span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">declare class AsyncGenerator&lt;T = unknown, TReturn = any, TNext = unknown&gt;</span><span class="s3">\n  </span><span class="s1">implements globalThis.AsyncGenerator&lt;T, TReturn, TNext&gt;</span><span class="s3">\n</span><span class="s1">{</span><span class="s3">\n  </span><span class="s1">_invoke: (</span><span class="s3">\n    </span><span class="s1">key: AsyncIteratorMethod,</span><span class="s3">\n    </span><span class="s1">arg: IteratorResult&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;IteratorResult&lt;T, TReturn&gt;&gt;;</span><span class="s3">\n\n  </span><span class="s1">constructor(gen: Generator&lt;T, TReturn, TNext&gt;);</span><span class="s3">\n\n  </span><span class="s1">next(...args: [] | [TNext]): Promise&lt;IteratorResult&lt;T, TReturn&gt;&gt;;</span><span class="s3">\n  </span><span class="s1">return(</span><span class="s3">\n    </span><span class="s1">value: TReturn | PromiseLike&lt;TReturn&gt;,</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IteratorResult&lt;T, TReturn&gt;&gt;;</span><span class="s3">\n  </span><span class="s1">throw(e: any): Promise&lt;IteratorResult&lt;T, TReturn&gt;&gt;;</span><span class="s3">\n  </span><span class="s1">[Symbol.asyncIterator](): AsyncGenerator&lt;T, TReturn, TNext&gt;;</span><span class="s3">\n  </span><span class="s1">[Symbol.asyncDispose](): Promise&lt;void&gt;;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface AsyncGeneratorRequest&lt;T = unknown, TReturn = any, TNext = unknown&gt; {</span><span class="s3">\n  </span><span class="s1">key: AsyncIteratorMethod;</span><span class="s3">\n  </span><span class="s1">arg: IteratorResult&lt;T&gt;;</span><span class="s3">\n  </span><span class="s1">resolve: (value: IteratorResult&lt;T, TReturn&gt;) =&gt; void;</span><span class="s3">\n  </span><span class="s1">reject: (error: any) =&gt; void;</span><span class="s3">\n  </span><span class="s1">next: AsyncGeneratorRequest&lt;T, TReturn, TNext&gt; | null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function AsyncGenerator&lt;T = unknown, TReturn = any, TNext = unknown&gt;(</span><span class="s3">\n  </span><span class="s1">this: AsyncGenerator&lt;T, TReturn, TNext&gt;,</span><span class="s3">\n  </span><span class="s1">gen: Generator&lt;T, TReturn, TNext&gt;,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">var front: AsyncGeneratorRequest&lt;T, TReturn, TNext&gt; | null,</span><span class="s3">\n    </span><span class="s1">back: AsyncGeneratorRequest&lt;T, TReturn, TNext&gt; | null;</span><span class="s3">\n\n  </span><span class="s1">function send(key: AsyncIteratorMethod, arg: IteratorResult&lt;T&gt;) {</span><span class="s3">\n    </span><span class="s1">return new Promise&lt;IteratorResult&lt;T, TReturn&gt;&gt;(function (resolve, reject) {</span><span class="s3">\n      </span><span class="s1">var request: AsyncGeneratorRequest&lt;T, TReturn, TNext&gt; = {</span><span class="s3">\n        </span><span class="s1">key: key,</span><span class="s3">\n        </span><span class="s1">arg: arg,</span><span class="s3">\n        </span><span class="s1">resolve: resolve,</span><span class="s3">\n        </span><span class="s1">reject: reject,</span><span class="s3">\n        </span><span class="s1">next: null,</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n      </span><span class="s1">if (back) {</span><span class="s3">\n        </span><span class="s1">back = back.next = request;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">front = back = request;</span><span class="s3">\n        </span><span class="s1">resume(key, arg);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function resume(key: AsyncIteratorMethod, arg: IteratorResult&lt;T, TReturn&gt;) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">var result = gen[key](arg);</span><span class="s3">\n      </span><span class="s1">var value = result.value;</span><span class="s3">\n      </span><span class="s1">var overloaded = value instanceof OverloadYield;</span><span class="s3">\n\n      </span><span class="s1">Promise.resolve(</span><span class="s3">\n        </span><span class="s1">overloaded ? (value as OverloadYield&lt;T | TReturn&gt;).v : value,</span><span class="s3">\n      </span><span class="s1">).then(</span><span class="s3">\n        </span><span class="s1">function (arg: any) {</span><span class="s3">\n          </span><span class="s1">if (overloaded) {</span><span class="s3">\n            </span><span class="s1">// Overloaded yield requires calling into the generator twice:</span><span class="s3">\n            </span><span class="s1">//  - first we get the iterator result wrapped in a promise</span><span class="s3">\n            </span><span class="s1">//    (the gen[key](arg) call above)</span><span class="s3">\n            </span><span class="s1">//  - then we await it (the Promise.resolve call above)</span><span class="s3">\n            </span><span class="s1">//  - then we give the result back to the iterator, so that it can:</span><span class="s3">\n            </span><span class="s1">//    * if it was an await, use its result</span><span class="s3">\n            </span><span class="s1">//    * if it was a yield*, possibly return the `done: true` signal</span><span class="s3">\n            </span><span class="s1">//      so that yield* knows that the iterator is finished.</span><span class="s3">\n            </span><span class="s1">//      This needs to happen in the second call, because in the</span><span class="s3">\n            </span><span class="s1">//      first one `done: true` was hidden in the promise and thus</span><span class="s3">\n            </span><span class="s1">//      not visible to the (sync) yield*.</span><span class="s3">\n            </span><span class="s1">//      The other part of this implementation is in asyncGeneratorDelegate.</span><span class="s3">\n            </span><span class="s1">var nextKey: </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot; </span><span class="s1">=</span><span class="s3">\n              </span><span class="s1">key === </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">!(value as OverloadYield&lt;IteratorReturnResult&lt;T&gt;&gt;).k ||</span><span class="s3">\n              </span><span class="s1">arg.done</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">// await or end of yield*</span><span class="s3">\n              </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-confusing-void-expression -- smaller bundle size</span><span class="s3">\n              </span><span class="s1">return resume(nextKey, arg);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// yield*, not done</span><span class="s3">\n              </span><span class="s1">arg = gen[nextKey](arg).value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">settle(result.done ? </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">normal</span><span class="s3">\&quot;</span><span class="s1">, arg);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">function (err) {</span><span class="s3">\n          </span><span class="s1">resume(</span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">, err);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">settle(</span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">, err);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function settle(type: AsyncIteratorMethod | </span><span class="s3">\&quot;</span><span class="s1">normal</span><span class="s3">\&quot;</span><span class="s1">, value: any) {</span><span class="s3">\n    </span><span class="s1">switch (type) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">front!.resolve({ value: value, done: true });</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">front!.reject(value);</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">front!.resolve({ value: value, done: false });</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">front = front!.next;</span><span class="s3">\n    </span><span class="s1">if (front) {</span><span class="s3">\n      </span><span class="s1">resume(front.key, front.arg);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">back = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this._invoke = send;</span><span class="s3">\n\n  </span><span class="s1">// Hide </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot; </span><span class="s1">method if generator return is not supported</span><span class="s3">\n  </span><span class="s1">if (typeof gen.return !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error -- intentionally remove </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot; </span><span class="s1">when not supported</span><span class="s3">\n    </span><span class="s1">this.return = undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">AsyncGenerator.prototype[</span><span class="s3">\n  </span><span class="s1">((typeof Symbol === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; Symbol.asyncIterator) ||</span><span class="s3">\n    \&quot;</span><span class="s1">@@asyncIterator</span><span class="s3">\&quot;</span><span class="s1">) as typeof Symbol.asyncIterator</span><span class="s3">\n</span><span class="s1">] = function () {</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">AsyncGenerator.prototype.next = function (arg: IteratorResult&lt;any&gt;) {</span><span class="s3">\n  </span><span class="s1">return this._invoke(</span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">, arg);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">AsyncGenerator.prototype.throw = function (arg: IteratorResult&lt;any&gt;) {</span><span class="s3">\n  </span><span class="s1">return this._invoke(</span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">, arg);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">AsyncGenerator.prototype.return = function (arg: IteratorResult&lt;any&gt;) {</span><span class="s3">\n  </span><span class="s1">return this._invoke(</span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">, arg);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>