<html>
<head>
<title>xpath.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5f826b; font-style: italic;}
.s1 { color: #bcbec4;}
.s2 { color: #bcbec4;}
.s3 { color: #cf8e6d;}
.s4 { color: #7a7e85;}
.s5 { color: #6aab73;}
.s6 { color: #2aacb8;}
.s7 { color: #42c3d4;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
xpath.js</font>
</center></td></tr></table>
<pre><span class="s0">/** Here is yet another implementation of XPath 1.0 in Javascript.</span>
 <span class="s0">*</span>
 <span class="s0">* My goal was to make it relatively compact, but as I fixed all the axis bugs</span>
 <span class="s0">* the axes became more and more complicated. :-(.</span>
 <span class="s0">*</span>
 <span class="s0">* I have not implemented namespaces or case-sensitive axes for XML yet.</span>
 <span class="s0">*</span>
 <span class="s0">* How to test it in Chrome: You can make a Chrome extension that replaces</span>
 <span class="s0">* the WebKit XPath parser with this one. But it takes a bit of effort to</span>
 <span class="s0">* get around isolated world and same-origin restrictions:</span>
 <span class="s0">* manifest.json:</span>
    <span class="s0">{</span>
      <span class="s0">&quot;name&quot;: &quot;XPathTest&quot;,</span>
      <span class="s0">&quot;version&quot;: &quot;0.1&quot;,</span>
      <span class="s0">&quot;content_scripts&quot;: [{</span>
        <span class="s0">&quot;matches&quot;: [&quot;http://localhost/*&quot;],  // or wildcard host</span>
        <span class="s0">&quot;js&quot;: [&quot;xpath.js&quot;, &quot;injection.js&quot;],</span>
        <span class="s0">&quot;all_frames&quot;: true, &quot;run_at&quot;: &quot;document_start&quot;</span>
      <span class="s0">}]</span>
    <span class="s0">}</span>
 <span class="s0">* injection.js:</span>
    <span class="s0">// goal: give my xpath object to the website's JS context.</span>
    <span class="s0">var script = document.createElement('script');</span>
    <span class="s0">script.textContent =</span>
        <span class="s0">&quot;document.addEventListener('xpathextend', function(e) {\n&quot; +</span>
        <span class="s0">&quot;  console.log('extending document with xpath...');\n&quot; +</span>
        <span class="s0">&quot;  e.detail(window);&quot; +</span>
        <span class="s0">&quot;});&quot;;</span>
    <span class="s0">document.documentElement.appendChild(script);</span>
    <span class="s0">document.documentElement.removeChild(script);</span>
    <span class="s0">var evt = document.createEvent('CustomEvent');</span>
    <span class="s0">evt.initCustomEvent('xpathextend', true, true, this.xpath.extend);</span>
    <span class="s0">document.dispatchEvent(evt);</span>
 <span class="s0">*/</span>
<span class="s1">module</span><span class="s2">.</span><span class="s1">exports </span><span class="s2">= </span><span class="s1">core </span><span class="s2">=&gt; {</span>
  <span class="s3">var </span><span class="s1">xpath </span><span class="s2">= {};</span>

  <span class="s4">// Helper function to deal with the migration of Attr to no longer have a nodeName property despite this codebase</span>
  <span class="s4">// assuming it does.</span>
  <span class="s3">function </span><span class="s1">getNodeName</span><span class="s2">(</span><span class="s1">nodeOrAttr</span><span class="s2">) {</span>
    <span class="s3">return </span><span class="s1">nodeOrAttr</span><span class="s2">.</span><span class="s1">constructor</span><span class="s2">.</span><span class="s1">name </span><span class="s2">=== </span><span class="s5">'Attr' </span><span class="s2">? </span><span class="s1">nodeOrAttr</span><span class="s2">.</span><span class="s1">name </span><span class="s2">: </span><span class="s1">nodeOrAttr</span><span class="s2">.</span><span class="s1">nodeName</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/***************************************************************************</span>
   <span class="s0">*                            Tokenization                                 *</span>
   <span class="s0">***************************************************************************/</span>
  <span class="s0">/**</span>
   <span class="s0">* The XPath lexer is basically a single regular expression, along with</span>
   <span class="s0">* some helper functions to pop different types.</span>
   <span class="s0">*/</span>
  <span class="s3">var </span><span class="s1">Stream </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">Stream </span><span class="s2">= </span><span class="s3">function </span><span class="s1">Stream</span><span class="s2">(</span><span class="s1">str</span><span class="s2">) {</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">original </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">str </span><span class="s2">= </span><span class="s1">str</span><span class="s2">;</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">peeked </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
    <span class="s4">// TODO: not really needed, but supposedly tokenizer also disambiguates</span>
    <span class="s4">// a * b vs. node test *</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">prev </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;  </span><span class="s4">// for debugging</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">prevprev </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s1">Stream</span><span class="s2">.</span><span class="s1">prototype </span><span class="s2">= {</span>
    <span class="s1">peek</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">peeked</span><span class="s2">) </span><span class="s3">return this</span><span class="s2">.</span><span class="s1">peeked</span><span class="s2">;</span>
      <span class="s3">var </span><span class="s1">m </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">re</span><span class="s2">.</span><span class="s1">exec</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">str</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(!</span><span class="s1">m</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">str </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">str</span><span class="s2">.</span><span class="s1">substr</span><span class="s2">(</span><span class="s1">m</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">peeked </span><span class="s2">= </span><span class="s1">m</span><span class="s2">[</span><span class="s6">1</span><span class="s2">];</span>
    <span class="s2">},</span>
    <span class="s0">/** Peek 2 tokens ahead. */</span>
    <span class="s1">peek2</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();  </span><span class="s4">// make sure this.peeked is set</span>
      <span class="s3">var </span><span class="s1">m </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">re</span><span class="s2">.</span><span class="s1">exec</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">str</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(!</span><span class="s1">m</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
      <span class="s3">return </span><span class="s1">m</span><span class="s2">[</span><span class="s6">1</span><span class="s2">];</span>
    <span class="s2">},</span>
    <span class="s1">pop</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">var </span><span class="s1">r </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">peeked </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">prevprev </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">prev</span><span class="s2">;</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">prev </span><span class="s2">= </span><span class="s1">r</span><span class="s2">;</span>
      <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">trypop</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">tokens</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">tok </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">tok </span><span class="s2">=== </span><span class="s1">tokens</span><span class="s2">) </span><span class="s3">return this</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">();</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">isArray</span><span class="s2">(</span><span class="s1">tokens</span><span class="s2">)) {</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">tokens</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">t </span><span class="s2">= </span><span class="s1">tokens</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">t </span><span class="s2">== </span><span class="s1">tok</span><span class="s2">) </span><span class="s3">return this</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">();;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s1">trypopfuncname</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">var </span><span class="s1">tok </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
      <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.</span><span class="s1">isQnameRe</span><span class="s2">.</span><span class="s1">test</span><span class="s2">(</span><span class="s1">tok</span><span class="s2">))</span>
        <span class="s3">return null</span><span class="s2">;</span>
      <span class="s3">switch </span><span class="s2">(</span><span class="s1">tok</span><span class="s2">) {</span>
        <span class="s3">case </span><span class="s5">'comment'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'text'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'processing-instruction'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'node'</span><span class="s2">:</span>
          <span class="s3">return null</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'(' </span><span class="s2">!= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek2</span><span class="s2">()) </span><span class="s3">return null</span><span class="s2">;</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">();</span>
    <span class="s2">},</span>
    <span class="s1">trypopaxisname</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">var </span><span class="s1">tok </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
      <span class="s3">switch </span><span class="s2">(</span><span class="s1">tok</span><span class="s2">) {</span>
        <span class="s3">case </span><span class="s5">'ancestor'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'ancestor-or-self'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'attribute'</span><span class="s2">:</span>
        <span class="s3">case </span><span class="s5">'child'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'descendant'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'descendant-or-self'</span><span class="s2">:</span>
        <span class="s3">case </span><span class="s5">'following'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'following-sibling'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'namespace'</span><span class="s2">:</span>
        <span class="s3">case </span><span class="s5">'parent'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'preceding'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'preceding-sibling'</span><span class="s2">: </span><span class="s3">case </span><span class="s5">'self'</span><span class="s2">:</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s5">'::' </span><span class="s2">== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek2</span><span class="s2">()) </span><span class="s3">return this</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">();</span>
      <span class="s2">}</span>
      <span class="s3">return null</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">trypopnametest</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">var </span><span class="s1">tok </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'*' </span><span class="s2">=== </span><span class="s1">tok </span><span class="s2">|| </span><span class="s3">this</span><span class="s2">.</span><span class="s1">startsWithNcNameRe</span><span class="s2">.</span><span class="s1">test</span><span class="s2">(</span><span class="s1">tok</span><span class="s2">)) </span><span class="s3">return this</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">();</span>
      <span class="s3">return null</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">trypopliteral</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">var </span><span class="s1">tok </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">tok</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
      <span class="s3">var </span><span class="s1">first </span><span class="s2">= </span><span class="s1">tok</span><span class="s2">.</span><span class="s1">charAt</span><span class="s2">(</span><span class="s6">0</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">last </span><span class="s2">= </span><span class="s1">tok</span><span class="s2">.</span><span class="s1">charAt</span><span class="s2">(</span><span class="s1">tok</span><span class="s2">.</span><span class="s1">length </span><span class="s2">- </span><span class="s6">1</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'&quot;' </span><span class="s2">=== </span><span class="s1">first </span><span class="s2">&amp;&amp; </span><span class="s5">'&quot;' </span><span class="s2">=== </span><span class="s1">last </span><span class="s2">||</span>
          <span class="s5">&quot;'&quot; </span><span class="s2">=== </span><span class="s1">first </span><span class="s2">&amp;&amp; </span><span class="s5">&quot;'&quot; </span><span class="s2">=== </span><span class="s1">last</span><span class="s2">) {</span>
        <span class="s3">this</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">();</span>
        <span class="s3">return </span><span class="s1">tok</span><span class="s2">.</span><span class="s1">substr</span><span class="s2">(</span><span class="s6">1</span><span class="s2">, </span><span class="s1">tok</span><span class="s2">.</span><span class="s1">length </span><span class="s2">- </span><span class="s6">2</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s1">trypopnumber</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">var </span><span class="s1">tok </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">isNumberRe</span><span class="s2">.</span><span class="s1">test</span><span class="s2">(</span><span class="s1">tok</span><span class="s2">)) </span><span class="s3">return </span><span class="s1">parseFloat</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">());</span>
      <span class="s3">else return null</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">trypopvarref</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">var </span><span class="s1">tok </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">tok</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'$' </span><span class="s2">=== </span><span class="s1">tok</span><span class="s2">.</span><span class="s1">charAt</span><span class="s2">(</span><span class="s6">0</span><span class="s2">)) </span><span class="s3">return this</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">().</span><span class="s1">substr</span><span class="s2">(</span><span class="s6">1</span><span class="s2">);</span>
      <span class="s3">else return null</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">position</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">original</span><span class="s2">.</span><span class="s1">length </span><span class="s2">- </span><span class="s3">this</span><span class="s2">.</span><span class="s1">str</span><span class="s2">.</span><span class="s1">length</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
  <span class="s2">(</span><span class="s3">function</span><span class="s2">() {</span>
    <span class="s4">// http://www.w3.org/TR/REC-xml-names/#NT-NCName</span>
    <span class="s3">var </span><span class="s1">nameStartCharsExceptColon </span><span class="s2">=</span>
        <span class="s5">'A-Z_a-z</span><span class="s3">\xc0</span><span class="s5">-</span><span class="s3">\xd6\xd8</span><span class="s5">-</span><span class="s3">\xf6\xF8</span><span class="s5">-</span><span class="s3">\u02FF\u0370</span><span class="s5">-</span><span class="s3">\u037D\u037F</span><span class="s5">-</span><span class="s3">\u1FFF</span><span class="s5">' </span><span class="s2">+</span>
        <span class="s5">'</span><span class="s3">\u200C</span><span class="s5">-</span><span class="s3">\u200D\u2070</span><span class="s5">-</span><span class="s3">\u218F\u2C00</span><span class="s5">-</span><span class="s3">\u2FEF\u3001</span><span class="s5">-</span><span class="s3">\uD7FF\uF900</span><span class="s5">-</span><span class="s3">\uFDCF</span><span class="s5">' </span><span class="s2">+</span>
        <span class="s5">'</span><span class="s3">\uFDF0</span><span class="s5">-</span><span class="s3">\uFFFD</span><span class="s5">'</span><span class="s2">;  </span><span class="s4">// JS doesn't support [#x10000-#xEFFFF]</span>
    <span class="s3">var </span><span class="s1">nameCharExceptColon </span><span class="s2">= </span><span class="s1">nameStartCharsExceptColon </span><span class="s2">+</span>
        <span class="s5">'</span><span class="s3">\\</span><span class="s5">-</span><span class="s3">\\</span><span class="s5">.0-9</span><span class="s3">\xb7\u0300</span><span class="s5">-</span><span class="s3">\u036F\u203F</span><span class="s5">-</span><span class="s3">\u2040</span><span class="s5">'</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">ncNameChars </span><span class="s2">= </span><span class="s5">'[' </span><span class="s2">+ </span><span class="s1">nameStartCharsExceptColon </span><span class="s2">+</span>
        <span class="s5">'][' </span><span class="s2">+ </span><span class="s1">nameCharExceptColon </span><span class="s2">+ </span><span class="s5">']*'</span>
    <span class="s4">// http://www.w3.org/TR/REC-xml-names/#NT-QName</span>
    <span class="s3">var </span><span class="s1">qNameChars </span><span class="s2">= </span><span class="s1">ncNameChars </span><span class="s2">+ </span><span class="s5">'(?::' </span><span class="s2">+ </span><span class="s1">ncNameChars </span><span class="s2">+ </span><span class="s5">')?'</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">otherChars </span><span class="s2">= </span><span class="s5">'</span><span class="s3">\\</span><span class="s5">.</span><span class="s3">\\</span><span class="s5">.|[</span><span class="s3">\\</span><span class="s5">(</span><span class="s3">\\</span><span class="s5">)</span><span class="s3">\\</span><span class="s5">[</span><span class="s3">\\</span><span class="s5">].@,]|::'</span><span class="s2">;  </span><span class="s4">// .. must come before [.]</span>
    <span class="s3">var </span><span class="s1">operatorChars </span><span class="s2">=</span>
        <span class="s5">'and|or|mod|div|' </span><span class="s2">+</span>
        <span class="s5">'//|!=|&lt;=|&gt;=|[*/|+</span><span class="s3">\\</span><span class="s5">-=&lt;&gt;]'</span><span class="s2">;  </span><span class="s4">// //, !=, &lt;=, &gt;= before individual ones.</span>
    <span class="s3">var </span><span class="s1">literal </span><span class="s2">= </span><span class="s5">'&quot;[^&quot;]*&quot;|' </span><span class="s2">+ </span><span class="s5">&quot;'[^']*'&quot;</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">numberChars </span><span class="s2">= </span><span class="s5">'[0-9]+(?:</span><span class="s3">\\</span><span class="s5">.[0-9]*)?|</span><span class="s3">\\</span><span class="s5">.[0-9]+'</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">variableReference </span><span class="s2">= </span><span class="s5">'</span><span class="s3">\\</span><span class="s5">$' </span><span class="s2">+ </span><span class="s1">qNameChars</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">nameTestChars </span><span class="s2">= </span><span class="s5">'</span><span class="s3">\\</span><span class="s5">*|' </span><span class="s2">+ </span><span class="s1">ncNameChars </span><span class="s2">+ </span><span class="s5">':</span><span class="s3">\\</span><span class="s5">*|' </span><span class="s2">+ </span><span class="s1">qNameChars</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">optionalSpace </span><span class="s2">= </span><span class="s5">'[ </span><span class="s3">\t\r\n</span><span class="s5">]*'</span><span class="s2">;  </span><span class="s4">// stricter than regexp \s.</span>
    <span class="s3">var </span><span class="s1">nodeType </span><span class="s2">= </span><span class="s5">'comment|text|processing-instruction|node'</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">re </span><span class="s2">= </span><span class="s3">new </span><span class="s1">RegExp</span><span class="s2">(</span>
        <span class="s4">// numberChars before otherChars so that leading-decimal doesn't become .</span>
        <span class="s5">'^' </span><span class="s2">+ </span><span class="s1">optionalSpace </span><span class="s2">+ </span><span class="s5">'(' </span><span class="s2">+ </span><span class="s1">numberChars </span><span class="s2">+ </span><span class="s5">'|' </span><span class="s2">+ </span><span class="s1">otherChars </span><span class="s2">+ </span><span class="s5">'|' </span><span class="s2">+</span>
        <span class="s1">nameTestChars </span><span class="s2">+ </span><span class="s5">'|' </span><span class="s2">+ </span><span class="s1">operatorChars </span><span class="s2">+ </span><span class="s5">'|' </span><span class="s2">+ </span><span class="s1">literal </span><span class="s2">+ </span><span class="s5">'|' </span><span class="s2">+</span>
        <span class="s1">variableReference </span><span class="s2">+ </span><span class="s5">')'</span>
        <span class="s4">// operatorName | nodeType | functionName | axisName are lumped into</span>
        <span class="s4">// qName for now; we'll check them on pop.</span>
    <span class="s2">);</span>
    <span class="s1">Stream</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">re </span><span class="s2">= </span><span class="s1">re</span><span class="s2">;</span>
    <span class="s1">Stream</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">startsWithNcNameRe </span><span class="s2">= </span><span class="s3">new </span><span class="s1">RegExp</span><span class="s2">(</span><span class="s5">'^' </span><span class="s2">+ </span><span class="s1">ncNameChars</span><span class="s2">);</span>
    <span class="s1">Stream</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">isQnameRe </span><span class="s2">= </span><span class="s3">new </span><span class="s1">RegExp</span><span class="s2">(</span><span class="s5">'^' </span><span class="s2">+ </span><span class="s1">qNameChars </span><span class="s2">+ </span><span class="s5">'$'</span><span class="s2">);</span>
    <span class="s1">Stream</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">isNumberRe </span><span class="s2">= </span><span class="s3">new </span><span class="s1">RegExp</span><span class="s2">(</span><span class="s5">'^' </span><span class="s2">+ </span><span class="s1">numberChars </span><span class="s2">+ </span><span class="s5">'$'</span><span class="s2">);</span>
  <span class="s2">})();</span>

  <span class="s0">/***************************************************************************</span>
   <span class="s0">*                               Parsing                                   *</span>
   <span class="s0">***************************************************************************/</span>
  <span class="s3">var </span><span class="s1">parse </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">parse </span><span class="s2">= </span><span class="s3">function </span><span class="s1">parse</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">r </span><span class="s2">= </span><span class="s1">orExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">,</span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">x</span><span class="s2">, </span><span class="s1">unparsed </span><span class="s2">= [];</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">x </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">()) {</span>
      <span class="s1">unparsed</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">x</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">unparsed</span><span class="s2">.</span><span class="s1">length</span><span class="s2">)</span>
      <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                               <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                               <span class="s5">': Unparsed tokens: ' </span><span class="s2">+ </span><span class="s1">unparsed</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s5">' '</span><span class="s2">));</span>
    <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/**</span>
   <span class="s0">* binaryL  ::= subExpr</span>
   <span class="s0">*            | binaryL op subExpr</span>
   <span class="s0">* so a op b op c becomes ((a op b) op c)</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">binaryL</span><span class="s2">(</span><span class="s1">subExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">ops</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">lhs </span><span class="s2">= </span><span class="s1">subExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">lhs </span><span class="s2">== </span><span class="s3">null</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">op</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">op </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">)) {</span>
      <span class="s3">var </span><span class="s1">rhs </span><span class="s2">= </span><span class="s1">subExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">rhs </span><span class="s2">== </span><span class="s3">null</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected something after ' </span><span class="s2">+ </span><span class="s1">op</span><span class="s2">);</span>
      <span class="s1">lhs </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">lhs</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/**</span>
   <span class="s0">* Too bad this is never used. If they made a ** operator (raise to power),</span>
   <span class="s0">( we would use it.</span>
   <span class="s0">* binaryR  ::= subExpr</span>
   <span class="s0">*            | subExpr op binaryR</span>
   <span class="s0">* so a op b op c becomes (a op (b op c))</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">binaryR</span><span class="s2">(</span><span class="s1">subExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">ops</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">lhs </span><span class="s2">= </span><span class="s1">subExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">lhs </span><span class="s2">== </span><span class="s3">null</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">op </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s1">ops</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">op</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">rhs </span><span class="s2">= </span><span class="s1">binaryR</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">rhs </span><span class="s2">== </span><span class="s3">null</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected something after ' </span><span class="s2">+ </span><span class="s1">op</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s1">op</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">);</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">return </span><span class="s1">lhs</span><span class="s2">;</span><span class="s4">// TODO</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s0">/** [1] LocationPath::= RelativeLocationPath | AbsoluteLocationPath</span>
   <span class="s0">* e.g. a, a/b, //a/b</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">locationPath</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">return </span><span class="s1">absoluteLocationPath</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) ||</span>
           <span class="s1">relativeLocationPath</span><span class="s2">(</span><span class="s3">null</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s0">/** [2] AbsoluteLocationPath::= '/' RelativeLocationPath? | AbbreviatedAbsoluteLocationPath</span>
   <span class="s0">*  [10] AbbreviatedAbsoluteLocationPath::= '//' RelativeLocationPath</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">absoluteLocationPath</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">op </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">peek</span><span class="s2">();</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s5">'/' </span><span class="s2">=== </span><span class="s1">op </span><span class="s2">|| </span><span class="s5">'//' </span><span class="s2">=== </span><span class="s1">op</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">lhs </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'Root'</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">relativeLocationPath</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s3">true</span><span class="s2">);</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">return null</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s0">/** [3] RelativeLocationPath::= Step | RelativeLocationPath '/' Step |</span>
   <span class="s0">*                            | AbbreviatedRelativeLocationPath</span>
   <span class="s0">*  [11] AbbreviatedRelativeLocationPath::= RelativeLocationPath '//' Step</span>
   <span class="s0">* e.g. p/a, etc.</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">relativeLocationPath</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">isOnlyRootOk</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">lhs</span><span class="s2">) {</span>
      <span class="s1">lhs </span><span class="s2">= </span><span class="s1">step</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">lhs</span><span class="s2">) </span><span class="s3">return </span><span class="s1">lhs</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">var </span><span class="s1">op</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">op </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">([</span><span class="s5">'/'</span><span class="s2">, </span><span class="s5">'//'</span><span class="s2">])) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'//' </span><span class="s2">=== </span><span class="s1">op</span><span class="s2">) {</span>
        <span class="s1">lhs </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'/'</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">,</span>
                     <span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'Axis'</span><span class="s2">, </span><span class="s5">'descendant-or-self'</span><span class="s2">, </span><span class="s5">'node'</span><span class="s2">, </span><span class="s1">undefined</span><span class="s2">));</span>
      <span class="s2">}</span>
      <span class="s3">var </span><span class="s1">rhs </span><span class="s2">= </span><span class="s1">step</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">rhs </span><span class="s2">&amp;&amp; </span><span class="s5">'/' </span><span class="s2">=== </span><span class="s1">op </span><span class="s2">&amp;&amp; </span><span class="s1">isOnlyRootOk</span><span class="s2">) </span><span class="s3">return </span><span class="s1">lhs</span><span class="s2">;</span>
      <span class="s3">else </span><span class="s1">isOnlyRootOk </span><span class="s2">= </span><span class="s3">false</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">rhs</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected step after ' </span><span class="s2">+ </span><span class="s1">op</span><span class="s2">);</span>
      <span class="s1">lhs </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'/'</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">rhs</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">lhs</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** [4] Step::= AxisSpecifier NodeTest Predicate* | AbbreviatedStep</span>
   <span class="s0">*  [12] AbbreviatedStep::= '.' | '..'</span>
   <span class="s0">* e.g. @href, self::p, p, a[@href], ., ..</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">step</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">abbrStep </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">([</span><span class="s5">'.'</span><span class="s2">, </span><span class="s5">'..'</span><span class="s2">]);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s5">'.' </span><span class="s2">=== </span><span class="s1">abbrStep</span><span class="s2">)  </span><span class="s4">// A location step of . is short for self::node().</span>
      <span class="s3">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'Axis'</span><span class="s2">, </span><span class="s5">'self'</span><span class="s2">, </span><span class="s5">'node'</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s5">'..' </span><span class="s2">=== </span><span class="s1">abbrStep</span><span class="s2">)  </span><span class="s4">// A location step of .. is short for parent::node()</span>
      <span class="s3">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'Axis'</span><span class="s2">, </span><span class="s5">'parent'</span><span class="s2">, </span><span class="s5">'node'</span><span class="s2">);</span>

    <span class="s3">var </span><span class="s1">axis </span><span class="s2">= </span><span class="s1">axisSpecifier</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">nodeType </span><span class="s2">= </span><span class="s1">nodeTypeTest</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">nodeName</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeType</span><span class="s2">) </span><span class="s1">nodeName </span><span class="s2">= </span><span class="s1">nodeNameTest</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">axis </span><span class="s2">&amp;&amp; </span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeType </span><span class="s2">&amp;&amp; </span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeName</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeType </span><span class="s2">&amp;&amp; </span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeName</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span>
            <span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
            <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
            <span class="s5">': Expected nodeTest after axisSpecifier ' </span><span class="s2">+ </span><span class="s1">axis</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">axis</span><span class="s2">) </span><span class="s1">axis </span><span class="s2">= </span><span class="s5">'child'</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeType</span><span class="s2">) {</span>
      <span class="s4">// When there's only a node name, then the node type is forced to be the</span>
      <span class="s4">// principal node type of the axis.</span>
      <span class="s4">// see http://www.w3.org/TR/xpath/#dt-principal-node-type</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'attribute' </span><span class="s2">=== </span><span class="s1">axis</span><span class="s2">) </span><span class="s1">nodeType </span><span class="s2">= </span><span class="s5">'attribute'</span><span class="s2">;</span>
      <span class="s3">else if </span><span class="s2">(</span><span class="s5">'namespace' </span><span class="s2">=== </span><span class="s1">axis</span><span class="s2">) </span><span class="s1">nodeType </span><span class="s2">= </span><span class="s5">'namespace'</span><span class="s2">;</span>
      <span class="s3">else </span><span class="s1">nodeType </span><span class="s2">= </span><span class="s5">'element'</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">var </span><span class="s1">lhs </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'Axis'</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">nodeType</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">pred</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= (</span><span class="s1">pred </span><span class="s2">= </span><span class="s1">predicate</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">))) {</span>
      <span class="s1">lhs </span><span class="s2">= </span><span class="s1">pred</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">lhs</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** [5] AxisSpecifier::= AxisName '::' | AbbreviatedAxisSpecifier</span>
   <span class="s0">*  [6] AxisName::= 'ancestor' | 'ancestor-or-self' | 'attribute' | 'child'</span>
   <span class="s0">*                | 'descendant' | 'descendant-or-self' | 'following'</span>
   <span class="s0">*                | 'following-sibling' | 'namespace' | 'parent' |</span>
   <span class="s0">*                | 'preceding' | 'preceding-sibling' | 'self'</span>
   <span class="s0">*  [13] AbbreviatedAxisSpecifier::= '@'?</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">axisSpecifier</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">attr </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">'@'</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">attr</span><span class="s2">) </span><span class="s3">return </span><span class="s5">'attribute'</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">axisName </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypopaxisname</span><span class="s2">();</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">axisName</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">coloncolon </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">'::'</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">coloncolon</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Should not happen. Should be ::.'</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">axisName</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s0">/** [7] NodeTest::= NameTest | NodeType '(' ')' | 'processing-instruction' '(' Literal ')'</span>
   <span class="s0">*  [38] NodeType::= 'comment' | 'text' | 'processing-instruction' | 'node'</span>
   <span class="s0">* I've split nodeTypeTest from nodeNameTest for convenience.</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">nodeTypeTest</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s5">'(' </span><span class="s2">!== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">peek2</span><span class="s2">()) {</span>
      <span class="s3">return null</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">var </span><span class="s1">type </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">([</span><span class="s5">'comment'</span><span class="s2">, </span><span class="s5">'text'</span><span class="s2">, </span><span class="s5">'processing-instruction'</span><span class="s2">, </span><span class="s5">'node'</span><span class="s2">]);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">type</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">'('</span><span class="s2">))</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Should not happen.'</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">param </span><span class="s2">= </span><span class="s1">undefined</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">type </span><span class="s2">== </span><span class="s5">'processing-instruction'</span><span class="s2">) {</span>
        <span class="s1">param </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypopliteral</span><span class="s2">();</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">')'</span><span class="s2">))</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected close parens.'</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">type</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s3">function </span><span class="s1">nodeNameTest</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">name </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypopnametest</span><span class="s2">();</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">name </span><span class="s2">!= </span><span class="s3">null</span><span class="s2">) </span><span class="s3">return </span><span class="s1">name</span><span class="s2">;</span>
    <span class="s3">else return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** [8] Predicate::= '[' PredicateExpr ']'</span>
   <span class="s0">*  [9] PredicateExpr::= Expr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">predicate</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">'['</span><span class="s2">)) </span><span class="s3">return null</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">expr </span><span class="s2">= </span><span class="s1">orExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">expr</span><span class="s2">)</span>
      <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                               <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                               <span class="s5">': Expected expression after ['</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">']'</span><span class="s2">))</span>
      <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                               <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                               <span class="s5">': Expected ] after expression.'</span><span class="s2">);</span>
    <span class="s3">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'Predicate'</span><span class="s2">, </span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">expr</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s0">/** [14] Expr::= OrExpr</span>
   <span class="s0">*/</span>
  <span class="s0">/** [15] PrimaryExpr::= VariableReference | '(' Expr ')' | Literal | Number | FunctionCall</span>
   <span class="s0">* e.g. $x,  (3+4),  &quot;hi&quot;,  32,  f(x)</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">primaryExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">x </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypopliteral</span><span class="s2">();</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">x</span><span class="s2">)</span>
      <span class="s1">x </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypopnumber</span><span class="s2">();</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">x</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">x</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">var </span><span class="s1">varRef </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypopvarref</span><span class="s2">();</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">varRef</span><span class="s2">) </span><span class="s3">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'VariableReference'</span><span class="s2">, </span><span class="s1">varRef</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">funCall </span><span class="s2">= </span><span class="s1">functionCall</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">funCall</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">funCall</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">'('</span><span class="s2">)) {</span>
      <span class="s3">var </span><span class="s1">e </span><span class="s2">= </span><span class="s1">orExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">e</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected expression after (.'</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">')'</span><span class="s2">))</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected ) after expression.'</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">e</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** [16] FunctionCall::= FunctionName '(' ( Argument ( ',' Argument )* )? ')'</span>
   <span class="s0">*  [17] Argument::= Expr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">functionCall</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">name </span><span class="s2">= </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypopfuncname</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">name</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">'('</span><span class="s2">))</span>
      <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                               <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                               <span class="s5">': Expected ( ) after function name.'</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">params </span><span class="s2">= [];</span>
    <span class="s3">var </span><span class="s1">first </span><span class="s2">= </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">')'</span><span class="s2">)) {</span>
      <span class="s3">if </span><span class="s2">(!</span><span class="s1">first </span><span class="s2">&amp;&amp; </span><span class="s3">null </span><span class="s2">== </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">','</span><span class="s2">))</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected , between arguments of the function.'</span><span class="s2">);</span>
      <span class="s1">first </span><span class="s2">= </span><span class="s3">false</span><span class="s2">;</span>
      <span class="s3">var </span><span class="s1">param </span><span class="s2">= </span><span class="s1">orExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">param </span><span class="s2">== </span><span class="s3">null</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected expression as argument of function.'</span><span class="s2">);</span>
      <span class="s1">params</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">param</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'FunctionCall'</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">params</span><span class="s2">);</span>
  <span class="s2">}</span>

  <span class="s0">/** [18] UnionExpr::= PathExpr | UnionExpr '|' PathExpr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">unionExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">binaryL</span><span class="s2">(</span><span class="s1">pathExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s5">'|'</span><span class="s2">); }</span>
  <span class="s0">/** [19] PathExpr ::= LocationPath</span>
   <span class="s0">*                  | FilterExpr</span>
   <span class="s0">*                  | FilterExpr '/' RelativeLocationPath</span>
   <span class="s0">*                  | FilterExpr '//' RelativeLocationPath</span>
   <span class="s0">* Unlike most other nodes, this one always generates a node because</span>
   <span class="s0">* at this point all reverse nodesets must turn into a forward nodeset</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">pathExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s4">// We have to do FilterExpr before LocationPath because otherwise</span>
    <span class="s4">// LocationPath will eat up the name from a function call.</span>
    <span class="s3">var </span><span class="s1">filter </span><span class="s2">= </span><span class="s1">filterExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">filter</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">loc </span><span class="s2">= </span><span class="s1">locationPath</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">loc</span><span class="s2">) {</span>
        <span class="s3">throw new </span><span class="s1">Error</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': The expression shouldn</span><span class="s3">\'</span><span class="s5">t be empty...'</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'PathExpr'</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">var </span><span class="s1">rel </span><span class="s2">= </span><span class="s1">relativeLocationPath</span><span class="s2">(</span><span class="s1">filter</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s3">false</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">filter </span><span class="s2">=== </span><span class="s1">rel</span><span class="s2">) </span><span class="s3">return </span><span class="s1">rel</span><span class="s2">;</span>
    <span class="s3">else return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'PathExpr'</span><span class="s2">, </span><span class="s1">rel</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s0">/** [20] FilterExpr::= PrimaryExpr | FilterExpr Predicate</span>
   <span class="s0">* aka. FilterExpr ::= PrimaryExpr Predicate*</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">filterExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">primary </span><span class="s2">= </span><span class="s1">primaryExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">primary </span><span class="s2">== </span><span class="s3">null</span><span class="s2">) </span><span class="s3">return null</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">pred</span><span class="s2">, </span><span class="s1">lhs </span><span class="s2">= </span><span class="s1">primary</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= (</span><span class="s1">pred </span><span class="s2">= </span><span class="s1">predicate</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">))) {</span>
      <span class="s1">lhs </span><span class="s2">= </span><span class="s1">pred</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">lhs</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/** [21] OrExpr::= AndExpr | OrExpr 'or' AndExpr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">orExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">orig </span><span class="s2">= (</span><span class="s1">stream</span><span class="s2">.</span><span class="s1">peeked </span><span class="s2">|| </span><span class="s5">''</span><span class="s2">) + </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">str</span>
    <span class="s3">var </span><span class="s1">r </span><span class="s2">= </span><span class="s1">binaryL</span><span class="s2">(</span><span class="s1">andExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s5">'or'</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">now </span><span class="s2">= (</span><span class="s1">stream</span><span class="s2">.</span><span class="s1">peeked </span><span class="s2">|| </span><span class="s5">''</span><span class="s2">) + </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">str</span><span class="s2">;</span>
    <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** [22] AndExpr::= EqualityExpr | AndExpr 'and' EqualityExpr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">andExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">binaryL</span><span class="s2">(</span><span class="s1">equalityExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s5">'and'</span><span class="s2">); }</span>
  <span class="s0">/** [23] EqualityExpr::= RelationalExpr | EqualityExpr '=' RelationalExpr</span>
   <span class="s0">*                     | EqualityExpr '!=' RelationalExpr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">equalityExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">binaryL</span><span class="s2">(</span><span class="s1">relationalExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, [</span><span class="s5">'='</span><span class="s2">,</span><span class="s5">'!='</span><span class="s2">]); }</span>
  <span class="s0">/** [24] RelationalExpr::= AdditiveExpr | RelationalExpr '&lt;' AdditiveExpr</span>
   <span class="s0">*                       | RelationalExpr '&gt;' AdditiveExpr</span>
   <span class="s0">*                       | RelationalExpr '&lt;=' AdditiveExpr</span>
   <span class="s0">*                       | RelationalExpr '&gt;=' AdditiveExpr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">relationalExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">binaryL</span><span class="s2">(</span><span class="s1">additiveExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, [</span><span class="s5">'&lt;'</span><span class="s2">,</span><span class="s5">'&gt;'</span><span class="s2">,</span><span class="s5">'&lt;='</span><span class="s2">,</span><span class="s5">'&gt;='</span><span class="s2">]); }</span>
  <span class="s0">/** [25] AdditiveExpr::= MultiplicativeExpr</span>
   <span class="s0">*                     | AdditiveExpr '+' MultiplicativeExpr</span>
   <span class="s0">*                     | AdditiveExpr '-' MultiplicativeExpr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">additiveExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">binaryL</span><span class="s2">(</span><span class="s1">multiplicativeExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, [</span><span class="s5">'+'</span><span class="s2">,</span><span class="s5">'-'</span><span class="s2">]); }</span>
  <span class="s0">/** [26] MultiplicativeExpr::= UnaryExpr</span>
   <span class="s0">*                           | MultiplicativeExpr MultiplyOperator UnaryExpr</span>
   <span class="s0">*                           | MultiplicativeExpr 'div' UnaryExpr</span>
   <span class="s0">*                           | MultiplicativeExpr 'mod' UnaryExpr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">multiplicativeExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">binaryL</span><span class="s2">(</span><span class="s1">unaryExpr</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, [</span><span class="s5">'*'</span><span class="s2">,</span><span class="s5">'div'</span><span class="s2">,</span><span class="s5">'mod'</span><span class="s2">]); }</span>
  <span class="s0">/** [27] UnaryExpr::= UnionExpr | '-' UnaryExpr</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">unaryExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">stream</span><span class="s2">.</span><span class="s1">trypop</span><span class="s2">(</span><span class="s5">'-'</span><span class="s2">)) {</span>
      <span class="s3">var </span><span class="s1">e </span><span class="s2">= </span><span class="s1">unaryExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">e</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Expected unary expression after -'</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">a</span><span class="s2">.</span><span class="s1">node</span><span class="s2">(</span><span class="s5">'UnaryMinus'</span><span class="s2">, </span><span class="s1">e</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">else return </span><span class="s1">unionExpr</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s3">var </span><span class="s1">astFactory </span><span class="s2">= {</span>
    <span class="s1">node</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span><span class="s3">return </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">slice</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">arguments</span><span class="s2">);}</span>
  <span class="s2">};</span>


  <span class="s0">/***************************************************************************</span>
   <span class="s0">*                            Optimizations (TODO)                         *</span>
   <span class="s0">***************************************************************************/</span>
  <span class="s0">/**</span>
   <span class="s0">* Some things I've been considering:</span>
   <span class="s0">* 1) a//b becomes a/descendant::b if there's no predicate that uses</span>
   <span class="s0">*    position() or last()</span>
   <span class="s0">* 2) axis[pred]: when pred doesn't use position, evaluate it just once per</span>
   <span class="s0">*    node in the node-set rather than once per (node, position, last).</span>
   <span class="s0">* For more optimizations, look up Gecko's optimizer:</span>
   <span class="s0">* http://mxr.mozilla.org/mozilla-central/source/content/xslt/src/xpath/txXPathOptimizer.cpp</span>
   <span class="s0">*/</span>
  <span class="s4">// TODO</span>
  <span class="s3">function </span><span class="s1">optimize</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">) {</span>
  <span class="s2">}</span>

  <span class="s0">/***************************************************************************</span>
   <span class="s0">*                           Evaluation: axes                              *</span>
   <span class="s0">***************************************************************************/</span>

  <span class="s0">/**</span>
   <span class="s0">* Data types: For string, number, boolean, we just use Javascript types.</span>
   <span class="s0">* Node-sets have the form</span>
   <span class="s0">*    {nodes: [node, ...]}</span>
   <span class="s0">* or {nodes: [node, ...], pos: [[1], [2], ...], lasts: [[1], [2], ...]}</span>
   <span class="s0">*</span>
   <span class="s0">* Most of the time, only the node is used and the position information is</span>
   <span class="s0">* discarded. But if you use a predicate, we need to try every value of</span>
   <span class="s0">* position and last in case the predicate calls position() or last().</span>
   <span class="s0">*/</span>

  <span class="s0">/**</span>
   <span class="s0">* The NodeMultiSet is a helper class to help generate</span>
   <span class="s0">* {nodes:[], pos:[], lasts:[]} structures. It is useful for the</span>
   <span class="s0">* descendant, descendant-or-self, following-sibling, and</span>
   <span class="s0">* preceding-sibling axes for which we can use a stack to organize things.</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">NodeMultiSet</span><span class="s2">(</span><span class="s1">isReverseAxis</span><span class="s2">) {</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">nodes </span><span class="s2">= [];</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">pos </span><span class="s2">= [];</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">lasts </span><span class="s2">= [];</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos </span><span class="s2">= [];</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">seriesIndexes </span><span class="s2">= [];  </span><span class="s4">// index within nodes that each series begins.</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">isReverseAxis </span><span class="s2">= </span><span class="s1">isReverseAxis</span><span class="s2">;</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">_pushToNodes </span><span class="s2">= </span><span class="s1">isReverseAxis </span><span class="s2">? </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">unshift </span><span class="s2">: </span><span class="s1">Array</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">push</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s1">NodeMultiSet</span><span class="s2">.</span><span class="s1">prototype </span><span class="s2">= {</span>
    <span class="s1">pushSeries</span><span class="s2">: </span><span class="s3">function </span><span class="s1">pushSeries</span><span class="s2">() {</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s6">1</span><span class="s2">);</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">seriesIndexes</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s1">popSeries</span><span class="s2">: </span><span class="s3">function </span><span class="s1">popSeries</span><span class="s2">() {</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">length</span><span class="s2">, </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">last </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">() - </span><span class="s6">1</span><span class="s2">,</span>
          <span class="s1">indexInPos </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">length</span><span class="s2">,</span>
          <span class="s1">seriesBeginIndex </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">seriesIndexes</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">(),</span>
          <span class="s1">seriesEndIndex </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">;</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s1">seriesBeginIndex</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">seriesEndIndex</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">indexInPos </span><span class="s2">&lt; </span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">length</span><span class="s2">);</span>
        <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">undefined </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">indexInPos</span><span class="s2">]);</span>
        <span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">indexInPos</span><span class="s2">] = </span><span class="s1">last</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s1">finalize</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">) </span><span class="s3">return this</span><span class="s2">;</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">lastsJSON </span><span class="s2">= </span><span class="s1">JSON</span><span class="s2">.</span><span class="s1">stringify</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">);</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">j </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">j </span><span class="s2">&lt; </span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">j</span><span class="s2">) {</span>
          <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">], </span><span class="s1">i </span><span class="s2">+ </span><span class="s5">',' </span><span class="s2">+ </span><span class="s1">j </span><span class="s2">+ </span><span class="s5">':' </span><span class="s2">+ </span><span class="s1">lastsJSON</span><span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">pushSeries </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">popSeries </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">addNode </span><span class="s2">= </span><span class="s3">function</span><span class="s2">() {</span>
        <span class="s3">throw new </span><span class="s1">Error</span><span class="s2">(</span><span class="s5">'Already finalized.'</span><span class="s2">);</span>
      <span class="s2">};</span>
      <span class="s3">return this</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">addNode</span><span class="s2">: </span><span class="s3">function </span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">_pushToNodes</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">, </span><span class="s1">node</span><span class="s2">)</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">_pushToNodes</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">, </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">slice</span><span class="s2">());</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">_pushToNodes</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">, </span><span class="s3">new </span><span class="s1">Array</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">length</span><span class="s2">));</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nextPos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]++;</span>
    <span class="s2">},</span>
    <span class="s1">simplify</span><span class="s2">: </span><span class="s3">function</span><span class="s2">() {</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">();</span>
      <span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">:</span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">:</span><span class="s3">this</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">, </span><span class="s1">lasts</span><span class="s2">:</span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">};</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
  <span class="s3">function </span><span class="s1">eachContext</span><span class="s2">(</span><span class="s1">nodeMultiSet</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">r </span><span class="s2">= [];</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; </span><span class="s1">i</span><span class="s2">++) {</span>
      <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
      <span class="s3">if </span><span class="s2">(!</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">) {</span>
        <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">node</span><span class="s2">], </span><span class="s1">pos</span><span class="s2">: [[</span><span class="s1">i </span><span class="s2">+ </span><span class="s6">1</span><span class="s2">]], </span><span class="s1">lasts</span><span class="s2">: [[</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">]]});</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">j </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">j </span><span class="s2">&lt; </span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">j</span><span class="s2">) {</span>
          <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">node</span><span class="s2">], </span><span class="s1">pos</span><span class="s2">: [[</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">]]], </span><span class="s1">lasts</span><span class="s2">: [[</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">]]]});</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** Matcher used in the axes.</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">nodeTypeNum </span><span class="s2">= </span><span class="s1">nodeTypeNum</span><span class="s2">;</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">nodeName </span><span class="s2">= </span><span class="s1">nodeName</span><span class="s2">;</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">shouldLowerCase </span><span class="s2">= </span><span class="s1">shouldLowerCase</span><span class="s2">;</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">nodeNameTest </span><span class="s2">=</span>
      <span class="s3">null </span><span class="s2">== </span><span class="s1">nodeName </span><span class="s2">? </span><span class="s3">this</span><span class="s2">.</span><span class="s1">_alwaysTrue </span><span class="s2">:</span>
      <span class="s1">shouldLowerCase </span><span class="s2">? </span><span class="s3">this</span><span class="s2">.</span><span class="s1">_nodeNameLowerCaseEquals </span><span class="s2">:</span>
      <span class="s3">this</span><span class="s2">.</span><span class="s1">_nodeNameEquals</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s1">NodeMatcher</span><span class="s2">.</span><span class="s1">prototype </span><span class="s2">= {</span>
    <span class="s1">matches</span><span class="s2">: </span><span class="s3">function </span><span class="s1">matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodeTypeNum </span><span class="s2">|| </span><span class="s3">this</span><span class="s2">.</span><span class="s1">_nodeTypeMatches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">)) {</span>
        <span class="s3">return this</span><span class="s2">.</span><span class="s1">nodeNameTest</span><span class="s2">(</span><span class="s1">getNodeName</span><span class="s2">(</span><span class="s1">node</span><span class="s2">));</span>
      <span class="s2">}</span>

      <span class="s3">return false</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">_nodeTypeMatches</span><span class="s2">(</span><span class="s1">nodeOrAttr</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">nodeOrAttr</span><span class="s2">.</span><span class="s1">constructor</span><span class="s2">.</span><span class="s1">name </span><span class="s2">=== </span><span class="s5">'Attr' </span><span class="s2">&amp;&amp; </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodeTypeNum </span><span class="s2">=== </span><span class="s6">2</span><span class="s2">) {</span>
        <span class="s3">return true</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s1">nodeOrAttr</span><span class="s2">.</span><span class="s1">nodeType </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodeTypeNum</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">_alwaysTrue</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">name</span><span class="s2">) {</span><span class="s3">return true</span><span class="s2">;},</span>
    <span class="s1">_nodeNameEquals</span><span class="s2">: </span><span class="s3">function </span><span class="s1">_nodeNameEquals</span><span class="s2">(</span><span class="s1">name</span><span class="s2">) {</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">nodeName </span><span class="s2">=== </span><span class="s1">name</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">_nodeNameLowerCaseEquals</span><span class="s2">: </span><span class="s3">function </span><span class="s1">_nodeNameLowerCaseEquals</span><span class="s2">(</span><span class="s1">name</span><span class="s2">) {</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">nodeName </span><span class="s2">=== </span><span class="s1">name</span><span class="s2">.</span><span class="s1">toLowerCase</span><span class="s2">();</span>
    <span class="s2">}</span>
  <span class="s2">};</span>

  <span class="s3">function </span><span class="s1">followingSiblingHelper</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">, </span><span class="s1">shift</span><span class="s2">, </span><span class="s1">peek</span><span class="s2">, </span><span class="s1">followingNode</span><span class="s2">, </span><span class="s1">andSelf</span><span class="s2">, </span><span class="s1">isReverseAxis</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">nodeMultiSet </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMultiSet</span><span class="s2">(</span><span class="s1">isReverseAxis</span><span class="s2">);</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) {  </span><span class="s4">// can be if for following, preceding</span>
      <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">shift</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">);</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">node </span><span class="s2">!= </span><span class="s3">null</span><span class="s2">);</span>
      <span class="s1">node </span><span class="s2">= </span><span class="s1">followingNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
      <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pushSeries</span><span class="s2">();</span>
      <span class="s3">var </span><span class="s1">numPushed </span><span class="s2">= </span><span class="s6">1</span><span class="s2">;</span>
      <span class="s3">while </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(! </span><span class="s1">andSelf </span><span class="s2">&amp;&amp; </span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">))</span>
          <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">node </span><span class="s2">=== </span><span class="s1">peek</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">)) {</span>
          <span class="s1">shift</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">);</span>
          <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pushSeries</span><span class="s2">();</span>
          <span class="s1">numPushed</span><span class="s2">++;</span>
        <span class="s2">}</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">andSelf </span><span class="s2">&amp;&amp; </span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">))</span>
          <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
        <span class="s1">node </span><span class="s2">= </span><span class="s1">followingNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s3">while </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s1">numPushed</span><span class="s2">--)</span>
        <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">popSeries</span><span class="s2">();</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">nodeMultiSet</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/** Returns the next non-descendant node in document order.</span>
   <span class="s0">* This is the first node in following::node(), if node is the context.</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">followingNonDescendantNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">.</span><span class="s1">firstChild</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">.</span><span class="s1">firstChild</span><span class="s2">;</span>
      <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">do </span><span class="s2">{</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">nextSibling</span><span class="s2">) </span><span class="s3">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">nextSibling</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s3">while </span><span class="s2">(</span><span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">parentNode</span><span class="s2">);</span>
    <span class="s3">return null</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/** Returns the next node in a document-order depth-first search.</span>
   <span class="s0">* See the definition of document order[1]:</span>
   <span class="s0">*   1) element</span>
   <span class="s0">*   2) namespace nodes</span>
   <span class="s0">*   3) attributes</span>
   <span class="s0">*   4) children</span>
   <span class="s0">*   [1]: http://www.w3.org/TR/xpath/#dt-document-order</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">followingNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">)  </span><span class="s4">// attributes: following node of element.</span>
      <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">firstChild</span><span class="s2">)</span>
      <span class="s3">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">firstChild</span><span class="s2">;</span>
    <span class="s3">do </span><span class="s2">{</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">nextSibling</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">nextSibling</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">parentNode</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s3">while </span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
    <span class="s3">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** Returns the previous node in document order (excluding attributes</span>
   <span class="s0">* and namespace nodes).</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">precedingNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">)</span>
      <span class="s3">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">previousSibling</span><span class="s2">) {</span>
      <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">previousSibling</span><span class="s2">;</span>
      <span class="s3">while </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">lastChild</span><span class="s2">) {</span>
        <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">lastChild</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s1">node</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">parentNode</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">parentNode</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">return null</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** This axis is inefficient if there are many nodes in the nodeList.</span>
   <span class="s0">* But I think it's a pretty useless axis so it's ok. */</span>
  <span class="s3">function </span><span class="s1">followingHelper</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">nodeMultiSet </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMultiSet</span><span class="s2">(</span><span class="s3">false</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">cursor </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s6">0</span><span class="s2">];</span>
    <span class="s3">var </span><span class="s1">unorderedFollowingStarts </span><span class="s2">= [];</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; </span><span class="s1">i</span><span class="s2">++) {</span>
      <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
      <span class="s3">var </span><span class="s1">start </span><span class="s2">= </span><span class="s1">followingNonDescendantNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">start</span><span class="s2">)</span>
        <span class="s1">unorderedFollowingStarts</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">start</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">unorderedFollowingStarts</span><span class="s2">.</span><span class="s1">length</span><span class="s2">)</span>
      <span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">:[]};</span>
    <span class="s3">var </span><span class="s1">pos </span><span class="s2">= [], </span><span class="s1">nextPos </span><span class="s2">= [];</span>
    <span class="s3">var </span><span class="s1">started </span><span class="s2">= </span><span class="s6">0</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">cursor </span><span class="s2">= </span><span class="s1">followingNode</span><span class="s2">(</span><span class="s1">cursor</span><span class="s2">)) {</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s1">unorderedFollowingStarts</span><span class="s2">.</span><span class="s1">length </span><span class="s2">- </span><span class="s6">1</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i</span><span class="s2">--){</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">cursor </span><span class="s2">=== </span><span class="s1">unorderedFollowingStarts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]) {</span>
          <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pushSeries</span><span class="s2">();</span>
          <span class="s1">unorderedFollowingStarts</span><span class="s2">.</span><span class="s1">splice</span><span class="s2">(</span><span class="s1">i</span><span class="s2">,</span><span class="s1">i</span><span class="s2">+</span><span class="s6">1</span><span class="s2">);</span>
          <span class="s1">started</span><span class="s2">++;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">started </span><span class="s2">&amp;&amp; </span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">cursor</span><span class="s2">)) {</span>
        <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">cursor</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">unorderedFollowingStarts</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">started</span><span class="s2">; </span><span class="s1">i</span><span class="s2">++)</span>
      <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">popSeries</span><span class="s2">();</span>
    <span class="s3">return </span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">();</span>
  <span class="s2">}</span>
  <span class="s3">function </span><span class="s1">precedingHelper</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">cursor </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">();</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">cursor</span><span class="s2">) </span><span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">:{}};</span>
    <span class="s3">var </span><span class="s1">r </span><span class="s2">= {</span><span class="s1">nodes</span><span class="s2">:[], </span><span class="s1">pos</span><span class="s2">:[], </span><span class="s1">lasts</span><span class="s2">:[]};</span>
    <span class="s3">var </span><span class="s1">nextParents </span><span class="s2">= [</span><span class="s1">cursor</span><span class="s2">.</span><span class="s1">parentNode </span><span class="s2">|| </span><span class="s1">cursor</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">], </span><span class="s1">nextPos </span><span class="s2">= [</span><span class="s6">1</span><span class="s2">];</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">cursor </span><span class="s2">= </span><span class="s1">precedingNode</span><span class="s2">(</span><span class="s1">cursor</span><span class="s2">)) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">cursor </span><span class="s2">=== </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length </span><span class="s2">- </span><span class="s6">1</span><span class="s2">]) {</span>
        <span class="s1">nextParents</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">());</span>
        <span class="s1">nextPos</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s6">1</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s3">var </span><span class="s1">matches </span><span class="s2">= </span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">cursor</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">someoneUsed </span><span class="s2">= </span><span class="s3">false</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">matches</span><span class="s2">)</span>
        <span class="s1">pos </span><span class="s2">= </span><span class="s1">nextPos</span><span class="s2">.</span><span class="s1">slice</span><span class="s2">();</span>

      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nextParents</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">cursor </span><span class="s2">=== </span><span class="s1">nextParents</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]) {</span>
          <span class="s1">nextParents</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">cursor</span><span class="s2">.</span><span class="s1">parentNode </span><span class="s2">|| </span><span class="s1">cursor</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">;</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">matches</span><span class="s2">) {</span>
            <span class="s1">pos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s3">null</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">matches</span><span class="s2">) {</span>
            <span class="s1">pos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">] = </span><span class="s1">nextPos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]++;</span>
            <span class="s1">someoneUsed </span><span class="s2">= </span><span class="s3">true</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">someoneUsed</span><span class="s2">) {</span>
        <span class="s1">r</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">unshift</span><span class="s2">(</span><span class="s1">cursor</span><span class="s2">);</span>
        <span class="s1">r</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">.</span><span class="s1">unshift</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">r</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">lasts </span><span class="s2">= [];</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">lasts</span><span class="s2">);</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">j </span><span class="s2">= </span><span class="s1">r</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">length </span><span class="s2">- </span><span class="s6">1</span><span class="s2">; </span><span class="s1">j </span><span class="s2">&gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">j</span><span class="s2">--) {</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">r</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">j</span><span class="s2">]) {</span>
          <span class="s1">r</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">splice</span><span class="s2">(</span><span class="s1">j</span><span class="s2">, </span><span class="s1">j</span><span class="s2">+</span><span class="s6">1</span><span class="s2">);</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
          <span class="s1">lasts</span><span class="s2">.</span><span class="s1">unshift</span><span class="s2">(</span><span class="s1">nextPos</span><span class="s2">[</span><span class="s1">j</span><span class="s2">] - </span><span class="s6">1</span><span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/** node-set, axis -&gt; node-set */</span>
  <span class="s3">function </span><span class="s1">descendantDfs</span><span class="s2">(</span><span class="s1">nodeMultiSet</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">remaining</span><span class="s2">, </span><span class="s1">matcher</span><span class="s2">, </span><span class="s1">andSelf</span><span class="s2">, </span><span class="s1">attrIndices</span><span class="s2">, </span><span class="s1">attrNodes</span><span class="s2">) {</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s1">remaining</span><span class="s2">.</span><span class="s1">length </span><span class="s2">&amp;&amp; </span><span class="s3">null </span><span class="s2">!= </span><span class="s1">remaining</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">ownerElement</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">attr </span><span class="s2">= </span><span class="s1">remaining</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">andSelf </span><span class="s2">&amp;&amp; </span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)) {</span>
        <span class="s1">attrNodes</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">);</span>
        <span class="s1">attrIndices</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node </span><span class="s2">&amp;&amp; !</span><span class="s1">andSelf</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">))</span>
        <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">var </span><span class="s1">pushed </span><span class="s2">= </span><span class="s3">false</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">node</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">remaining</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) </span><span class="s3">return</span><span class="s2">;</span>
      <span class="s1">node </span><span class="s2">= </span><span class="s1">remaining</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
      <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pushSeries</span><span class="s2">();</span>
      <span class="s1">pushed </span><span class="s2">= </span><span class="s3">true</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s1">remaining</span><span class="s2">.</span><span class="s1">length </span><span class="s2">&amp;&amp; </span><span class="s1">node </span><span class="s2">=== </span><span class="s1">remaining</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) {</span>
      <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pushSeries</span><span class="s2">();</span>
      <span class="s1">pushed </span><span class="s2">= </span><span class="s3">true</span><span class="s2">;</span>
      <span class="s1">remaining</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">andSelf</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">))</span>
        <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">// TODO: use optimization. Also try element.getElementsByTagName</span>
    <span class="s4">// var nodeList = 1 === nodeTypeNum &amp;&amp; null != node.children ? node.children : node.childNodes;</span>
    <span class="s3">var </span><span class="s1">nodeList </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">childNodes</span><span class="s2">;</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">j </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">j </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">j</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">child </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">j</span><span class="s2">];</span>
      <span class="s1">descendantDfs</span><span class="s2">(</span><span class="s1">nodeMultiSet</span><span class="s2">, </span><span class="s1">child</span><span class="s2">, </span><span class="s1">remaining</span><span class="s2">, </span><span class="s1">matcher</span><span class="s2">, </span><span class="s1">andSelf</span><span class="s2">, </span><span class="s1">attrIndices</span><span class="s2">, </span><span class="s1">attrNodes</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">pushed</span><span class="s2">) {</span>
      <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">popSeries</span><span class="s2">();</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s3">function </span><span class="s1">descenantHelper</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">, </span><span class="s1">andSelf</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">nodeMultiSet </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMultiSet</span><span class="s2">(</span><span class="s3">false</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">attrIndices </span><span class="s2">= [], </span><span class="s1">attrNodes </span><span class="s2">= [];</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) {</span>
      <span class="s4">// var node = nodeList.shift();</span>
      <span class="s1">descendantDfs</span><span class="s2">(</span><span class="s1">nodeMultiSet</span><span class="s2">, </span><span class="s3">null</span><span class="s2">, </span><span class="s1">nodeList</span><span class="s2">, </span><span class="s1">matcher</span><span class="s2">, </span><span class="s1">andSelf</span><span class="s2">, </span><span class="s1">attrIndices</span><span class="s2">, </span><span class="s1">attrNodes</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">();</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s1">attrNodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">-</span><span class="s6">1</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&gt;= </span><span class="s6">0</span><span class="s2">; --</span><span class="s1">i</span><span class="s2">) {</span>
      <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">splice</span><span class="s2">(</span><span class="s1">attrIndices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">attrIndices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">attrNodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]);</span>
      <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">.</span><span class="s1">splice</span><span class="s2">(</span><span class="s1">attrIndices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">attrIndices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], [</span><span class="s6">1</span><span class="s2">]);</span>
      <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">.</span><span class="s1">splice</span><span class="s2">(</span><span class="s1">attrIndices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">attrIndices</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], [</span><span class="s6">1</span><span class="s2">]);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">nodeMultiSet</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/**</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">ancestorHelper</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">, </span><span class="s1">andSelf</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">ancestors </span><span class="s2">= []; </span><span class="s4">// array of non-empty arrays of matching ancestors</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
      <span class="s3">var </span><span class="s1">isFirst </span><span class="s2">= </span><span class="s3">true</span><span class="s2">;</span>
      <span class="s3">var </span><span class="s1">a </span><span class="s2">= [];</span>
      <span class="s3">while </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(!</span><span class="s1">isFirst </span><span class="s2">|| </span><span class="s1">andSelf</span><span class="s2">) {</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">node</span><span class="s2">))</span>
            <span class="s1">a</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
        <span class="s2">}</span>
        <span class="s1">isFirst </span><span class="s2">= </span><span class="s3">false</span><span class="s2">;</span>
        <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">parentNode </span><span class="s2">|| </span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s1">a</span><span class="s2">.</span><span class="s1">length</span><span class="s2">)</span>
        <span class="s1">ancestors</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">a</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">var </span><span class="s1">lasts </span><span class="s2">= [];</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">ancestors</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) </span><span class="s1">lasts</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">ancestors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">length</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">nodeMultiSet </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMultiSet</span><span class="s2">(</span><span class="s3">true</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">newCtx </span><span class="s2">= {</span><span class="s1">nodes</span><span class="s2">:[], </span><span class="s1">pos</span><span class="s2">:[], </span><span class="s1">lasts</span><span class="s2">:[]};</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s1">ancestors</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">pos </span><span class="s2">= [</span><span class="s1">ancestors</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">length</span><span class="s2">];</span>
      <span class="s3">var </span><span class="s1">last </span><span class="s2">= [</span><span class="s1">lasts</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]];</span>
      <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">ancestors</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">pop</span><span class="s2">();</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s1">ancestors</span><span class="s2">.</span><span class="s1">length </span><span class="s2">- </span><span class="s6">1</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">; --</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">node </span><span class="s2">=== </span><span class="s1">ancestors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s1">ancestors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">length </span><span class="s2">- </span><span class="s6">1</span><span class="s2">]) {</span>
          <span class="s1">pos</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">ancestors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">length</span><span class="s2">);</span>
          <span class="s1">last</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">lasts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]);</span>
          <span class="s1">ancestors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">pop</span><span class="s2">();</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">ancestors</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">length</span><span class="s2">) {</span>
            <span class="s1">ancestors</span><span class="s2">.</span><span class="s1">splice</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">i</span><span class="s2">+</span><span class="s6">1</span><span class="s2">);</span>
            <span class="s1">lasts</span><span class="s2">.</span><span class="s1">splice</span><span class="s2">(</span><span class="s1">i</span><span class="s2">, </span><span class="s1">i</span><span class="s2">+</span><span class="s6">1</span><span class="s2">);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">ancestors</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">length</span><span class="s2">) {</span>
        <span class="s1">ancestors</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
        <span class="s1">lasts</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
      <span class="s2">}</span>
      <span class="s1">newCtx</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
      <span class="s1">newCtx</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">pos</span><span class="s2">);</span>
      <span class="s1">newCtx</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">last</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">newCtx</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** Helper function for sortDocumentOrder. Returns a list of indices, from the</span>
   <span class="s0">* node to the root, of positions within parent.</span>
   <span class="s0">* For convenience, the node is the first element of the array.</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">addressVector</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">r </span><span class="s2">= [</span><span class="s1">node</span><span class="s2">];</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">) {</span>
      <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">;</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(-</span><span class="s6">1</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">;</span>
      <span class="s3">while </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">previousSibling</span><span class="s2">) {</span>
        <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">previousSibling</span><span class="s2">;</span>
        <span class="s1">i</span><span class="s2">++;</span>
      <span class="s2">}</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">i</span><span class="s2">);</span>
      <span class="s1">node </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">parentNode</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s3">function </span><span class="s1">addressComparator</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">minlen </span><span class="s2">= </span><span class="s1">Math</span><span class="s2">.</span><span class="s1">min</span><span class="s2">(</span><span class="s1">a</span><span class="s2">.</span><span class="s1">length </span><span class="s2">- </span><span class="s6">1</span><span class="s2">, </span><span class="s1">b</span><span class="s2">.</span><span class="s1">length </span><span class="s2">- </span><span class="s6">1</span><span class="s2">),  </span><span class="s4">// not including [0]=node</span>
        <span class="s1">alen </span><span class="s2">= </span><span class="s1">a</span><span class="s2">.</span><span class="s1">length</span><span class="s2">,</span>
        <span class="s1">blen </span><span class="s2">= </span><span class="s1">b</span><span class="s2">.</span><span class="s1">length</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] === </span><span class="s1">b</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) </span><span class="s3">return </span><span class="s6">0</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">c</span><span class="s2">;</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">minlen</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
      <span class="s1">c </span><span class="s2">= </span><span class="s1">a</span><span class="s2">[</span><span class="s1">alen </span><span class="s2">- </span><span class="s1">i </span><span class="s2">- </span><span class="s6">1</span><span class="s2">] - </span><span class="s1">b</span><span class="s2">[</span><span class="s1">blen </span><span class="s2">- </span><span class="s1">i </span><span class="s2">- </span><span class="s6">1</span><span class="s2">];</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">!== </span><span class="s1">c</span><span class="s2">)</span>
        <span class="s3">break</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">c </span><span class="s2">|| </span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">c</span><span class="s2">) {</span>
      <span class="s4">// All equal until one of the nodes. The longer one is the descendant.</span>
      <span class="s1">c </span><span class="s2">= </span><span class="s1">alen </span><span class="s2">- </span><span class="s1">blen</span><span class="s2">;</span>
    <span class="s2">}</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">c</span><span class="s2">)</span>
      <span class="s1">c </span><span class="s2">= </span><span class="s1">getNodeName</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) - </span><span class="s1">getNodeName</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">c</span><span class="s2">)</span>
      <span class="s1">c </span><span class="s2">= </span><span class="s6">1</span><span class="s2">;</span>
    <span class="s3">return </span><span class="s1">c</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s3">var </span><span class="s1">sortUniqDocumentOrder </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">sortUniqDocumentOrder </span><span class="s2">= </span><span class="s3">function</span><span class="s2">(</span><span class="s1">nodes</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">a </span><span class="s2">= [];</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; </span><span class="s1">i</span><span class="s2">++) {</span>
      <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
      <span class="s3">var </span><span class="s1">v </span><span class="s2">= </span><span class="s1">addressVector</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
      <span class="s1">a</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">v</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s1">a</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">addressComparator</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">b </span><span class="s2">= [];</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">a</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; </span><span class="s1">i</span><span class="s2">++) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">&lt; </span><span class="s1">i </span><span class="s2">&amp;&amp; </span><span class="s1">a</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s6">0</span><span class="s2">] === </span><span class="s1">a</span><span class="s2">[</span><span class="s1">i </span><span class="s2">- </span><span class="s6">1</span><span class="s2">][</span><span class="s6">0</span><span class="s2">])</span>
        <span class="s3">continue</span><span class="s2">;</span>
      <span class="s1">b</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s1">i</span><span class="s2">][</span><span class="s6">0</span><span class="s2">]);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">b</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** Sort node multiset. Does not do any de-duping. */</span>
  <span class="s3">function </span><span class="s1">sortNodeMultiSet</span><span class="s2">(</span><span class="s1">nodeMultiSet</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">a </span><span class="s2">= [];</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; </span><span class="s1">i</span><span class="s2">++) {</span>
      <span class="s3">var </span><span class="s1">v </span><span class="s2">= </span><span class="s1">addressVector</span><span class="s2">(</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]);</span>
      <span class="s1">a</span><span class="s2">.</span><span class="s1">push</span><span class="s2">({</span><span class="s1">v</span><span class="s2">:</span><span class="s1">v</span><span class="s2">, </span><span class="s1">n</span><span class="s2">:</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">],</span>
              <span class="s1">p</span><span class="s2">:</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">l</span><span class="s2">:</span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]});</span>
    <span class="s2">}</span>
    <span class="s1">a</span><span class="s2">.</span><span class="s1">sort</span><span class="s2">(</span><span class="s1">compare</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">r </span><span class="s2">= {</span><span class="s1">nodes</span><span class="s2">:[], </span><span class="s1">pos</span><span class="s2">:[], </span><span class="s1">lasts</span><span class="s2">:[]};</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">a</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">n</span><span class="s2">);</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">p</span><span class="s2">);</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">a</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">l</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">function </span><span class="s1">compare</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">addressComparator</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">v</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">v</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s0">/** Returns an array containing all the ancestors down to a node.</span>
   <span class="s0">* The array starts with document.</span>
   <span class="s0">*/</span>
  <span class="s3">function </span><span class="s1">nodeAndAncestors</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">ancestors </span><span class="s2">= [</span><span class="s1">node</span><span class="s2">];</span>
    <span class="s3">var </span><span class="s1">p </span><span class="s2">= </span><span class="s1">node</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">p </span><span class="s2">= </span><span class="s1">p</span><span class="s2">.</span><span class="s1">parentNode </span><span class="s2">|| </span><span class="s1">p</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">) {</span>
      <span class="s1">ancestors</span><span class="s2">.</span><span class="s1">unshift</span><span class="s2">(</span><span class="s1">p</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">ancestors</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s3">function </span><span class="s1">compareSiblings</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">a </span><span class="s2">=== </span><span class="s1">b</span><span class="s2">) </span><span class="s3">return </span><span class="s6">0</span><span class="s2">;</span>
    <span class="s3">var </span><span class="s1">c </span><span class="s2">= </span><span class="s1">a</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">c </span><span class="s2">= </span><span class="s1">c</span><span class="s2">.</span><span class="s1">previousSibling</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">c </span><span class="s2">=== </span><span class="s1">b</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s6">1</span><span class="s2">;  </span><span class="s4">// b &lt; a</span>
    <span class="s2">}</span>
    <span class="s1">c </span><span class="s2">= </span><span class="s1">b</span><span class="s2">;</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">c </span><span class="s2">= </span><span class="s1">c</span><span class="s2">.</span><span class="s1">previousSibling</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">c </span><span class="s2">=== </span><span class="s1">a</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s2">-</span><span class="s6">1</span><span class="s2">;  </span><span class="s4">// a &lt; b</span>
    <span class="s2">}</span>
    <span class="s3">throw new </span><span class="s1">Error</span><span class="s2">(</span><span class="s5">'a and b are not siblings: ' </span><span class="s2">+ </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">stringifyObject</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) + </span><span class="s5">' vs ' </span><span class="s2">+ </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">stringifyObject</span><span class="s2">(</span><span class="s1">b</span><span class="s2">));</span>
  <span class="s2">}</span>
  <span class="s0">/** The merge in merge-sort.*/</span>
  <span class="s3">function </span><span class="s1">mergeNodeLists</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">aanc</span><span class="s2">, </span><span class="s1">banc</span><span class="s2">, </span><span class="s1">r </span><span class="s2">= [];</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">!== </span><span class="s3">typeof </span><span class="s1">x</span><span class="s2">)</span>
      <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                               <span class="s5">'Invalid LHS for | operator ' </span><span class="s2">+</span>
                               <span class="s5">'(expected node-set): ' </span><span class="s2">+ </span><span class="s1">x</span><span class="s2">);</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">!== </span><span class="s3">typeof </span><span class="s1">y</span><span class="s2">)</span>
      <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                               <span class="s5">'Invalid LHS for | operator ' </span><span class="s2">+</span>
                               <span class="s5">'(expected node-set): ' </span><span class="s2">+ </span><span class="s1">y</span><span class="s2">);</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s3">true</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">a</span><span class="s2">) {</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">a</span><span class="s2">)</span>
          <span class="s1">aanc </span><span class="s2">= </span><span class="s1">addressVector</span><span class="s2">(</span><span class="s1">a</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">b</span><span class="s2">) {</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">b</span><span class="s2">)</span>
          <span class="s1">banc </span><span class="s2">= </span><span class="s1">addressVector</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">a </span><span class="s2">|| </span><span class="s3">null </span><span class="s2">== </span><span class="s1">b</span><span class="s2">) </span><span class="s3">break</span><span class="s2">;</span>
      <span class="s3">var </span><span class="s1">c </span><span class="s2">= </span><span class="s1">addressComparator</span><span class="s2">(</span><span class="s1">aanc</span><span class="s2">, </span><span class="s1">banc</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">c </span><span class="s2">&lt; </span><span class="s6">0</span><span class="s2">) {</span>
        <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">a</span><span class="s2">);</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
        <span class="s1">aanc </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s1">c </span><span class="s2">&gt; </span><span class="s6">0</span><span class="s2">) {</span>
        <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
        <span class="s1">banc </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s1">getNodeName</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) &lt; </span><span class="s1">getNodeName</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)) {  </span><span class="s4">// attributes</span>
        <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">a</span><span class="s2">);</span>
        <span class="s1">a </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
        <span class="s1">aanc </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s1">getNodeName</span><span class="s2">(</span><span class="s1">a</span><span class="s2">) &gt; </span><span class="s1">getNodeName</span><span class="s2">(</span><span class="s1">b</span><span class="s2">)) {  </span><span class="s4">// attributes</span>
        <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
        <span class="s1">banc </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s1">a </span><span class="s2">!== </span><span class="s1">b</span><span class="s2">) {</span>
        <span class="s4">// choose b arbitrarily</span>
        <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
        <span class="s1">banc </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">a </span><span class="s2">=== </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">);</span>
        <span class="s4">// just skip b without pushing it.</span>
        <span class="s1">b </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
        <span class="s1">banc </span><span class="s2">= </span><span class="s3">null</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">a</span><span class="s2">) {</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">a</span><span class="s2">);</span>
      <span class="s1">a </span><span class="s2">= </span><span class="s1">x</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
    <span class="s2">}</span>
    <span class="s3">while </span><span class="s2">(</span><span class="s1">b</span><span class="s2">) {</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
      <span class="s1">b </span><span class="s2">= </span><span class="s1">y</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">();</span>
    <span class="s2">}</span>
    <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s3">function </span><span class="s1">comparisonHelper</span><span class="s2">(</span><span class="s1">test</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">isNumericComparison</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">coersion</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s1">isNumericComparison</span><span class="s2">)</span>
      <span class="s1">coersion </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">;</span>
    <span class="s3">else </span><span class="s1">coersion </span><span class="s2">=</span>
      <span class="s5">'boolean' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">x </span><span class="s2">|| </span><span class="s5">'boolean' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">y </span><span class="s2">? </span><span class="s1">fn</span><span class="s2">[</span><span class="s5">'boolean'</span><span class="s2">] :</span>
      <span class="s5">'number' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">x </span><span class="s2">|| </span><span class="s5">'number' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">y </span><span class="s2">? </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number </span><span class="s2">:</span>
      <span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">x </span><span class="s2">&amp;&amp; </span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">y</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">aMap </span><span class="s2">= {};</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">xi </span><span class="s2">= </span><span class="s1">coersion</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]});</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">j </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">j </span><span class="s2">&lt; </span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">j</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">yj </span><span class="s2">= </span><span class="s1">coersion</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">j</span><span class="s2">]]});</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">test</span><span class="s2">(</span><span class="s1">xi</span><span class="s2">, </span><span class="s1">yj</span><span class="s2">)) </span><span class="s3">return true</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">return false</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">x </span><span class="s2">&amp;&amp; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes </span><span class="s2">&amp;&amp; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) {</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">xi </span><span class="s2">= </span><span class="s1">coersion</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]}), </span><span class="s1">yc </span><span class="s2">= </span><span class="s1">coersion</span><span class="s2">(</span><span class="s1">y</span><span class="s2">);</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">test</span><span class="s2">(</span><span class="s1">xi</span><span class="s2">, </span><span class="s1">yc</span><span class="s2">))</span>
          <span class="s3">return true</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">return false</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">y </span><span class="s2">&amp;&amp; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes </span><span class="s2">&amp;&amp; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) {</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">yi </span><span class="s2">= </span><span class="s1">coersion</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]}), </span><span class="s1">xc </span><span class="s2">= </span><span class="s1">coersion</span><span class="s2">(</span><span class="s1">x</span><span class="s2">);</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">test</span><span class="s2">(</span><span class="s1">xc</span><span class="s2">, </span><span class="s1">yi</span><span class="s2">))</span>
          <span class="s3">return true</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">return false</span><span class="s2">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">var </span><span class="s1">xc </span><span class="s2">= </span><span class="s1">coersion</span><span class="s2">(</span><span class="s1">x</span><span class="s2">), </span><span class="s1">yc </span><span class="s2">= </span><span class="s1">coersion</span><span class="s2">(</span><span class="s1">y</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">test</span><span class="s2">(</span><span class="s1">xc</span><span class="s2">, </span><span class="s1">yc</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s3">var </span><span class="s1">axes </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">axes </span><span class="s2">= {</span>
    <span class="s5">'ancestor'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">ancestor</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">ancestorHelper</span><span class="s2">(</span>
          <span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">, </span><span class="s3">false</span><span class="s2">);</span>
      <span class="s2">},</span>
    <span class="s5">'ancestor-or-self'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">ancestorOrSelf</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">ancestorHelper</span><span class="s2">(</span>
          <span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">, </span><span class="s3">true</span><span class="s2">);</span>
      <span class="s2">},</span>
    <span class="s5">'attribute'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">attribute</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s4">// TODO: figure out whether positions should be undefined here.</span>
        <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
        <span class="s3">var </span><span class="s1">nodeMultiSet </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMultiSet</span><span class="s2">(</span><span class="s3">false</span><span class="s2">);</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">nodeName</span><span class="s2">) {</span>
          <span class="s4">// TODO: with namespace</span>
          <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
            <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
            <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">node</span><span class="s2">.</span><span class="s1">getAttributeNode</span><span class="s2">)</span>
              <span class="s3">continue</span><span class="s2">;  </span><span class="s4">// only Element has .getAttributeNode</span>
            <span class="s3">var </span><span class="s1">attr </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">getAttributeNode</span><span class="s2">(</span><span class="s1">nodeName</span><span class="s2">);</span>
            <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">attr </span><span class="s2">&amp;&amp; </span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">)) {</span>
              <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pushSeries</span><span class="s2">();</span>
              <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">);</span>
              <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">popSeries</span><span class="s2">();</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
          <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
            <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
            <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">attributes</span><span class="s2">) {</span>
              <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pushSeries</span><span class="s2">();</span>
              <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">j </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">j </span><span class="s2">&lt; </span><span class="s1">node</span><span class="s2">.</span><span class="s1">attributes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; </span><span class="s1">j</span><span class="s2">++) {  </span><span class="s4">// all nodes have .attributes</span>
                <span class="s3">var </span><span class="s1">attr </span><span class="s2">= </span><span class="s1">node</span><span class="s2">.</span><span class="s1">attributes</span><span class="s2">[</span><span class="s1">j</span><span class="s2">];</span>
                <span class="s3">if </span><span class="s2">(</span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">))  </span><span class="s4">// TODO: I think this check is unnecessary</span>
                  <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">attr</span><span class="s2">);</span>
              <span class="s2">}</span>
              <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">popSeries</span><span class="s2">();</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">();</span>
      <span class="s2">},</span>
    <span class="s5">'child'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">child</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
        <span class="s3">var </span><span class="s1">nodeMultiSet </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMultiSet</span><span class="s2">(</span><span class="s3">false</span><span class="s2">);</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">n </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">n</span><span class="s2">.</span><span class="s1">ownerElement</span><span class="s2">)  </span><span class="s4">// skip attribute nodes' text child.</span>
            <span class="s3">continue</span><span class="s2">;</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">n</span><span class="s2">.</span><span class="s1">childNodes</span><span class="s2">) {</span>
            <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">pushSeries</span><span class="s2">();</span>
            <span class="s3">var </span><span class="s1">childList </span><span class="s2">= </span><span class="s6">1 </span><span class="s2">=== </span><span class="s1">nodeTypeNum </span><span class="s2">&amp;&amp; </span><span class="s3">null </span><span class="s2">!= </span><span class="s1">n</span><span class="s2">.</span><span class="s1">children </span><span class="s2">?</span>
                <span class="s1">n</span><span class="s2">.</span><span class="s1">children </span><span class="s2">: </span><span class="s1">n</span><span class="s2">.</span><span class="s1">childNodes</span><span class="s2">;</span>
            <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">j </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">j </span><span class="s2">&lt; </span><span class="s1">childList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">j</span><span class="s2">) {</span>
              <span class="s3">var </span><span class="s1">child </span><span class="s2">= </span><span class="s1">childList</span><span class="s2">[</span><span class="s1">j</span><span class="s2">];</span>
              <span class="s3">if </span><span class="s2">(</span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">child</span><span class="s2">)) {</span>
                <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">addNode</span><span class="s2">(</span><span class="s1">child</span><span class="s2">);</span>
              <span class="s2">}</span>
              <span class="s4">// don't have to do de-duping because children have parent,</span>
              <span class="s4">// which are current context.</span>
            <span class="s2">}</span>
            <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">popSeries</span><span class="s2">();</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s1">nodeMultiSet</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">();</span>
        <span class="s3">return </span><span class="s1">sortNodeMultiSet</span><span class="s2">(</span><span class="s1">nodeMultiSet</span><span class="s2">);</span>
      <span class="s2">},</span>
    <span class="s5">'descendant'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">descenant</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">descenantHelper</span><span class="s2">(</span>
          <span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">, </span><span class="s3">false</span><span class="s2">);</span>
      <span class="s2">},</span>
    <span class="s5">'descendant-or-self'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">descenantOrSelf</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">descenantHelper</span><span class="s2">(</span>
          <span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">, </span><span class="s3">true</span><span class="s2">);</span>
      <span class="s2">},</span>
    <span class="s5">'following'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">following</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">followingHelper</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
      <span class="s2">},</span>
    <span class="s5">'following-sibling'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">followingSibling</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">followingSiblingHelper</span><span class="s2">(</span>
          <span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">,</span>
          <span class="s1">Array</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">shift</span><span class="s2">, </span><span class="s3">function</span><span class="s2">() {</span><span class="s3">return this</span><span class="s2">[</span><span class="s6">0</span><span class="s2">];},</span>
          <span class="s3">function</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span><span class="s3">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">nextSibling</span><span class="s2">;});</span>
      <span class="s2">},</span>
    <span class="s5">'namespace'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">namespace</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s4">// TODO</span>
      <span class="s2">},</span>
    <span class="s5">'parent'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">parent</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
        <span class="s3">var </span><span class="s1">nodes </span><span class="s2">= [], </span><span class="s1">pos </span><span class="s2">= [];</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">parent </span><span class="s2">= </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">parentNode </span><span class="s2">|| </span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">].</span><span class="s1">ownerElement</span><span class="s2">;</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">parent</span><span class="s2">)</span>
            <span class="s3">continue</span><span class="s2">;</span>
          <span class="s3">if </span><span class="s2">(!</span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">))</span>
            <span class="s3">continue</span><span class="s2">;</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length </span><span class="s2">&gt; </span><span class="s6">0 </span><span class="s2">&amp;&amp; </span><span class="s1">parent </span><span class="s2">=== </span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">-</span><span class="s6">1</span><span class="s2">])</span>
            <span class="s3">continue</span><span class="s2">;</span>
          <span class="s1">nodes</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">parent</span><span class="s2">);</span>
          <span class="s1">pos</span><span class="s2">.</span><span class="s1">push</span><span class="s2">([</span><span class="s6">1</span><span class="s2">]);</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">:</span><span class="s1">nodes</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">:</span><span class="s1">pos</span><span class="s2">, </span><span class="s1">lasts</span><span class="s2">:</span><span class="s1">pos</span><span class="s2">};</span>
      <span class="s2">},</span>
    <span class="s5">'preceding'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">preceding</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">precedingHelper</span><span class="s2">(</span>
          <span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
      <span class="s2">},</span>
    <span class="s5">'preceding-sibling'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">precedingSibling</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">return </span><span class="s1">followingSiblingHelper</span><span class="s2">(</span>
          <span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">,</span>
          <span class="s1">Array</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">pop</span><span class="s2">, </span><span class="s3">function</span><span class="s2">() {</span><span class="s3">return this</span><span class="s2">[</span><span class="s3">this</span><span class="s2">.</span><span class="s1">length</span><span class="s2">-</span><span class="s6">1</span><span class="s2">];},</span>
          <span class="s3">function</span><span class="s2">(</span><span class="s1">node</span><span class="s2">) {</span><span class="s3">return </span><span class="s1">node</span><span class="s2">.</span><span class="s1">previousSibling</span><span class="s2">},</span>
          <span class="s3">false</span><span class="s2">, </span><span class="s3">true</span><span class="s2">);</span>
      <span class="s2">},</span>
    <span class="s5">'self'</span><span class="s2">:</span>
      <span class="s3">function </span><span class="s1">self</span><span class="s2">(</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">nodes </span><span class="s2">= [], </span><span class="s1">pos </span><span class="s2">= [];</span>
        <span class="s3">var </span><span class="s1">matcher </span><span class="s2">= </span><span class="s3">new </span><span class="s1">NodeMatcher</span><span class="s2">(</span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">nodeList</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">matcher</span><span class="s2">.</span><span class="s1">matches</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">])) {</span>
            <span class="s1">nodes</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">nodeList</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]);</span>
            <span class="s1">pos</span><span class="s2">.</span><span class="s1">push</span><span class="s2">([</span><span class="s6">1</span><span class="s2">]);</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
        <span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">nodes</span><span class="s2">, </span><span class="s1">pos</span><span class="s2">: </span><span class="s1">pos</span><span class="s2">, </span><span class="s1">lasts</span><span class="s2">: </span><span class="s1">pos</span><span class="s2">}</span>
      <span class="s2">}</span>
  <span class="s2">};</span>

  <span class="s0">/***************************************************************************</span>
   <span class="s0">*                         Evaluation: functions                           *</span>
   <span class="s0">***************************************************************************/</span>
  <span class="s3">var </span><span class="s1">fn </span><span class="s2">= {</span>
    <span class="s5">'number'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">number</span><span class="s2">(</span><span class="s1">optObject</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'number' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">optObject</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">optObject</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'string' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">optObject</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">parseFloat</span><span class="s2">(</span><span class="s1">optObject</span><span class="s2">);  </span><span class="s4">// note: parseFloat(' ') -&gt; NaN, unlike +' ' -&gt; 0.</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'boolean' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">optObject</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s2">+</span><span class="s1">optObject</span><span class="s2">;</span>
      <span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s3">this</span><span class="s2">, </span><span class="s1">optObject</span><span class="s2">));  </span><span class="s4">// for node-sets</span>
    <span class="s2">},</span>
    <span class="s5">'string'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">string</span><span class="s2">(</span><span class="s1">optObject</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">optObject</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s3">this</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'string' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">optObject </span><span class="s2">|| </span><span class="s5">'boolean' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">optObject </span><span class="s2">||</span>
          <span class="s5">'number' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">optObject</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s5">'' </span><span class="s2">+ </span><span class="s1">optObject</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">== </span><span class="s1">optObject</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) </span><span class="s3">return </span><span class="s5">''</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">optObject</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">textContent</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">optObject</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">textContent</span><span class="s2">;</span>
      <span class="s3">return </span><span class="s1">optObject</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">nodeValue</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'boolean'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">booleanVal</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">x </span><span class="s2">? </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length </span><span class="s2">&gt; </span><span class="s6">0 </span><span class="s2">: !!</span><span class="s1">x</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'last'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">last</span><span class="s2">() {</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">isArray</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">));</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">isArray</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">));</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">[</span><span class="s6">0</span><span class="s2">][</span><span class="s6">0</span><span class="s2">];</span>
    <span class="s2">},</span>
    <span class="s5">'position'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">position</span><span class="s2">() {</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">isArray</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">));</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">isArray</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">));</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">lasts</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s6">1 </span><span class="s2">=== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">length</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s6">0</span><span class="s2">][</span><span class="s6">0</span><span class="s2">];</span>
    <span class="s2">},</span>
    <span class="s5">'count'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">count</span><span class="s2">(</span><span class="s1">nodeSet</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">!== </span><span class="s3">typeof </span><span class="s1">nodeSet</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Position ' </span><span class="s2">+ </span><span class="s1">stream</span><span class="s2">.</span><span class="s1">position</span><span class="s2">() +</span>
                                 <span class="s5">': Function count(node-set) ' </span><span class="s2">+</span>
                                 <span class="s5">'got wrong argument type: ' </span><span class="s2">+ </span><span class="s1">nodeSet</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">nodeSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'id'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">id</span><span class="s2">(</span><span class="s1">object</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">r </span><span class="s2">= {</span><span class="s1">nodes</span><span class="s2">: []};</span>
      <span class="s3">var </span><span class="s1">doc </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">ownerDocument </span><span class="s2">|| </span><span class="s3">this</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">];</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">ids</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">object</span><span class="s2">) {</span>
        <span class="s4">// for node-sets, map id over each node value.</span>
        <span class="s1">ids </span><span class="s2">= [];</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">object</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">idNode </span><span class="s2">= </span><span class="s1">object</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
          <span class="s3">var </span><span class="s1">idsString </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">idNode</span><span class="s2">]});</span>
          <span class="s3">var </span><span class="s1">a </span><span class="s2">= </span><span class="s1">idsString</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s7">/[ \t\r\n]+/g</span><span class="s2">);</span>
          <span class="s1">Array</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">push</span><span class="s2">.</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">ids</span><span class="s2">, </span><span class="s1">a</span><span class="s2">);</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">var </span><span class="s1">idsString </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">object</span><span class="s2">);</span>
        <span class="s3">var </span><span class="s1">a </span><span class="s2">= </span><span class="s1">idsString</span><span class="s2">.</span><span class="s1">split</span><span class="s2">(</span><span class="s7">/[ \t\r\n]+/g</span><span class="s2">);</span>
        <span class="s1">ids </span><span class="s2">= </span><span class="s1">a</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">ids</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">id </span><span class="s2">= </span><span class="s1">ids</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">id</span><span class="s2">.</span><span class="s1">length</span><span class="s2">)</span>
          <span class="s3">continue</span><span class="s2">;</span>
        <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">doc</span><span class="s2">.</span><span class="s1">getElementById</span><span class="s2">(</span><span class="s1">id</span><span class="s2">);</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">node</span><span class="s2">)</span>
          <span class="s1">r</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s1">r</span><span class="s2">.</span><span class="s1">nodes </span><span class="s2">= </span><span class="s1">sortUniqDocumentOrder</span><span class="s2">(</span><span class="s1">r</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'local-name'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">nodeSet</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeSet</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">name</span><span class="s2">(</span><span class="s3">this</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">) {</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'argument to name() must be a node-set. got ' </span><span class="s2">+ </span><span class="s1">nodeSet</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">// TODO: namespaced version</span>
      <span class="s3">return </span><span class="s1">nodeSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">localName</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'namespace-uri'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">nodeSet</span><span class="s2">) {</span>
      <span class="s4">// TODO</span>
      <span class="s3">throw new </span><span class="s1">Error</span><span class="s2">(</span><span class="s5">'not implemented yet'</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'name'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">nodeSet</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeSet</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">name</span><span class="s2">(</span><span class="s3">this</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">nodeSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">) {</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'argument to name() must be a node-set. got ' </span><span class="s2">+ </span><span class="s1">nodeSet</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s1">nodeSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">].</span><span class="s1">name</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'concat'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">concat</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">l </span><span class="s2">= [];</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">arguments</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s1">l</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">arguments</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]));</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s1">l</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s5">''</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'starts-with'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">startsWith</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s2">as = </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s1">bs </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s2">as.</span><span class="s1">substr</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">bs</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) === </span><span class="s1">bs</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'contains'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">contains</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s2">as = </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s1">bs </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">i </span><span class="s2">= as.</span><span class="s1">indexOf</span><span class="s2">(</span><span class="s1">bs</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(-</span><span class="s6">1 </span><span class="s2">=== </span><span class="s1">i</span><span class="s2">) </span><span class="s3">return false</span><span class="s2">;</span>
      <span class="s3">return true</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'substring-before'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">substringBefore</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s2">as = </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s1">bs </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">i </span><span class="s2">= as.</span><span class="s1">indexOf</span><span class="s2">(</span><span class="s1">bs</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(-</span><span class="s6">1 </span><span class="s2">=== </span><span class="s1">i</span><span class="s2">) </span><span class="s3">return </span><span class="s5">''</span><span class="s2">;</span>
      <span class="s3">return </span><span class="s2">as.</span><span class="s1">substr</span><span class="s2">(</span><span class="s6">0</span><span class="s2">, </span><span class="s1">i</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'substring-after'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">substringBefore</span><span class="s2">(</span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s2">as = </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">a</span><span class="s2">), </span><span class="s1">bs </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">b</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">i </span><span class="s2">= as.</span><span class="s1">indexOf</span><span class="s2">(</span><span class="s1">bs</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(-</span><span class="s6">1 </span><span class="s2">=== </span><span class="s1">i</span><span class="s2">) </span><span class="s3">return </span><span class="s5">''</span><span class="s2">;</span>
      <span class="s3">return </span><span class="s2">as.</span><span class="s1">substr</span><span class="s2">(</span><span class="s1">i </span><span class="s2">+ </span><span class="s1">bs</span><span class="s2">.</span><span class="s1">length</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'substring'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">substring</span><span class="s2">(</span><span class="s1">string</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">optEnd</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">string </span><span class="s2">|| </span><span class="s3">null </span><span class="s2">== </span><span class="s1">start</span><span class="s2">) {</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                 <span class="s5">'Must be at least 2 arguments to string()'</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s3">var </span><span class="s1">sString </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">string</span><span class="s2">),</span>
          <span class="s1">iStart </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">round</span><span class="s2">(</span><span class="s1">start</span><span class="s2">),</span>
          <span class="s1">iEnd </span><span class="s2">= </span><span class="s1">optEnd </span><span class="s2">== </span><span class="s3">null </span><span class="s2">? </span><span class="s3">null </span><span class="s2">: </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">round</span><span class="s2">(</span><span class="s1">optEnd</span><span class="s2">);</span>
      <span class="s4">// Note that xpath string positions user 1-based index</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">iEnd </span><span class="s2">== </span><span class="s3">null</span><span class="s2">)</span>
        <span class="s3">return </span><span class="s1">sString</span><span class="s2">.</span><span class="s1">substr</span><span class="s2">(</span><span class="s1">iStart </span><span class="s2">- </span><span class="s6">1</span><span class="s2">);</span>
      <span class="s3">else</span>
        <span class="s3">return </span><span class="s1">sString</span><span class="s2">.</span><span class="s1">substr</span><span class="s2">(</span><span class="s1">iStart </span><span class="s2">- </span><span class="s6">1</span><span class="s2">, </span><span class="s1">iEnd</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'string-length'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">stringLength</span><span class="s2">(</span><span class="s1">optString</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s3">this</span><span class="s2">, </span><span class="s1">optString</span><span class="s2">).</span><span class="s1">length</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'normalize-space'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">normalizeSpace</span><span class="s2">(</span><span class="s1">optString</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">s </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s3">this</span><span class="s2">, </span><span class="s1">optString</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">s</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s7">/[ \t\r\n]+/g</span><span class="s2">, </span><span class="s5">' '</span><span class="s2">).</span><span class="s1">replace</span><span class="s2">(</span><span class="s7">/^ | $/g</span><span class="s2">, </span><span class="s5">''</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'translate'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">translate</span><span class="s2">(</span><span class="s1">string</span><span class="s2">, </span><span class="s1">from</span><span class="s2">, </span><span class="s1">to</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">sString </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">.</span><span class="s1">call</span><span class="s2">(</span><span class="s3">this</span><span class="s2">, </span><span class="s1">string</span><span class="s2">),</span>
          <span class="s1">sFrom </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">from</span><span class="s2">),</span>
          <span class="s1">sTo </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">to</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">eachCharRe </span><span class="s2">= [];</span>
      <span class="s3">var </span><span class="s1">map </span><span class="s2">= {};</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">sFrom</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">c </span><span class="s2">= </span><span class="s1">sFrom</span><span class="s2">.</span><span class="s1">charAt</span><span class="s2">(</span><span class="s1">i</span><span class="s2">);</span>
        <span class="s1">map</span><span class="s2">[</span><span class="s1">c</span><span class="s2">] = </span><span class="s1">sTo</span><span class="s2">.</span><span class="s1">charAt</span><span class="s2">(</span><span class="s1">i</span><span class="s2">);  </span><span class="s4">// returns '' if beyond length of sTo.</span>
        <span class="s4">// copied from goog.string.regExpEscape in the Closure library.</span>
        <span class="s1">eachCharRe</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span>
          <span class="s1">c</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s7">/([-()\[\]{}+?*.$\^|,:#&lt;!\\])/g</span><span class="s2">, </span><span class="s5">'</span><span class="s3">\\</span><span class="s5">$1'</span><span class="s2">).</span>
            <span class="s1">replace</span><span class="s2">(</span><span class="s7">/\x08/g</span><span class="s2">, </span><span class="s5">'</span><span class="s3">\\</span><span class="s5">x08'</span><span class="s2">));</span>
      <span class="s2">}</span>
      <span class="s3">var </span><span class="s1">re </span><span class="s2">= </span><span class="s3">new </span><span class="s1">RegExp</span><span class="s2">(</span><span class="s1">eachCharRe</span><span class="s2">.</span><span class="s1">join</span><span class="s2">(</span><span class="s5">'|'</span><span class="s2">), </span><span class="s5">'g'</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">sString</span><span class="s2">.</span><span class="s1">replace</span><span class="s2">(</span><span class="s1">re</span><span class="s2">, </span><span class="s3">function</span><span class="s2">(</span><span class="s1">c</span><span class="s2">) {</span><span class="s3">return </span><span class="s1">map</span><span class="s2">[</span><span class="s1">c</span><span class="s2">];});</span>
    <span class="s2">},</span>
    <span class="s4">/// Boolean functions</span>
    <span class="s5">'not'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">not</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">bx </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">[</span><span class="s5">'boolean'</span><span class="s2">](</span><span class="s1">x</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s2">!</span><span class="s1">bx</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'true'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">trueVal</span><span class="s2">() { </span><span class="s3">return true</span><span class="s2">; },</span>
    <span class="s5">'false'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">falseVal</span><span class="s2">() { </span><span class="s3">return false</span><span class="s2">; },</span>
    <span class="s4">// TODO</span>
    <span class="s5">'lang'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">lang</span><span class="s2">(</span><span class="s1">string</span><span class="s2">) { </span><span class="s3">throw new </span><span class="s1">Error</span><span class="s2">(</span><span class="s5">'Not implemented'</span><span class="s2">);},</span>
    <span class="s5">'sum'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">sum</span><span class="s2">(</span><span class="s1">optNodeSet</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">optNodeSet</span><span class="s2">) </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">sum</span><span class="s2">(</span><span class="s3">this</span><span class="s2">);</span>
      <span class="s4">// for node-sets, map id over each node value.</span>
      <span class="s3">var </span><span class="s1">sum </span><span class="s2">= </span><span class="s6">0</span><span class="s2">;</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">optNodeSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">optNodeSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
        <span class="s3">var </span><span class="s1">x </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">node</span><span class="s2">]});</span>
        <span class="s1">sum </span><span class="s2">+= </span><span class="s1">x</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">return </span><span class="s1">sum</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s5">'floor'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">floor</span><span class="s2">(</span><span class="s1">number</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">Math</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">number</span><span class="s2">));</span>
    <span class="s2">},</span>
    <span class="s5">'ceiling'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">ceiling</span><span class="s2">(</span><span class="s1">number</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">Math</span><span class="s2">.</span><span class="s1">ceil</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">number</span><span class="s2">));</span>
    <span class="s2">},</span>
    <span class="s5">'round'</span><span class="s2">: </span><span class="s3">function </span><span class="s1">round</span><span class="s2">(</span><span class="s1">number</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">Math</span><span class="s2">.</span><span class="s1">round</span><span class="s2">(</span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">number</span><span class="s2">));</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
  <span class="s0">/***************************************************************************</span>
   <span class="s0">*                         Evaluation: operators                           *</span>
   <span class="s0">***************************************************************************/</span>
  <span class="s3">var </span><span class="s1">more </span><span class="s2">= {</span>
    <span class="s1">UnaryMinus</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) { </span><span class="s3">return </span><span class="s2">-</span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">); },</span>
    <span class="s5">'+'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) + </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">); },</span>
    <span class="s5">'-'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) - </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">); },</span>
    <span class="s5">'*'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) * </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">); },</span>
    <span class="s5">'div'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) / </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">); },</span>
    <span class="s5">'mod'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) % </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">); },</span>
    <span class="s5">'&lt;'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">comparisonHelper</span><span class="s2">(</span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &lt; </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">);}, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">true</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'&lt;='</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">comparisonHelper</span><span class="s2">(</span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &lt;= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">);}, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">true</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'&gt;'</span><span class="s2">:  </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">comparisonHelper</span><span class="s2">(</span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &gt; </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">);}, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">true</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'&gt;='</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span>
      <span class="s3">return </span><span class="s1">comparisonHelper</span><span class="s2">(</span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) &gt;= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">y</span><span class="s2">);}, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">true</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s5">'and'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">[</span><span class="s5">'boolean'</span><span class="s2">](</span><span class="s1">x</span><span class="s2">) &amp;&amp; </span><span class="s1">fn</span><span class="s2">[</span><span class="s5">'boolean'</span><span class="s2">](</span><span class="s1">y</span><span class="s2">); },</span>
    <span class="s5">'or'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s1">fn</span><span class="s2">[</span><span class="s5">'boolean'</span><span class="s2">](</span><span class="s1">x</span><span class="s2">) || </span><span class="s1">fn</span><span class="s2">[</span><span class="s5">'boolean'</span><span class="s2">](</span><span class="s1">y</span><span class="s2">); },</span>
    <span class="s5">'|'</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) { </span><span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">mergeNodeLists</span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">, </span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">)}; },</span>
    <span class="s5">'='</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span>
      <span class="s4">// optimization for two node-sets case: avoid n^2 comparisons.</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">x </span><span class="s2">&amp;&amp; </span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">y</span><span class="s2">) {</span>
        <span class="s3">var </span><span class="s1">aMap </span><span class="s2">= {};</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">s </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]});</span>
          <span class="s1">aMap</span><span class="s2">[</span><span class="s1">s</span><span class="s2">] = </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">s </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]});</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">aMap</span><span class="s2">[</span><span class="s1">s</span><span class="s2">]) </span><span class="s3">return true</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">return false</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s1">comparisonHelper</span><span class="s2">(</span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span><span class="s3">return </span><span class="s1">x </span><span class="s2">=== </span><span class="s1">y</span><span class="s2">;}, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s5">'!='</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span>
      <span class="s4">// optimization for two node-sets case: avoid n^2 comparisons.</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">x </span><span class="s2">&amp;&amp; </span><span class="s5">'object' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">y</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length </span><span class="s2">|| </span><span class="s6">0 </span><span class="s2">=== </span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">) </span><span class="s3">return false</span><span class="s2">;</span>
        <span class="s3">var </span><span class="s1">aMap </span><span class="s2">= {};</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">s </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]});</span>
          <span class="s1">aMap</span><span class="s2">[</span><span class="s1">s</span><span class="s2">] = </span><span class="s3">true</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s3">var </span><span class="s1">s </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">({</span><span class="s1">nodes</span><span class="s2">:[</span><span class="s1">y</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">i</span><span class="s2">]]});</span>
          <span class="s3">if </span><span class="s2">(!</span><span class="s1">aMap</span><span class="s2">[</span><span class="s1">s</span><span class="s2">]) </span><span class="s3">return true</span><span class="s2">;</span>
        <span class="s2">}</span>
        <span class="s3">return false</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s1">comparisonHelper</span><span class="s2">(</span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">) {</span><span class="s3">return </span><span class="s1">x </span><span class="s2">!== </span><span class="s1">y</span><span class="s2">;}, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
  <span class="s3">var </span><span class="s1">nodeTypes </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">nodeTypes </span><span class="s2">= {</span>
    <span class="s5">'node'</span><span class="s2">: </span><span class="s6">0</span><span class="s2">,</span>
    <span class="s5">'attribute'</span><span class="s2">: </span><span class="s6">2</span><span class="s2">,</span>
    <span class="s5">'comment'</span><span class="s2">: </span><span class="s6">8</span><span class="s2">, </span><span class="s4">// this.doc.COMMENT_NODE,</span>
    <span class="s5">'text'</span><span class="s2">: </span><span class="s6">3</span><span class="s2">, </span><span class="s4">// this.doc.TEXT_NODE,</span>
    <span class="s5">'processing-instruction'</span><span class="s2">: </span><span class="s6">7</span><span class="s2">, </span><span class="s4">// this.doc.PROCESSING_INSTRUCTION_NODE,</span>
    <span class="s5">'element'</span><span class="s2">: </span><span class="s6">1  </span><span class="s4">//this.doc.ELEMENT_NODE</span>
  <span class="s2">};</span>
  <span class="s0">/** For debugging and unit tests: returnjs a stringified version of the</span>
   <span class="s0">* argument. */</span>
  <span class="s3">var </span><span class="s1">stringifyObject </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">stringifyObject </span><span class="s2">= </span><span class="s3">function </span><span class="s1">stringifyObject</span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">seenKey </span><span class="s2">= </span><span class="s5">'seen' </span><span class="s2">+ </span><span class="s1">Math</span><span class="s2">.</span><span class="s1">floor</span><span class="s2">(</span><span class="s1">Math</span><span class="s2">.</span><span class="s1">random</span><span class="s2">()*</span><span class="s6">1000000000</span><span class="s2">);</span>
    <span class="s3">return </span><span class="s1">JSON</span><span class="s2">.</span><span class="s1">stringify</span><span class="s2">(</span><span class="s1">helper</span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">));</span>

    <span class="s3">function </span><span class="s1">helper</span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">Array</span><span class="s2">.</span><span class="s1">isArray</span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">)) {</span>
        <span class="s3">return </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">map</span><span class="s2">(</span><span class="s3">function</span><span class="s2">(</span><span class="s1">x</span><span class="s2">) {</span><span class="s3">return </span><span class="s1">helper</span><span class="s2">(</span><span class="s1">x</span><span class="s2">);});</span>
      <span class="s2">}</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">!== </span><span class="s3">typeof </span><span class="s1">ctx</span><span class="s2">) </span><span class="s3">return </span><span class="s1">ctx</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">ctx</span><span class="s2">) </span><span class="s3">return </span><span class="s1">ctx</span><span class="s2">;</span>
    <span class="s4">//  if (ctx.toString) return ctx.toString();</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">outerHTML</span><span class="s2">) </span><span class="s3">return </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">outerHTML</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">nodeValue</span><span class="s2">) </span><span class="s3">return </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">nodeName </span><span class="s2">+ </span><span class="s5">'=' </span><span class="s2">+ </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">nodeValue</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">[</span><span class="s1">seenKey</span><span class="s2">]) </span><span class="s3">return </span><span class="s5">'[circular]'</span><span class="s2">;</span>
      <span class="s1">ctx</span><span class="s2">[</span><span class="s1">seenKey</span><span class="s2">] = </span><span class="s3">true</span><span class="s2">;</span>
      <span class="s3">var </span><span class="s1">nicer </span><span class="s2">= {};</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">ctx</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s1">seenKey </span><span class="s2">=== </span><span class="s1">key</span><span class="s2">)</span>
          <span class="s3">continue</span><span class="s2">;</span>
        <span class="s3">try </span><span class="s2">{</span>
          <span class="s1">nicer</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s1">helper</span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">[</span><span class="s1">key</span><span class="s2">]);</span>
        <span class="s2">} </span><span class="s3">catch </span><span class="s2">(</span><span class="s1">e</span><span class="s2">) {</span>
          <span class="s1">nicer</span><span class="s2">[</span><span class="s1">key</span><span class="s2">] = </span><span class="s5">'[exception: ' </span><span class="s2">+ </span><span class="s1">e</span><span class="s2">.</span><span class="s1">message </span><span class="s2">+ </span><span class="s5">']'</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
      <span class="s3">delete </span><span class="s1">ctx</span><span class="s2">[</span><span class="s1">seenKey</span><span class="s2">];</span>
      <span class="s3">return </span><span class="s1">nicer</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s3">var </span><span class="s1">Evaluator </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">Evaluator </span><span class="s2">= </span><span class="s3">function </span><span class="s1">Evaluator</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">) {</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">doc </span><span class="s2">= </span><span class="s1">doc</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s1">Evaluator</span><span class="s2">.</span><span class="s1">prototype </span><span class="s2">= {</span>
    <span class="s1">val</span><span class="s2">: </span><span class="s3">function </span><span class="s1">val</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">) {</span>
      <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">);</span>

      <span class="s3">if </span><span class="s2">(</span><span class="s5">'number' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">ast </span><span class="s2">|| </span><span class="s5">'string' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">ast</span><span class="s2">) </span><span class="s3">return </span><span class="s1">ast</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">more</span><span class="s2">[</span><span class="s1">ast</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]]) {</span>
        <span class="s3">var </span><span class="s1">evaluatedParams </span><span class="s2">= [];</span>
        <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">1</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">ast</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
          <span class="s1">evaluatedParams</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">val</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">ctx</span><span class="s2">));</span>
        <span class="s2">}</span>
        <span class="s3">var </span><span class="s1">r </span><span class="s2">= </span><span class="s1">more</span><span class="s2">[</span><span class="s1">ast</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]].</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">evaluatedParams</span><span class="s2">);</span>
        <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s3">switch </span><span class="s2">(</span><span class="s1">ast</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) {</span>
        <span class="s3">case </span><span class="s5">'Root'</span><span class="s2">: </span><span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">: [</span><span class="s3">this</span><span class="s2">.</span><span class="s1">doc</span><span class="s2">]};</span>
        <span class="s3">case </span><span class="s5">'FunctionCall'</span><span class="s2">:</span>
          <span class="s3">var </span><span class="s1">functionName </span><span class="s2">= </span><span class="s1">ast</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">functionParams </span><span class="s2">= </span><span class="s1">ast</span><span class="s2">[</span><span class="s6">2</span><span class="s2">];</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">fn</span><span class="s2">[</span><span class="s1">functionName</span><span class="s2">])</span>
            <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR</span><span class="s2">,</span>
                                     <span class="s5">'Unknown function: ' </span><span class="s2">+ </span><span class="s1">functionName</span><span class="s2">);</span>
          <span class="s3">var </span><span class="s1">evaluatedParams </span><span class="s2">= [];</span>
          <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">functionParams</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
            <span class="s1">evaluatedParams</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">val</span><span class="s2">(</span><span class="s1">functionParams</span><span class="s2">[</span><span class="s1">i</span><span class="s2">], </span><span class="s1">ctx</span><span class="s2">));</span>
          <span class="s2">}</span>
          <span class="s3">var </span><span class="s1">r </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">[</span><span class="s1">functionName</span><span class="s2">].</span><span class="s1">apply</span><span class="s2">(</span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">evaluatedParams</span><span class="s2">);</span>
          <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
        <span class="s3">case </span><span class="s5">'Predicate'</span><span class="s2">:</span>
          <span class="s3">var </span><span class="s1">lhs </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">val</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">ctx</span><span class="s2">);</span>
          <span class="s3">var </span><span class="s1">ret </span><span class="s2">= {</span><span class="s1">nodes</span><span class="s2">: []};</span>
          <span class="s3">var </span><span class="s1">contexts </span><span class="s2">= </span><span class="s1">eachContext</span><span class="s2">(</span><span class="s1">lhs</span><span class="s2">);</span>
          <span class="s3">for </span><span class="s2">(</span><span class="s3">var </span><span class="s1">i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i </span><span class="s2">&lt; </span><span class="s1">contexts</span><span class="s2">.</span><span class="s1">length</span><span class="s2">; ++</span><span class="s1">i</span><span class="s2">) {</span>
            <span class="s3">var </span><span class="s1">singleNodeSet </span><span class="s2">= </span><span class="s1">contexts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">];</span>
            <span class="s3">var </span><span class="s1">rhs </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">val</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">[</span><span class="s6">2</span><span class="s2">], </span><span class="s1">singleNodeSet</span><span class="s2">);</span>
            <span class="s3">var </span><span class="s1">success</span><span class="s2">;</span>
            <span class="s3">if </span><span class="s2">(</span><span class="s5">'number' </span><span class="s2">=== </span><span class="s3">typeof </span><span class="s1">rhs</span><span class="s2">) {</span>
              <span class="s1">success </span><span class="s2">= </span><span class="s1">rhs </span><span class="s2">=== </span><span class="s1">singleNodeSet</span><span class="s2">.</span><span class="s1">pos</span><span class="s2">[</span><span class="s6">0</span><span class="s2">][</span><span class="s6">0</span><span class="s2">];</span>
            <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
              <span class="s1">success </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">[</span><span class="s5">'boolean'</span><span class="s2">](</span><span class="s1">rhs</span><span class="s2">);</span>
            <span class="s2">}</span>
            <span class="s3">if </span><span class="s2">(</span><span class="s1">success</span><span class="s2">) {</span>
              <span class="s3">var </span><span class="s1">node </span><span class="s2">= </span><span class="s1">singleNodeSet</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">];</span>
              <span class="s1">ret</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">push</span><span class="s2">(</span><span class="s1">node</span><span class="s2">);</span>
              <span class="s4">// skip over all the rest of the same node.</span>
              <span class="s3">while </span><span class="s2">(</span><span class="s1">i</span><span class="s2">+</span><span class="s6">1 </span><span class="s2">&lt; </span><span class="s1">contexts</span><span class="s2">.</span><span class="s1">length </span><span class="s2">&amp;&amp; </span><span class="s1">node </span><span class="s2">=== </span><span class="s1">contexts</span><span class="s2">[</span><span class="s1">i</span><span class="s2">+</span><span class="s6">1</span><span class="s2">].</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">]) {</span>
                <span class="s1">i</span><span class="s2">++;</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
          <span class="s3">return </span><span class="s1">ret</span><span class="s2">;</span>
        <span class="s3">case </span><span class="s5">'PathExpr'</span><span class="s2">:</span>
          <span class="s4">// turn the path into an expressoin; i.e., remove the position</span>
          <span class="s4">// information of the last axis.</span>
          <span class="s3">var </span><span class="s1">x </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">val</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">ctx</span><span class="s2">);</span>
          <span class="s4">// Make the nodeset a forward-direction-only one.</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s1">x</span><span class="s2">.</span><span class="s1">finalize</span><span class="s2">) {  </span><span class="s4">// it is a NodeMultiSet</span>
            <span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">: </span><span class="s1">x</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">};</span>
          <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
            <span class="s3">return </span><span class="s1">x</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s3">case </span><span class="s5">'/'</span><span class="s2">:</span>
          <span class="s4">// TODO: don't generate '/' nodes, just Axis nodes.</span>
          <span class="s3">var </span><span class="s1">lhs </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">val</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">[</span><span class="s6">1</span><span class="s2">], </span><span class="s1">ctx</span><span class="s2">);</span>
          <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">lhs</span><span class="s2">);</span>
          <span class="s3">var </span><span class="s1">r </span><span class="s2">= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">val</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">[</span><span class="s6">2</span><span class="s2">], </span><span class="s1">lhs</span><span class="s2">);</span>
          <span class="s1">console</span><span class="s2">.</span><span class="s1">assert</span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s1">r</span><span class="s2">);</span>
          <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
        <span class="s3">case </span><span class="s5">'Axis'</span><span class="s2">:</span>
          <span class="s4">// All the axis tests from Step. We only get AxisSpecifier NodeTest,</span>
          <span class="s4">// not the predicate (which is applied later)</span>
          <span class="s3">var </span><span class="s1">axis </span><span class="s2">= </span><span class="s1">ast</span><span class="s2">[</span><span class="s6">1</span><span class="s2">],</span>
              <span class="s1">nodeType </span><span class="s2">= </span><span class="s1">ast</span><span class="s2">[</span><span class="s6">2</span><span class="s2">],</span>
              <span class="s1">nodeTypeNum </span><span class="s2">= </span><span class="s1">nodeTypes</span><span class="s2">[</span><span class="s1">nodeType</span><span class="s2">],</span>
              <span class="s1">shouldLowerCase </span><span class="s2">= </span><span class="s3">true</span><span class="s2">,  </span><span class="s4">// TODO: give option</span>
              <span class="s1">nodeName </span><span class="s2">= </span><span class="s1">ast</span><span class="s2">[</span><span class="s6">3</span><span class="s2">] &amp;&amp; </span><span class="s1">shouldLowerCase </span><span class="s2">? </span><span class="s1">ast</span><span class="s2">[</span><span class="s6">3</span><span class="s2">].</span><span class="s1">toLowerCase</span><span class="s2">() : </span><span class="s1">ast</span><span class="s2">[</span><span class="s6">3</span><span class="s2">];</span>
          <span class="s1">nodeName </span><span class="s2">= </span><span class="s1">nodeName </span><span class="s2">=== </span><span class="s5">'*' </span><span class="s2">? </span><span class="s3">null </span><span class="s2">: </span><span class="s1">nodeName</span><span class="s2">;</span>
          <span class="s3">if </span><span class="s2">(</span><span class="s5">'object' </span><span class="s2">!== </span><span class="s3">typeof </span><span class="s1">ctx</span><span class="s2">) </span><span class="s3">return </span><span class="s2">{</span><span class="s1">nodes</span><span class="s2">:[], </span><span class="s1">pos</span><span class="s2">:[]};</span>
          <span class="s3">var </span><span class="s1">nodeList </span><span class="s2">= </span><span class="s1">ctx</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">slice</span><span class="s2">();  </span><span class="s4">// TODO: is copy needed?</span>
          <span class="s3">var </span><span class="s1">r </span><span class="s2">= </span><span class="s1">axes</span><span class="s2">[</span><span class="s1">axis</span><span class="s2">](</span><span class="s1">nodeList  </span><span class="s4">/*destructive!*/</span><span class="s2">, </span><span class="s1">nodeTypeNum</span><span class="s2">, </span><span class="s1">nodeName</span><span class="s2">, </span><span class="s1">shouldLowerCase</span><span class="s2">);</span>
          <span class="s3">return </span><span class="s1">r</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
  <span class="s3">var </span><span class="s1">evaluate </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">evaluate </span><span class="s2">= </span><span class="s3">function </span><span class="s1">evaluate</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">, </span><span class="s1">doc</span><span class="s2">, </span><span class="s1">context</span><span class="s2">) {</span>
    <span class="s4">//var astFactory = new AstEvaluatorFactory(doc, context);</span>
    <span class="s3">var </span><span class="s1">stream </span><span class="s2">= </span><span class="s3">new </span><span class="s1">Stream</span><span class="s2">(</span><span class="s1">expr</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">ast </span><span class="s2">= </span><span class="s1">parse</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">astFactory</span><span class="s2">);</span>
    <span class="s3">var </span><span class="s1">val </span><span class="s2">= </span><span class="s3">new </span><span class="s1">Evaluator</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">).</span><span class="s1">val</span><span class="s2">(</span><span class="s1">ast</span><span class="s2">, {</span><span class="s1">nodes</span><span class="s2">: [</span><span class="s1">context</span><span class="s2">]});</span>
    <span class="s3">return </span><span class="s1">val</span><span class="s2">;</span>
  <span class="s2">}</span>

  <span class="s0">/***************************************************************************</span>
   <span class="s0">*                           DOM interface                                 *</span>
   <span class="s0">***************************************************************************/</span>
  <span class="s3">var </span><span class="s1">XPathException </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">XPathException </span><span class="s2">= </span><span class="s3">function </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">code</span><span class="s2">, </span><span class="s1">message</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">e </span><span class="s2">= </span><span class="s3">new </span><span class="s1">Error</span><span class="s2">(</span><span class="s1">message</span><span class="s2">);</span>
    <span class="s1">e</span><span class="s2">.</span><span class="s1">name </span><span class="s2">= </span><span class="s5">'XPathException'</span><span class="s2">;</span>
    <span class="s1">e</span><span class="s2">.</span><span class="s1">code </span><span class="s2">= </span><span class="s1">code</span><span class="s2">;</span>
    <span class="s3">return </span><span class="s1">e</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s1">XPathException</span><span class="s2">.</span><span class="s1">INVALID_EXPRESSION_ERR </span><span class="s2">= </span><span class="s6">51</span><span class="s2">;</span>
  <span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR </span><span class="s2">= </span><span class="s6">52</span><span class="s2">;</span>


  <span class="s3">var </span><span class="s1">XPathEvaluator </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">XPathEvaluator </span><span class="s2">= </span><span class="s3">function </span><span class="s1">XPathEvaluator</span><span class="s2">() {}</span>
  <span class="s1">XPathEvaluator</span><span class="s2">.</span><span class="s1">prototype </span><span class="s2">= {</span>
    <span class="s1">createExpression</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">, </span><span class="s1">resolver</span><span class="s2">) {</span>
      <span class="s3">return new </span><span class="s1">XPathExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">, </span><span class="s1">resolver</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s1">createNSResolver</span><span class="s2">: </span><span class="s3">function</span><span class="s2">(</span><span class="s1">nodeResolver</span><span class="s2">) {</span>
      <span class="s4">// TODO</span>
    <span class="s2">},</span>
    <span class="s1">evaluate</span><span class="s2">: </span><span class="s3">function </span><span class="s1">evaluate</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">, </span><span class="s1">contextNode</span><span class="s2">, </span><span class="s1">resolver</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">result</span><span class="s2">) {</span>
      <span class="s3">var </span><span class="s1">expr </span><span class="s2">= </span><span class="s3">new </span><span class="s1">XPathExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">, </span><span class="s1">resolver</span><span class="s2">);</span>
      <span class="s3">return </span><span class="s1">expr</span><span class="s2">.</span><span class="s1">evaluate</span><span class="s2">(</span><span class="s1">contextNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">result</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">};</span>


  <span class="s3">var </span><span class="s1">XPathExpression </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">XPathExpression </span><span class="s2">= </span><span class="s3">function </span><span class="s1">XPathExpression</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">, </span><span class="s1">resolver</span><span class="s2">, </span><span class="s1">optDoc</span><span class="s2">) {</span>
    <span class="s3">var </span><span class="s1">stream </span><span class="s2">= </span><span class="s3">new </span><span class="s1">Stream</span><span class="s2">(</span><span class="s1">expression</span><span class="s2">);</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">_ast </span><span class="s2">= </span><span class="s1">parse</span><span class="s2">(</span><span class="s1">stream</span><span class="s2">, </span><span class="s1">astFactory</span><span class="s2">);</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">_doc </span><span class="s2">= </span><span class="s1">optDoc</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s1">XPathExpression</span><span class="s2">.</span><span class="s1">prototype </span><span class="s2">= {</span>
    <span class="s1">evaluate</span><span class="s2">: </span><span class="s3">function </span><span class="s1">evaluate</span><span class="s2">(</span><span class="s1">contextNode</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">result</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">== </span><span class="s1">contextNode</span><span class="s2">.</span><span class="s1">nodeType</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">Error</span><span class="s2">(</span><span class="s5">'bad argument (expected context node): ' </span><span class="s2">+ </span><span class="s1">contextNode</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">doc </span><span class="s2">= </span><span class="s1">contextNode</span><span class="s2">.</span><span class="s1">ownerDocument </span><span class="s2">|| </span><span class="s1">contextNode</span><span class="s2">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">null </span><span class="s2">!= </span><span class="s3">this</span><span class="s2">.</span><span class="s1">_doc </span><span class="s2">&amp;&amp; </span><span class="s3">this</span><span class="s2">.</span><span class="s1">_doc </span><span class="s2">!== </span><span class="s1">doc</span><span class="s2">) {</span>
        <span class="s3">throw new </span><span class="s1">core</span><span class="s2">.</span><span class="s1">DOMException</span><span class="s2">(</span>
            <span class="s1">core</span><span class="s2">.</span><span class="s1">DOMException</span><span class="s2">.</span><span class="s1">WRONG_DOCUMENT_ERR</span><span class="s2">,</span>
            <span class="s5">'The document must be the same as the context node</span><span class="s3">\'</span><span class="s5">s document.'</span><span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s3">var </span><span class="s1">evaluator </span><span class="s2">= </span><span class="s3">new </span><span class="s1">Evaluator</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">);</span>
      <span class="s3">var </span><span class="s1">value </span><span class="s2">= </span><span class="s1">evaluator</span><span class="s2">.</span><span class="s1">val</span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">_ast</span><span class="s2">, {</span><span class="s1">nodes</span><span class="s2">: [</span><span class="s1">contextNode</span><span class="s2">]});</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">NUMBER_TYPE </span><span class="s2">=== </span><span class="s1">type</span><span class="s2">)</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">number</span><span class="s2">(</span><span class="s1">value</span><span class="s2">);</span>
      <span class="s3">else if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">STRING_TYPE </span><span class="s2">=== </span><span class="s1">type</span><span class="s2">)</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">.</span><span class="s1">string</span><span class="s2">(</span><span class="s1">value</span><span class="s2">);</span>
      <span class="s3">else if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">BOOLEAN_TYPE </span><span class="s2">=== </span><span class="s1">type</span><span class="s2">)</span>
        <span class="s1">value </span><span class="s2">= </span><span class="s1">fn</span><span class="s2">[</span><span class="s5">'boolean'</span><span class="s2">](</span><span class="s1">value</span><span class="s2">);</span>
      <span class="s3">else if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ANY_TYPE </span><span class="s2">!== </span><span class="s1">type </span><span class="s2">&amp;&amp;</span>
               <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_ITERATOR_TYPE </span><span class="s2">!== </span><span class="s1">type </span><span class="s2">&amp;&amp;</span>
               <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ORDERED_NODE_ITERATOR_TYPE </span><span class="s2">!== </span><span class="s1">type </span><span class="s2">&amp;&amp;</span>
               <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_SNAPSHOT_TYPE </span><span class="s2">!== </span><span class="s1">type </span><span class="s2">&amp;&amp;</span>
               <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ORDERED_NODE_SNAPSHOT_TYPE </span><span class="s2">!== </span><span class="s1">type </span><span class="s2">&amp;&amp;</span>
               <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ANY_UNORDERED_NODE_TYPE </span><span class="s2">!== </span><span class="s1">type </span><span class="s2">&amp;&amp;</span>
               <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">FIRST_ORDERED_NODE_TYPE </span><span class="s2">!== </span><span class="s1">type</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">core</span><span class="s2">.</span><span class="s1">DOMException</span><span class="s2">(</span>
            <span class="s1">core</span><span class="s2">.</span><span class="s1">DOMException</span><span class="s2">.</span><span class="s1">NOT_SUPPORTED_ERR</span><span class="s2">,</span>
            <span class="s5">'You must provide an XPath result type (0=any).'</span><span class="s2">);</span>
      <span class="s3">else if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ANY_TYPE </span><span class="s2">!== </span><span class="s1">type </span><span class="s2">&amp;&amp;</span>
               <span class="s5">'object' </span><span class="s2">!== </span><span class="s3">typeof </span><span class="s1">value</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span>
            <span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR</span><span class="s2">,</span>
            <span class="s5">'Value should be a node-set: ' </span><span class="s2">+ </span><span class="s1">value</span><span class="s2">);</span>
      <span class="s3">return new </span><span class="s1">XPathResult</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">type</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">var </span><span class="s1">XPathResult </span><span class="s2">= </span><span class="s1">xpath</span><span class="s2">.</span><span class="s1">XPathResult </span><span class="s2">= </span><span class="s3">function </span><span class="s1">XPathResult</span><span class="s2">(</span><span class="s1">doc</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">resultType</span><span class="s2">) {</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">_value </span><span class="s2">= </span><span class="s1">value</span><span class="s2">;</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">_resultType </span><span class="s2">= </span><span class="s1">resultType</span><span class="s2">;</span>
    <span class="s3">this</span><span class="s2">.</span><span class="s1">_i </span><span class="s2">= </span><span class="s6">0</span><span class="s2">;</span>

    <span class="s4">// TODO: we removed mutation events but didn't take care of this. No tests fail, so that's nice, but eventually we</span>
    <span class="s4">// should fix this, preferably by entirely replacing our XPath implementation.</span>
    <span class="s4">// this._invalidated = false;</span>
    <span class="s4">// if (this.resultType === XPathResult.UNORDERED_NODE_ITERATOR_TYPE ||</span>
    <span class="s4">//     this.resultType === XPathResult.ORDERED_NODE_ITERATOR_TYPE) {</span>
    <span class="s4">//   doc.addEventListener('DOMSubtreeModified', invalidate, true);</span>
    <span class="s4">//   var self = this;</span>
    <span class="s4">//   function invalidate() {</span>
    <span class="s4">//     self._invalidated = true;</span>
    <span class="s4">//     doc.removeEventListener('DOMSubtreeModified', invalidate, true);</span>
    <span class="s4">//   }</span>
    <span class="s4">// }</span>
  <span class="s2">}</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ANY_TYPE </span><span class="s2">= </span><span class="s6">0</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">NUMBER_TYPE </span><span class="s2">= </span><span class="s6">1</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">STRING_TYPE </span><span class="s2">= </span><span class="s6">2</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">BOOLEAN_TYPE </span><span class="s2">= </span><span class="s6">3</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_ITERATOR_TYPE </span><span class="s2">= </span><span class="s6">4</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ORDERED_NODE_ITERATOR_TYPE </span><span class="s2">= </span><span class="s6">5</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_SNAPSHOT_TYPE </span><span class="s2">= </span><span class="s6">6</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ORDERED_NODE_SNAPSHOT_TYPE </span><span class="s2">= </span><span class="s6">7</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ANY_UNORDERED_NODE_TYPE </span><span class="s2">= </span><span class="s6">8</span><span class="s2">;</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">FIRST_ORDERED_NODE_TYPE </span><span class="s2">= </span><span class="s6">9</span><span class="s2">;</span>
  <span class="s3">var </span><span class="s1">proto </span><span class="s2">= {</span>
    <span class="s4">// XPathResultType</span>
    <span class="s1">get resultType</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">_resultType</span><span class="s2">) </span><span class="s3">return this</span><span class="s2">.</span><span class="s1">_resultType</span><span class="s2">;</span>
      <span class="s3">switch </span><span class="s2">(</span><span class="s3">typeof this</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">) {</span>
        <span class="s3">case </span><span class="s5">'number'</span><span class="s2">: </span><span class="s3">return </span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">NUMBER_TYPE</span><span class="s2">;</span>
        <span class="s3">case </span><span class="s5">'string'</span><span class="s2">: </span><span class="s3">return </span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">STRING_TYPE</span><span class="s2">;</span>
        <span class="s3">case </span><span class="s5">'boolean'</span><span class="s2">: </span><span class="s3">return </span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">BOOLEAN_TYPE</span><span class="s2">;</span>
        <span class="s3">default</span><span class="s2">: </span><span class="s3">return </span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_ITERATOR_TYPE</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s1">get numberValue</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">NUMBER_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR</span><span class="s2">,</span>
                                 <span class="s5">'You should have asked for a NUMBER_TYPE.'</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">get stringValue</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">STRING_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR</span><span class="s2">,</span>
                                 <span class="s5">'You should have asked for a STRING_TYPE.'</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">get booleanValue</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">BOOLEAN_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span><span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR</span><span class="s2">,</span>
                                 <span class="s5">'You should have asked for a BOOLEAN_TYPE.'</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">get singleNodeValue</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ANY_UNORDERED_NODE_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType </span><span class="s2">&amp;&amp;</span>
          <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">FIRST_ORDERED_NODE_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span>
            <span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR</span><span class="s2">,</span>
            <span class="s5">'You should have asked for a FIRST_ORDERED_NODE_TYPE.'</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s6">0</span><span class="s2">] || </span><span class="s3">null</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">get invalidIteratorState</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_ITERATOR_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType </span><span class="s2">&amp;&amp;</span>
          <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ORDERED_NODE_ITERATOR_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType</span><span class="s2">)</span>
        <span class="s3">return false</span><span class="s2">;</span>
      <span class="s3">return </span><span class="s2">!!</span><span class="s3">this</span><span class="s2">.</span><span class="s1">_invalidated</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">get snapshotLength</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_SNAPSHOT_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType </span><span class="s2">&amp;&amp;</span>
          <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ORDERED_NODE_SNAPSHOT_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span>
            <span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR</span><span class="s2">,</span>
            <span class="s5">'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.'</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">.</span><span class="s1">length</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">iterateNext</span><span class="s2">: </span><span class="s3">function </span><span class="s1">iterateNext</span><span class="s2">() {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_ITERATOR_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType </span><span class="s2">&amp;&amp;</span>
          <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ORDERED_NODE_ITERATOR_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span>
            <span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR</span><span class="s2">,</span>
            <span class="s5">'You should have asked for a ORDERED_NODE_ITERATOR_TYPE.'</span><span class="s2">);</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.</span><span class="s1">invalidIteratorState</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">core</span><span class="s2">.</span><span class="s1">DOMException</span><span class="s2">(</span>
            <span class="s1">core</span><span class="s2">.</span><span class="s1">DOMException</span><span class="s2">.</span><span class="s1">INVALID_STATE_ERR</span><span class="s2">,</span>
            <span class="s5">'The document has been mutated since the result was returned'</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s3">this</span><span class="s2">.</span><span class="s1">_i</span><span class="s2">++] || </span><span class="s3">null</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s1">snapshotItem</span><span class="s2">: </span><span class="s3">function </span><span class="s1">snapshotItem</span><span class="s2">(</span><span class="s1">index</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">UNORDERED_NODE_SNAPSHOT_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType </span><span class="s2">&amp;&amp;</span>
          <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">ORDERED_NODE_SNAPSHOT_TYPE </span><span class="s2">!== </span><span class="s3">this</span><span class="s2">.</span><span class="s1">resultType</span><span class="s2">)</span>
        <span class="s3">throw new </span><span class="s1">XPathException</span><span class="s2">(</span>
            <span class="s1">XPathException</span><span class="s2">.</span><span class="s1">TYPE_ERR</span><span class="s2">,</span>
            <span class="s5">'You should have asked for a ORDERED_NODE_SNAPSHOT_TYPE.'</span><span class="s2">);</span>
      <span class="s3">return this</span><span class="s2">.</span><span class="s1">_value</span><span class="s2">.</span><span class="s1">nodes</span><span class="s2">[</span><span class="s1">index</span><span class="s2">] || </span><span class="s3">null</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
  <span class="s4">// so you can access ANY_TYPE etc. from the instances:</span>
  <span class="s1">XPathResult</span><span class="s2">.</span><span class="s1">prototype </span><span class="s2">= </span><span class="s1">Object</span><span class="s2">.</span><span class="s1">create</span><span class="s2">(</span><span class="s1">XPathResult</span><span class="s2">,</span>
      <span class="s1">Object</span><span class="s2">.</span><span class="s1">keys</span><span class="s2">(</span><span class="s1">proto</span><span class="s2">).</span><span class="s1">reduce</span><span class="s2">(</span><span class="s3">function </span><span class="s2">(</span><span class="s1">descriptors</span><span class="s2">, </span><span class="s1">name</span><span class="s2">) {</span>
        <span class="s1">descriptors</span><span class="s2">[</span><span class="s1">name</span><span class="s2">] = </span><span class="s1">Object</span><span class="s2">.</span><span class="s1">getOwnPropertyDescriptor</span><span class="s2">(</span><span class="s1">proto</span><span class="s2">, </span><span class="s1">name</span><span class="s2">);</span>
        <span class="s3">return </span><span class="s1">descriptors</span><span class="s2">;</span>
      <span class="s2">}, {</span>
        <span class="s1">constructor</span><span class="s2">: {</span>
          <span class="s1">value</span><span class="s2">: </span><span class="s1">XPathResult</span><span class="s2">,</span>
          <span class="s1">writable</span><span class="s2">: </span><span class="s3">true</span><span class="s2">,</span>
          <span class="s1">configurable</span><span class="s2">: </span><span class="s3">true</span>
        <span class="s2">}</span>
      <span class="s2">}));</span>

  <span class="s1">core</span><span class="s2">.</span><span class="s1">XPathException </span><span class="s2">= </span><span class="s1">XPathException</span><span class="s2">;</span>
  <span class="s1">core</span><span class="s2">.</span><span class="s1">XPathExpression </span><span class="s2">= </span><span class="s1">XPathExpression</span><span class="s2">;</span>
  <span class="s1">core</span><span class="s2">.</span><span class="s1">XPathResult </span><span class="s2">= </span><span class="s1">XPathResult</span><span class="s2">;</span>
  <span class="s1">core</span><span class="s2">.</span><span class="s1">XPathEvaluator </span><span class="s2">= </span><span class="s1">XPathEvaluator</span><span class="s2">;</span>

  <span class="s1">core</span><span class="s2">.</span><span class="s1">Document</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">createExpression </span><span class="s2">=</span>
    <span class="s1">XPathEvaluator</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">createExpression</span><span class="s2">;</span>

  <span class="s1">core</span><span class="s2">.</span><span class="s1">Document</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">createNSResolver </span><span class="s2">=</span>
      <span class="s1">XPathEvaluator</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">createNSResolver</span><span class="s2">;</span>

  <span class="s1">core</span><span class="s2">.</span><span class="s1">Document</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">evaluate </span><span class="s2">= </span><span class="s1">XPathEvaluator</span><span class="s2">.</span><span class="s1">prototype</span><span class="s2">.</span><span class="s1">evaluate</span><span class="s2">;</span>

  <span class="s3">return </span><span class="s1">xpath</span><span class="s2">; </span><span class="s4">// for tests</span>
<span class="s2">};</span>
</pre>
</body>
</html>